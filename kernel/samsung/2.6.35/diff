Only in 2.6.35: 2.6.35
Only in 2.6.35/arch/arm/common: fiq_debugger.c
Only in 2.6.35/arch/arm/common: fiq_debugger_ringbuf.h
Only in 2.6.35/arch/arm/common: fiq_glue.S
Only in 2.6.35/arch/arm/common: fiq_glue_setup.c
Only in 2.6.35/arch/arm/configs: aries_captivate_defconfig
Only in 2.6.35/arch/arm/configs: aries_galaxysb_defconfig
Only in 2.6.35/arch/arm/configs: aries_galaxys_defconfig
Only in 2.6.35/arch/arm/configs: aries_vibrant_defconfig
Only in 2.6.35/arch/arm/configs: herring_defconfig
diff -cBr 2.6.35/arch/arm/include/asm/assembler.h linux-2.6.35.y-512ac85/arch/arm/include/asm/assembler.h
*** 2.6.35/arch/arm/include/asm/assembler.h	2011-05-07 19:57:18.256750007 -0400
--- linux-2.6.35.y-512ac85/arch/arm/include/asm/assembler.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 215,221 ****
  	@ Slightly optimised to avoid incrementing the pointer twice
  	usraccoff \instr, \reg, \ptr, \inc, 0, \cond, \abort
  	.if	\rept == 2
! 	usraccoff \instr, \reg, \ptr, \inc, \inc, \cond, \abort
  	.endif
  
  	add\cond \ptr, #\rept * \inc
--- 215,221 ----
  	@ Slightly optimised to avoid incrementing the pointer twice
  	usraccoff \instr, \reg, \ptr, \inc, 0, \cond, \abort
  	.if	\rept == 2
! 	usraccoff \instr, \reg, \ptr, \inc, 4, \cond, \abort
  	.endif
  
  	add\cond \ptr, #\rept * \inc
Only in 2.6.35/arch/arm/include/asm: fiq_debugger.h
Only in 2.6.35/arch/arm/include/asm: fiq_glue.h
diff -cBr 2.6.35/arch/arm/kernel/signal.c linux-2.6.35.y-512ac85/arch/arm/kernel/signal.c
*** 2.6.35/arch/arm/kernel/signal.c	2011-05-07 19:57:18.256750007 -0400
--- linux-2.6.35.y-512ac85/arch/arm/kernel/signal.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 474,482 ****
  	unsigned long handler = (unsigned long)ka->sa.sa_handler;
  	unsigned long retcode;
  	int thumb = 0;
! 	unsigned long cpsr = regs->ARM_cpsr & ~(PSR_f | PSR_E_BIT);
! 
! 	cpsr |= PSR_ENDSTATE;
  
  	/*a
  	 * Maybe we need to deliver a 32-bit signal to a 26-bit task.
--- 474,480 ----
  	unsigned long handler = (unsigned long)ka->sa.sa_handler;
  	unsigned long retcode;
  	int thumb = 0;
! 	unsigned long cpsr = regs->ARM_cpsr & ~PSR_f;
  
  	/*
  	 * Maybe we need to deliver a 32-bit signal to a 26-bit task.
diff -cBr 2.6.35/arch/arm/lib/findbit.S linux-2.6.35.y-512ac85/arch/arm/lib/findbit.S
*** 2.6.35/arch/arm/lib/findbit.S	2011-05-07 19:57:18.256750007 -0400
--- linux-2.6.35.y-512ac85/arch/arm/lib/findbit.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 174,181 ****
   */
  .L_found:
  #if __LINUX_ARM_ARCH__ >= 5
! 		rsb	r0, r3, #0
! 		and	r3, r3, r0
  		clz	r3, r3
  		rsb	r3, r3, #31
  		add	r0, r2, r3
--- 174,181 ----
   */
  .L_found:
  #if __LINUX_ARM_ARCH__ >= 5
! 		rsb	r1, r3, #0
! 		and	r3, r3, r1
  		clz	r3, r3
  		rsb	r3, r3, #31
  		add	r0, r2, r3
***************
*** 190,196 ****
  		addeq	r2, r2, #1
  		mov	r0, r2
  #endif
- 		cmp	r1, r0			@ Clamp to maxbit
- 		movlo	r0, r1
  		mov	pc, lr
  
--- 190,194 ----
diff -cBr 2.6.35/arch/arm/mach-at91/include/mach/at91_mci.h linux-2.6.35.y-512ac85/arch/arm/mach-at91/include/mach/at91_mci.h
*** 2.6.35/arch/arm/mach-at91/include/mach/at91_mci.h	2011-05-07 19:57:18.256750007 -0400
--- linux-2.6.35.y-512ac85/arch/arm/mach-at91/include/mach/at91_mci.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 74,81 ****
  #define			AT91_MCI_TRTYP_BLOCK	(0 << 19)
  #define			AT91_MCI_TRTYP_MULTIPLE	(1 << 19)
  #define			AT91_MCI_TRTYP_STREAM	(2 << 19)
- #define			AT91_MCI_TRTYP_SDIO_BYTE	(4 << 19)
- #define			AT91_MCI_TRTYP_SDIO_BLOCK	(5 << 19)
  
  #define AT91_MCI_BLKR		0x18		/* Block Register */
  #define		AT91_MCI_BLKR_BCNT(n)	((0xffff & (n)) << 0)	/* Block count */
--- 74,79 ----
Only in 2.6.35/arch/arm/mach-s5pv210: adc.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries-btlpm.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries.h
Only in 2.6.35/arch/arm/mach-s5pv210: aries-panel.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries-rfkill.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries-touchkey-led.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries-vibrator.c
Only in 2.6.35/arch/arm/mach-s5pv210: aries-watchdog.c
Only in 2.6.35/arch/arm/mach-s5pv210: coresight.c
Only in 2.6.35/arch/arm/mach-s5pv210: cpu-freq.c
Only in 2.6.35/arch/arm/mach-s5pv210: cpuidle.c
Only in 2.6.35/arch/arm/mach-s5pv210: dev-aries-phone.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring-btlpm.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring.h
Only in 2.6.35/arch/arm/mach-s5pv210: herring-panel.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring-rfkill.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring-touchkey-led.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring-vibrator.c
Only in 2.6.35/arch/arm/mach-s5pv210: herring-watchdog.c
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: adc.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: battery.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: cpu-freq-v210.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: cpuidle.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: gpio-aries.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: gpio-herring.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: gpio-p1.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: gpio-settings.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: media.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: param.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: pm-core.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: power-domain.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: regs-adc.h
Only in 2.6.35/arch/arm/mach-s5pv210/include/mach: regs-audss.h
Only in 2.6.35/arch/arm/mach-s5pv210: mach-aries.c
Only in 2.6.35/arch/arm/mach-s5pv210: mach-aries.c.bln
Only in 2.6.35/arch/arm/mach-s5pv210: mach-herring.c
Only in 2.6.35/arch/arm/mach-s5pv210: pm.c
Only in 2.6.35/arch/arm/mach-s5pv210: power-domain.c
Only in 2.6.35/arch/arm/mach-s5pv210: sec_switch.c
Only in 2.6.35/arch/arm/mach-s5pv210: setup-csis.c
Only in 2.6.35/arch/arm/mach-s5pv210: setup-fb.c
Only in 2.6.35/arch/arm/mach-s5pv210: setup-fimc0.c
Only in 2.6.35/arch/arm/mach-s5pv210: setup-fimc1.c
Only in 2.6.35/arch/arm/mach-s5pv210: setup-fimc2.c
Only in 2.6.35/arch/arm/mach-s5pv210: sleep.S
diff -cBr 2.6.35/arch/arm/mm/cache-v6.S linux-2.6.35.y-512ac85/arch/arm/mm/cache-v6.S
*** 2.6.35/arch/arm/mm/cache-v6.S	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/arm/mm/cache-v6.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 196,205 ****
   *	- end     - virtual end address of region
   */
  v6_dma_inv_range:
- #ifdef CONFIG_DMA_CACHE_RWFO
- 	ldrb	r2, [r0]			@ read for ownership
- 	strb	r2, [r0]			@ write for ownership
- #endif
  	tst	r0, #D_CACHE_LINE_SIZE - 1
  	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
  #ifdef HARVARD_CACHE
--- 196,201 ----
***************
*** 208,217 ****
  	mcrne	p15, 0, r0, c7, c11, 1		@ clean unified line
  #endif
  	tst	r1, #D_CACHE_LINE_SIZE - 1
- #ifdef CONFIG_DMA_CACHE_RWFO
- 	ldrneb	r2, [r1, #-1]			@ read for ownership
- 	strneb	r2, [r1, #-1]			@ write for ownership
- #endif
  	bic	r1, r1, #D_CACHE_LINE_SIZE - 1
  #ifdef HARVARD_CACHE
  	mcrne	p15, 0, r1, c7, c14, 1		@ clean & invalidate D line
--- 204,209 ----
***************
*** 219,224 ****
--- 211,220 ----
  	mcrne	p15, 0, r1, c7, c15, 1		@ clean & invalidate unified line
  #endif
  1:
+ #ifdef CONFIG_DMA_CACHE_RWFO
+ 	ldr	r2, [r0]			@ read for ownership
+ 	str	r2, [r0]			@ write for ownership
+ #endif
  #ifdef HARVARD_CACHE
  	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D line
  #else
***************
*** 226,235 ****
  #endif
  	add	r0, r0, #D_CACHE_LINE_SIZE
  	cmp	r0, r1
- #ifdef CONFIG_DMA_CACHE_RWFO
- 	ldrlo	r2, [r0]			@ read for ownership
- 	strlo	r2, [r0]			@ write for ownership
- #endif
  	blo	1b
  	mov	r0, #0
  	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
--- 222,227 ----
***************
*** 264,275 ****
   *	- end     - virtual end address of region
   */
  ENTRY(v6_dma_flush_range)
- #ifdef CONFIG_DMA_CACHE_RWFO
- 	ldrb	r2, [r0]		@ read for ownership
- 	strb	r2, [r0]		@ write for ownership
- #endif
  	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
  1:
  #ifdef HARVARD_CACHE
  	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D line
  #else
--- 256,267 ----
   *	- end     - virtual end address of region
   */
  ENTRY(v6_dma_flush_range)
  	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
  1:
+ #ifdef CONFIG_DMA_CACHE_RWFO
+ 	ldr	r2, [r0]			@ read for ownership
+ 	str	r2, [r0]			@ write for ownership
+ #endif
  #ifdef HARVARD_CACHE
  	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D line
  #else
***************
*** 277,286 ****
  #endif
  	add	r0, r0, #D_CACHE_LINE_SIZE
  	cmp	r0, r1
- #ifdef CONFIG_DMA_CACHE_RWFO
- 	ldrlob	r2, [r0]			@ read for ownership
- 	strlob	r2, [r0]			@ write for ownership
- #endif
  	blo	1b
  	mov	r0, #0
  	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
--- 269,274 ----
diff -cBr 2.6.35/arch/arm/mm/fault-armv.c linux-2.6.35.y-512ac85/arch/arm/mm/fault-armv.c
*** 2.6.35/arch/arm/mm/fault-armv.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/arm/mm/fault-armv.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 65,94 ****
  	return ret;
  }
  
- #if USE_SPLIT_PTLOCKS
- /*
-  * If we are using split PTE locks, then we need to take the page
-  * lock here.  Otherwise we are using shared mm->page_table_lock
-  * which is already locked, thus cannot take it.
-  */
- static inline void do_pte_lock(spinlock_t *ptl)
- {
- 	/*
- 	 * Use nested version here to indicate that we are already
- 	 * holding one similar spinlock.
- 	 */
- 	spin_lock_nested(ptl, SINGLE_DEPTH_NESTING);
- }
- 
- static inline void do_pte_unlock(spinlock_t *ptl)
- {
- 	spin_unlock(ptl);
- }
- #else /* !USE_SPLIT_PTLOCKS */
- static inline void do_pte_lock(spinlock_t *ptl) {}
- static inline void do_pte_unlock(spinlock_t *ptl) {}
- #endif /* USE_SPLIT_PTLOCKS */
- 
  static int adjust_pte(struct vm_area_struct *vma, unsigned long address,
  	unsigned long pfn)
  {
--- 65,70 ----
***************
*** 113,123 ****
  	 */
  	ptl = pte_lockptr(vma->vm_mm, pmd);
  	pte = pte_offset_map_nested(pmd, address);
! 	do_pte_lock(ptl);
  
  	ret = do_adjust_pte(vma, address, pfn, pte);
  
! 	do_pte_unlock(ptl);
  	pte_unmap_nested(pte);
  
  	return ret;
--- 89,99 ----
  	 */
  	ptl = pte_lockptr(vma->vm_mm, pmd);
  	pte = pte_offset_map_nested(pmd, address);
! 	spin_lock(ptl);
  
  	ret = do_adjust_pte(vma, address, pfn, pte);
  
! 	spin_unlock(ptl);
  	pte_unmap_nested(pte);
  
  	return ret;
diff -cBr 2.6.35/arch/arm/plat-omap/dma.c linux-2.6.35.y-512ac85/arch/arm/plat-omap/dma.c
*** 2.6.35/arch/arm/plat-omap/dma.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/arm/plat-omap/dma.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 30,36 ****
  #include <linux/irq.h>
  #include <linux/io.h>
  #include <linux/slab.h>
- #include <linux/delay.h>
  
  #include <asm/system.h>
  #include <mach/hardware.h>
--- 30,35 ----
***************
*** 994,1010 ****
  	l = dma_read(CCR(lch));
  
  	/*
! 	 * Errata: Inter Frame DMA buffering issue (All OMAP2420 and
! 	 * OMAP2430ES1.0): DMA will wrongly buffer elements if packing and
! 	 * bursting is enabled. This might result in data gets stalled in
! 	 * FIFO at the end of the block.
! 	 * Workaround: DMA channels must have BUFFERING_DISABLED bit set to
! 	 * guarantee no data will stay in the DMA FIFO in case inter frame
! 	 * buffering occurs.
  	 */
! 	if (cpu_is_omap2420() ||
! 	    (cpu_is_omap2430() && (omap_type() == OMAP2430_REV_ES1_0)))
! 		l |= OMAP_DMA_CCR_BUFFERING_DISABLE;
  
  	l |= OMAP_DMA_CCR_EN;
  	dma_write(l, CCR(lch));
--- 993,1003 ----
  	l = dma_read(CCR(lch));
  
  	/*
! 	 * Errata: On ES2.0 BUFFERING disable must be set.
! 	 * This will always fail on ES1.0
  	 */
! 	if (cpu_is_omap24xx())
! 		l |= OMAP_DMA_CCR_EN;
  
  	l |= OMAP_DMA_CCR_EN;
  	dma_write(l, CCR(lch));
***************
*** 1022,1060 ****
  		dma_write(0, CICR(lch));
  
  	l = dma_read(CCR(lch));
! 	/* OMAP3 Errata i541: sDMA FIFO draining does not finish */
! 	if (cpu_is_omap34xx() && (l & OMAP_DMA_CCR_SEL_SRC_DST_SYNC)) {
! 		int i = 0;
! 		u32 sys_cf;
! 
! 		/* Configure No-Standby */
! 		l = dma_read(OCP_SYSCONFIG);
! 		sys_cf = l;
! 		l &= ~DMA_SYSCONFIG_MIDLEMODE_MASK;
! 		l |= DMA_SYSCONFIG_MIDLEMODE(DMA_IDLEMODE_NO_IDLE);
! 		dma_write(l , OCP_SYSCONFIG);
! 
! 		l = dma_read(CCR(lch));
! 		l &= ~OMAP_DMA_CCR_EN;
! 		dma_write(l, CCR(lch));
! 
! 		/* Wait for sDMA FIFO drain */
! 		l = dma_read(CCR(lch));
! 		while (i < 100 && (l & (OMAP_DMA_CCR_RD_ACTIVE |
! 					OMAP_DMA_CCR_WR_ACTIVE))) {
! 			udelay(5);
! 			i++;
! 			l = dma_read(CCR(lch));
! 		}
! 		if (i >= 100)
! 			printk(KERN_ERR "DMA drain did not complete on "
! 					"lch %d\n", lch);
! 		/* Restore OCP_SYSCONFIG */
! 		dma_write(sys_cf, OCP_SYSCONFIG);
! 	} else {
! 		l &= ~OMAP_DMA_CCR_EN;
! 		dma_write(l, CCR(lch));
! 	}
  
  	if (!omap_dma_in_1510_mode() && dma_chan[lch].next_lch != -1) {
  		int next_lch, cur_lch = lch;
--- 1015,1022 ----
  		dma_write(0, CICR(lch));
  
  	l = dma_read(CCR(lch));
! 	l &= ~OMAP_DMA_CCR_EN;
! 	dma_write(l, CCR(lch));
  
  	if (!omap_dma_in_1510_mode() && dma_chan[lch].next_lch != -1) {
  		int next_lch, cur_lch = lch;
diff -cBr 2.6.35/arch/arm/plat-omap/include/plat/dma.h linux-2.6.35.y-512ac85/arch/arm/plat-omap/include/plat/dma.h
*** 2.6.35/arch/arm/plat-omap/include/plat/dma.h	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/arm/plat-omap/include/plat/dma.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 335,344 ****
  #define OMAP2_DMA_MISALIGNED_ERR_IRQ	(1 << 11)
  
  #define OMAP_DMA_CCR_EN			(1 << 7)
- #define OMAP_DMA_CCR_RD_ACTIVE		(1 << 9)
- #define OMAP_DMA_CCR_WR_ACTIVE		(1 << 10)
- #define OMAP_DMA_CCR_SEL_SRC_DST_SYNC	(1 << 24)
- #define OMAP_DMA_CCR_BUFFERING_DISABLE	(1 << 25)
  
  #define OMAP_DMA_DATA_TYPE_S8		0x00
  #define OMAP_DMA_DATA_TYPE_S16		0x01
--- 335,340 ----
Only in 2.6.35/arch/arm/plat-s5p: bootmem.c

Only in 2.6.35/arch/arm/plat-s5p: dev-csis.c
Only in 2.6.35/arch/arm/plat-s5p: dev-mfc.c
Only in 2.6.35/arch/arm/plat-s5p: devs.c
Only in 2.6.35/arch/arm/plat-s5p: hr-time-rtc.c
Only in 2.6.35/arch/arm/plat-s5p/include/plat: csis.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: fb.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: fimc.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: irq-eint-group.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: irq-pm.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: jpeg.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: media.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: mfc.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-csis.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-fb.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-fimc.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-iis.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-ipc.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-keypad.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-mfc.h
Only in 2.6.35/arch/arm/plat-s5p/include/plat: regs-systimer.h

Only in 2.6.35/arch/arm/plat-s5p: irq-eint-group.c
Only in 2.6.35/arch/arm/plat-s5p: irq-pm.c

Only in 2.6.35/arch/arm/plat-s5p: pm.c
Only in 2.6.35/arch/arm/plat-s5p: setup-mfc.c
Only in 2.6.35/arch/arm/plat-s5p: systimer-s5p.c

Only in 2.6.35/arch/arm/plat-samsung/include/plat: regs-otg.h
diff -cBr 2.6.35/arch/ia64/include/asm/system.h linux-2.6.35.y-512ac85/arch/ia64/include/asm/system.h
*** 2.6.35/arch/ia64/include/asm/system.h	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/ia64/include/asm/system.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 272,277 ****
--- 272,281 ----
  
  void default_idle(void);
  
+ #ifdef CONFIG_VIRT_CPU_ACCOUNTING
+ extern void account_system_vtime(struct task_struct *);
+ #endif
+ 
  #endif /* __KERNEL__ */
  
  #endif /* __ASSEMBLY__ */
diff -cBr 2.6.35/arch/ia64/kernel/mca.c linux-2.6.35.y-512ac85/arch/ia64/kernel/mca.c
*** 2.6.35/arch/ia64/kernel/mca.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/ia64/kernel/mca.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1859,1866 ****
  			data = mca_bootmem();
  			first_time = 0;
  		} else
! 			data = (void *)__get_free_pages(GFP_KERNEL,
! 							get_order(sz));
  		if (!data)
  			panic("Could not allocate MCA memory for cpu %d\n",
  					cpu);
--- 1859,1865 ----
  			data = mca_bootmem();
  			first_time = 0;
  		} else
! 			data = __get_free_pages(GFP_KERNEL, get_order(sz));
  		if (!data)
  			panic("Could not allocate MCA memory for cpu %d\n",
  					cpu);
diff -cBr 2.6.35/arch/ia64/sn/pci/tioca_provider.c linux-2.6.35.y-512ac85/arch/ia64/sn/pci/tioca_provider.c
*** 2.6.35/arch/ia64/sn/pci/tioca_provider.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/ia64/sn/pci/tioca_provider.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 509,515 ****
   * use the GART mapped mode.
   */
  static u64
! tioca_dma_map(struct pci_dev *pdev, unsigned long paddr, size_t byte_count, int dma_flags)
  {
  	u64 mapaddr;
  
--- 509,515 ----
   * use the GART mapped mode.
   */
  static u64
! tioca_dma_map(struct pci_dev *pdev, u64 paddr, size_t byte_count, int dma_flags)
  {
  	u64 mapaddr;
  
diff -cBr 2.6.35/arch/microblaze/Makefile linux-2.6.35.y-512ac85/arch/microblaze/Makefile
*** 2.6.35/arch/microblaze/Makefile	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/microblaze/Makefile	2010-11-22 14:01:26.000000000 -0500
***************
*** 72,87 ****
  
  all: linux.bin
  
! # With make 3.82 we cannot mix normal and wildcard targets
! BOOT_TARGETS1 = linux.bin linux.bin.gz
! BOOT_TARGETS2 = simpleImage.%
  
  archclean:
  	$(Q)$(MAKE) $(clean)=$(boot)
  
! $(BOOT_TARGETS1): vmlinux
! 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
! $(BOOT_TARGETS2): vmlinux
  	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
  
  define archhelp
--- 72,83 ----
  
  all: linux.bin
  
! BOOT_TARGETS = linux.bin linux.bin.gz simpleImage.%
  
  archclean:
  	$(Q)$(MAKE) $(clean)=$(boot)
  
! $(BOOT_TARGETS): vmlinux
  	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
  
  define archhelp
diff -cBr 2.6.35/arch/mips/alchemy/mtx-1/platform.c linux-2.6.35.y-512ac85/arch/mips/alchemy/mtx-1/platform.c
*** 2.6.35/arch/mips/alchemy/mtx-1/platform.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/mips/alchemy/mtx-1/platform.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 28,35 ****
  #include <linux/mtd/physmap.h>
  #include <mtd/mtd-abi.h>
  
- #include <asm/mach-au1x00/au1xxx_eth.h>
- 
  static struct gpio_keys_button mtx1_gpio_button[] = {
  	{
  		.gpio = 207,
--- 28,33 ----
***************
*** 142,158 ****
  	&mtx1_mtd,
  };
  
- static struct au1000_eth_platform_data mtx1_au1000_eth0_pdata = {
- 	.phy_search_highest_addr	= 1,
- 	.phy1_search_mac0 		= 1,
- };
- 
  static int __init mtx1_register_devices(void)
  {
  	int rc;
  
- 	au1xxx_override_eth_cfg(0, &mtx1_au1000_eth0_pdata);
- 
  	rc = gpio_request(mtx1_gpio_button[0].gpio,
  					mtx1_gpio_button[0].desc);
  	if (rc < 0) {
--- 140,149 ----
diff -cBr 2.6.35/arch/parisc/kernel/firmware.c linux-2.6.35.y-512ac85/arch/parisc/kernel/firmware.c
*** 2.6.35/arch/parisc/kernel/firmware.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/parisc/kernel/firmware.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1126,1138 ****
  	unsigned int i;
  	unsigned long flags;
  
! 	for (i = 0; i < count;) {
  		switch(str[i]) {
  		case '\n':
  			iodc_dbuf[i+0] = '\r';
  			iodc_dbuf[i+1] = '\n';
  			i += 2;
  			goto print;
  		default:
  			iodc_dbuf[i] = str[i];
  			i++;
--- 1126,1140 ----
  	unsigned int i;
  	unsigned long flags;
  
! 	for (i = 0; i < count && i < 79;) {
  		switch(str[i]) {
  		case '\n':
  			iodc_dbuf[i+0] = '\r';
  			iodc_dbuf[i+1] = '\n';
  			i += 2;
  			goto print;
+ 		case '\b':	/* BS */
+ 			i--; /* overwrite last */
  		default:
  			iodc_dbuf[i] = str[i];
  			i++;
***************
*** 1140,1145 ****
--- 1142,1156 ----
  		}
  	}
  
+ 	/* if we're at the end of line, and not already inserting a newline,
+ 	 * insert one anyway. iodc console doesn't claim to support >79 char
+ 	 * lines. don't account for this in the return value.
+ 	 */
+ 	if (i == 79 && iodc_dbuf[i-1] != '\n') {
+ 		iodc_dbuf[i+0] = '\r';
+ 		iodc_dbuf[i+1] = '\n';
+ 	}
+ 
  print:
          spin_lock_irqsave(&pdc_lock, flags);
          real32_call(PAGE0->mem_cons.iodc_io,
diff -cBr 2.6.35/arch/parisc/kernel/irq.c linux-2.6.35.y-512ac85/arch/parisc/kernel/irq.c
*** 2.6.35/arch/parisc/kernel/irq.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/parisc/kernel/irq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 117,123 ****
  	int cpu_dest;
  
  	/* timer and ipi have to always be received on all CPUs */
! 	if (CHECK_IRQ_PER_CPU(irq_to_desc(irq)->status)) {
  		/* Bad linux design decision.  The mask has already
  		 * been set; we must reset it */
  		cpumask_setall(irq_desc[irq].affinity);
--- 117,123 ----
  	int cpu_dest;
  
  	/* timer and ipi have to always be received on all CPUs */
! 	if (CHECK_IRQ_PER_CPU(irq)) {
  		/* Bad linux design decision.  The mask has already
  		 * been set; we must reset it */
  		cpumask_setall(irq_desc[irq].affinity);
diff -cBr 2.6.35/arch/powerpc/include/asm/reg.h linux-2.6.35.y-512ac85/arch/powerpc/include/asm/reg.h
*** 2.6.35/arch/powerpc/include/asm/reg.h	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/include/asm/reg.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 878,884 ****
  #define PV_970		0x0039
  #define PV_POWER5	0x003A
  #define PV_POWER5p	0x003B
- #define PV_POWER7	0x003F
  #define PV_970FX	0x003C
  #define PV_630		0x0040
  #define PV_630p	0x0041
--- 878,883 ----
diff -cBr 2.6.35/arch/powerpc/include/asm/system.h linux-2.6.35.y-512ac85/arch/powerpc/include/asm/system.h
*** 2.6.35/arch/powerpc/include/asm/system.h	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/include/asm/system.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 545,550 ****
--- 545,554 ----
  
  #define PTRRELOC(x)	((typeof(x)) add_reloc_offset((unsigned long)(x)))
  
+ #ifdef CONFIG_VIRT_CPU_ACCOUNTING
+ extern void account_system_vtime(struct task_struct *);
+ #endif
+ 
  extern struct dentry *powerpc_debugfs_root;
  
  #endif /* __KERNEL__ */
diff -cBr 2.6.35/arch/powerpc/kernel/cpu_setup_6xx.S linux-2.6.35.y-512ac85/arch/powerpc/kernel/cpu_setup_6xx.S
*** 2.6.35/arch/powerpc/kernel/cpu_setup_6xx.S	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/kernel/cpu_setup_6xx.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 18,24 ****
  #include <asm/mmu.h>
  
  _GLOBAL(__setup_cpu_603)
! 	mflr	r5
  BEGIN_MMU_FTR_SECTION
  	li	r10,0
  	mtspr	SPRN_SPRG_603_LRU,r10		/* init SW LRU tracking */
--- 18,24 ----
  #include <asm/mmu.h>
  
  _GLOBAL(__setup_cpu_603)
! 	mflr	r4
  BEGIN_MMU_FTR_SECTION
  	li	r10,0
  	mtspr	SPRN_SPRG_603_LRU,r10		/* init SW LRU tracking */
***************
*** 27,86 ****
  	bl	__init_fpu_registers
  END_FTR_SECTION_IFCLR(CPU_FTR_FPU_UNAVAILABLE)
  	bl	setup_common_caches
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_604)
! 	mflr	r5
  	bl	setup_common_caches
  	bl	setup_604_hid0
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_750)
! 	mflr	r5
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_750cx)
! 	mflr	r5
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	bl	setup_750cx
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_750fx)
! 	mflr	r5
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	bl	setup_750fx
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_7400)
! 	mflr	r5
  	bl	__init_fpu_registers
  	bl	setup_7400_workarounds
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_7410)
! 	mflr	r5
  	bl	__init_fpu_registers
  	bl	setup_7410_workarounds
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	li	r3,0
  	mtspr	SPRN_L2CR2,r3
! 	mtlr	r5
  	blr
  _GLOBAL(__setup_cpu_745x)
! 	mflr	r5
  	bl	setup_common_caches
  	bl	setup_745x_specifics
! 	mtlr	r5
  	blr
  
  /* Enable caches for 603's, 604, 750 & 7400 */
--- 27,86 ----
  	bl	__init_fpu_registers
  END_FTR_SECTION_IFCLR(CPU_FTR_FPU_UNAVAILABLE)
  	bl	setup_common_caches
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_604)
! 	mflr	r4
  	bl	setup_common_caches
  	bl	setup_604_hid0
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_750)
! 	mflr	r4
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_750cx)
! 	mflr	r4
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	bl	setup_750cx
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_750fx)
! 	mflr	r4
  	bl	__init_fpu_registers
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	bl	setup_750fx
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_7400)
! 	mflr	r4
  	bl	__init_fpu_registers
  	bl	setup_7400_workarounds
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_7410)
! 	mflr	r4
  	bl	__init_fpu_registers
  	bl	setup_7410_workarounds
  	bl	setup_common_caches
  	bl	setup_750_7400_hid0
  	li	r3,0
  	mtspr	SPRN_L2CR2,r3
! 	mtlr	r4
  	blr
  _GLOBAL(__setup_cpu_745x)
! 	mflr	r4
  	bl	setup_common_caches
  	bl	setup_745x_specifics
! 	mtlr	r4
  	blr
  
  /* Enable caches for 603's, 604, 750 & 7400 */
***************
*** 194,203 ****
  	cror	4*cr0+eq,4*cr0+eq,4*cr1+eq
  	cror	4*cr0+eq,4*cr0+eq,4*cr2+eq
  	bnelr
! 	lwz	r6,CPU_SPEC_FEATURES(r4)
  	li	r7,CPU_FTR_CAN_NAP
  	andc	r6,r6,r7
! 	stw	r6,CPU_SPEC_FEATURES(r4)
  	blr
  
  /* 750fx specific
--- 194,203 ----
  	cror	4*cr0+eq,4*cr0+eq,4*cr1+eq
  	cror	4*cr0+eq,4*cr0+eq,4*cr2+eq
  	bnelr
! 	lwz	r6,CPU_SPEC_FEATURES(r5)
  	li	r7,CPU_FTR_CAN_NAP
  	andc	r6,r6,r7
! 	stw	r6,CPU_SPEC_FEATURES(r5)
  	blr
  
  /* 750fx specific
***************
*** 225,236 ****
  	andis.	r11,r11,L3CR_L3E@h
  	beq	1f
  END_FTR_SECTION_IFSET(CPU_FTR_L3CR)
! 	lwz	r6,CPU_SPEC_FEATURES(r4)
  	andi.	r0,r6,CPU_FTR_L3_DISABLE_NAP
  	beq	1f
  	li	r7,CPU_FTR_CAN_NAP
  	andc	r6,r6,r7
! 	stw	r6,CPU_SPEC_FEATURES(r4)
  1:
  	mfspr	r11,SPRN_HID0
  
--- 225,236 ----
  	andis.	r11,r11,L3CR_L3E@h
  	beq	1f
  END_FTR_SECTION_IFSET(CPU_FTR_L3CR)
! 	lwz	r6,CPU_SPEC_FEATURES(r5)
  	andi.	r0,r6,CPU_FTR_L3_DISABLE_NAP
  	beq	1f
  	li	r7,CPU_FTR_CAN_NAP
  	andc	r6,r6,r7
! 	stw	r6,CPU_SPEC_FEATURES(r5)
  1:
  	mfspr	r11,SPRN_HID0
  
diff -cBr 2.6.35/arch/powerpc/kernel/machine_kexec_64.c linux-2.6.35.y-512ac85/arch/powerpc/kernel/machine_kexec_64.c
*** 2.6.35/arch/powerpc/kernel/machine_kexec_64.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/kernel/machine_kexec_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 15,21 ****
  #include <linux/thread_info.h>
  #include <linux/init_task.h>
  #include <linux/errno.h>
- #include <linux/cpu.h>
  
  #include <asm/page.h>
  #include <asm/current.h>
--- 15,20 ----
***************
*** 200,231 ****
  	mb();
  }
  
- /*
-  * We need to make sure each present CPU is online.  The next kernel will scan
-  * the device tree and assume primary threads are online and query secondary
-  * threads via RTAS to online them if required.  If we don't online primary
-  * threads, they will be stuck.  However, we also online secondary threads as we
-  * may be using 'cede offline'.  In this case RTAS doesn't see the secondary
-  * threads as offline -- and again, these CPUs will be stuck.
-  *
-  * So, we online all CPUs that should be running, including secondary threads.
-  */
- static void wake_offline_cpus(void)
- {
- 	int cpu = 0;
- 
- 	for_each_present_cpu(cpu) {
- 		if (!cpu_online(cpu)) {
- 			printk(KERN_INFO "kexec: Waking offline cpu %d.\n",
- 					cpu);
- 			cpu_up(cpu);
- 		}
- 	}
- }
- 
  static void kexec_prepare_cpus(void)
  {
! 	wake_offline_cpus();
  	smp_call_function(kexec_smp_down, NULL, /* wait */0);
  	local_irq_disable();
  	mb(); /* make sure IRQs are disabled before we say they are */
--- 199,207 ----
  	mb();
  }
  
  static void kexec_prepare_cpus(void)
  {
! 
  	smp_call_function(kexec_smp_down, NULL, /* wait */0);
  	local_irq_disable();
  	mb(); /* make sure IRQs are disabled before we say they are */
diff -cBr 2.6.35/arch/powerpc/kernel/perf_event.c linux-2.6.35.y-512ac85/arch/powerpc/kernel/perf_event.c
*** 2.6.35/arch/powerpc/kernel/perf_event.c	2011-05-07 19:57:18.266750012 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/kernel/perf_event.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1230,1257 ****
  	return ip;
  }
  
- static bool pmc_overflow(unsigned long val)
- {
- 	if ((int)val < 0)
- 		return true;
- 
- 	/*
- 	 * Events on POWER7 can roll back if a speculative event doesn't
- 	 * eventually complete. Unfortunately in some rare cases they will
- 	 * raise a performance monitor exception. We need to catch this to
- 	 * ensure we reset the PMC. In all cases the PMC will be 256 or less
- 	 * cycles from overflow.
- 	 *
- 	 * We only do this if the first pass fails to find any overflowing
- 	 * PMCs because a user might set a period of less than 256 and we
- 	 * don't want to mistakenly reset them.
- 	 */
- 	if (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))
- 		return true;
- 
- 	return false;
- }
- 
  /*
   * Performance monitor interrupt stuff
   */
--- 1230,1235 ----
***************
*** 1299,1305 ****
  			if (is_limited_pmc(i + 1))
  				continue;
  			val = read_pmc(i + 1);
! 			if (pmc_overflow(val))
  				write_pmc(i + 1, 0);
  		}
  	}
--- 1277,1283 ----
  			if (is_limited_pmc(i + 1))
  				continue;
  			val = read_pmc(i + 1);
! 			if ((int)val < 0)
  				write_pmc(i + 1, 0);
  		}
  	}
diff -cBr 2.6.35/arch/powerpc/mm/hash_utils_64.c linux-2.6.35.y-512ac85/arch/powerpc/mm/hash_utils_64.c
*** 2.6.35/arch/powerpc/mm/hash_utils_64.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/mm/hash_utils_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1122,1128 ****
  	else
  #endif /* CONFIG_PPC_HAS_HASH_64K */
  		rc = __hash_page_4K(ea, access, vsid, ptep, trap, local, ssize,
! 				    subpage_protection(mm, ea));
  
  	/* Dump some info in case of hash insertion failure, they should
  	 * never happen so it is really useful to know if/when they do
--- 1122,1128 ----
  	else
  #endif /* CONFIG_PPC_HAS_HASH_64K */
  		rc = __hash_page_4K(ea, access, vsid, ptep, trap, local, ssize,
! 				    subpage_protection(pgdir, ea));
  
  	/* Dump some info in case of hash insertion failure, they should
  	 * never happen so it is really useful to know if/when they do
diff -cBr 2.6.35/arch/powerpc/sysdev/fsl_rio.c linux-2.6.35.y-512ac85/arch/powerpc/sysdev/fsl_rio.c
*** 2.6.35/arch/powerpc/sysdev/fsl_rio.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/powerpc/sysdev/fsl_rio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 952,957 ****
--- 952,958 ----
  	if (dsr & DOORBELL_DSR_QFI) {
  		pr_info("RIO: doorbell queue full\n");
  		out_be32(&priv->msg_regs->dsr, DOORBELL_DSR_QFI);
+ 		goto out;
  	}
  
  	/* XXX Need to check/dispatch until queue empty */
diff -cBr 2.6.35/arch/s390/include/asm/processor.h linux-2.6.35.y-512ac85/arch/s390/include/asm/processor.h
*** 2.6.35/arch/s390/include/asm/processor.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/include/asm/processor.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 150,155 ****
--- 150,160 ----
   */
  extern unsigned long thread_saved_pc(struct task_struct *t);
  
+ /*
+  * Print register of task into buffer. Used in fs/proc/array.c.
+  */
+ extern void task_show_regs(struct seq_file *m, struct task_struct *task);
+ 
  extern void show_code(struct pt_regs *regs);
  
  unsigned long get_wchan(struct task_struct *p);
diff -cBr 2.6.35/arch/s390/include/asm/system.h linux-2.6.35.y-512ac85/arch/s390/include/asm/system.h
*** 2.6.35/arch/s390/include/asm/system.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/include/asm/system.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 97,102 ****
--- 97,103 ----
  
  extern void account_vtime(struct task_struct *, struct task_struct *);
  extern void account_tick_vtime(struct task_struct *);
+ extern void account_system_vtime(struct task_struct *);
  
  #ifdef CONFIG_PFAULT
  extern void pfault_irq_init(void);
diff -cBr 2.6.35/arch/s390/kernel/nmi.c linux-2.6.35.y-512ac85/arch/s390/kernel/nmi.c
*** 2.6.35/arch/s390/kernel/nmi.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/kernel/nmi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 95,100 ****
--- 95,101 ----
  static int notrace s390_revalidate_registers(struct mci *mci)
  {
  	int kill_task;
+ 	u64 tmpclock;
  	u64 zero;
  	void *fpt_save_area, *fpt_creg_save_area;
  
***************
*** 213,222 ****
  			: "0", "cc");
  #endif
  	/* Revalidate clock comparator register */
! 	if (S390_lowcore.clock_comparator == -1)
! 		set_clock_comparator(S390_lowcore.mcck_clock);
! 	else
! 		set_clock_comparator(S390_lowcore.clock_comparator);
  	/* Check if old PSW is valid */
  	if (!mci->wp)
  		/*
--- 214,224 ----
  			: "0", "cc");
  #endif
  	/* Revalidate clock comparator register */
! 	asm volatile(
! 		"	stck	0(%1)\n"
! 		"	sckc	0(%1)"
! 		: "=m" (tmpclock) : "a" (&(tmpclock)) : "cc", "memory");
! 
  	/* Check if old PSW is valid */
  	if (!mci->wp)
  		/*
diff -cBr 2.6.35/arch/s390/kernel/traps.c linux-2.6.35.y-512ac85/arch/s390/kernel/traps.c
*** 2.6.35/arch/s390/kernel/traps.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/kernel/traps.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 237,242 ****
--- 237,279 ----
  	show_last_breaking_event(regs);
  }
  
+ /* This is called from fs/proc/array.c */
+ void task_show_regs(struct seq_file *m, struct task_struct *task)
+ {
+ 	struct pt_regs *regs;
+ 
+ 	regs = task_pt_regs(task);
+ 	seq_printf(m, "task: %p, ksp: %p\n",
+ 		       task, (void *)task->thread.ksp);
+ 	seq_printf(m, "User PSW : %p %p\n",
+ 		       (void *) regs->psw.mask, (void *)regs->psw.addr);
+ 
+ 	seq_printf(m, "User GPRS: " FOURLONG,
+ 			  regs->gprs[0], regs->gprs[1],
+ 			  regs->gprs[2], regs->gprs[3]);
+ 	seq_printf(m, "           " FOURLONG,
+ 			  regs->gprs[4], regs->gprs[5],
+ 			  regs->gprs[6], regs->gprs[7]);
+ 	seq_printf(m, "           " FOURLONG,
+ 			  regs->gprs[8], regs->gprs[9],
+ 			  regs->gprs[10], regs->gprs[11]);
+ 	seq_printf(m, "           " FOURLONG,
+ 			  regs->gprs[12], regs->gprs[13],
+ 			  regs->gprs[14], regs->gprs[15]);
+ 	seq_printf(m, "User ACRS: %08x %08x %08x %08x\n",
+ 			  task->thread.acrs[0], task->thread.acrs[1],
+ 			  task->thread.acrs[2], task->thread.acrs[3]);
+ 	seq_printf(m, "           %08x %08x %08x %08x\n",
+ 			  task->thread.acrs[4], task->thread.acrs[5],
+ 			  task->thread.acrs[6], task->thread.acrs[7]);
+ 	seq_printf(m, "           %08x %08x %08x %08x\n",
+ 			  task->thread.acrs[8], task->thread.acrs[9],
+ 			  task->thread.acrs[10], task->thread.acrs[11]);
+ 	seq_printf(m, "           %08x %08x %08x %08x\n",
+ 			  task->thread.acrs[12], task->thread.acrs[13],
+ 			  task->thread.acrs[14], task->thread.acrs[15]);
+ }
+ 
  static DEFINE_SPINLOCK(die_lock);
  
  void die(const char * str, struct pt_regs * regs, long err)
diff -cBr 2.6.35/arch/s390/kernel/vtime.c linux-2.6.35.y-512ac85/arch/s390/kernel/vtime.c
*** 2.6.35/arch/s390/kernel/vtime.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/kernel/vtime.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 19,25 ****
  #include <linux/kernel_stat.h>
  #include <linux/rcupdate.h>
  #include <linux/posix-timers.h>
- #include <linux/cpu.h>
  
  #include <asm/s390_ext.h>
  #include <asm/timer.h>
--- 19,24 ----
***************
*** 566,588 ****
  	__ctl_set_bit(0,10);
  }
  
- static int __cpuinit s390_nohz_notify(struct notifier_block *self,
- 				      unsigned long action, void *hcpu)
- {
- 	struct s390_idle_data *idle;
- 	long cpu = (long) hcpu;
- 
- 	idle = &per_cpu(s390_idle, cpu);
- 	switch (action) {
- 	case CPU_DYING:
- 	case CPU_DYING_FROZEN:
- 		idle->nohz_delay = 0;
- 	default:
- 		break;
- 	}
- 	return NOTIFY_OK;
- }
- 
  void __init vtime_init(void)
  {
  	/* request the cpu timer external interrupt */
--- 565,570 ----
***************
*** 591,596 ****
  
  	/* Enable cpu timer interrupts on the boot cpu. */
  	init_cpu_vtimer();
- 	cpu_notifier(s390_nohz_notify, 0);
  }
  
--- 573,577 ----
diff -cBr 2.6.35/arch/s390/lib/delay.c linux-2.6.35.y-512ac85/arch/s390/lib/delay.c
*** 2.6.35/arch/s390/lib/delay.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/s390/lib/delay.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 29,49 ****
  {
  	unsigned long mask, cr0, cr0_saved;
  	u64 clock_saved;
- 	u64 end;
  
- 	mask = psw_kernel_bits | PSW_MASK_WAIT | PSW_MASK_EXT;
- 	end = get_clock() + (usecs << 12);
  	clock_saved = local_tick_disable();
  	__ctl_store(cr0_saved, 0, 0);
  	cr0 = (cr0_saved & 0xffff00e0) | 0x00000800;
  	__ctl_load(cr0 , 0, 0);
  	lockdep_off();
! 	do {
! 		set_clock_comparator(end);
! 		trace_hardirqs_on();
! 		__load_psw_mask(mask);
! 		local_irq_disable();
! 	} while (get_clock() < end);
  	lockdep_on();
  	__ctl_load(cr0_saved, 0, 0);
  	local_tick_enable(clock_saved);
--- 29,45 ----
  {
  	unsigned long mask, cr0, cr0_saved;
  	u64 clock_saved;
  
  	clock_saved = local_tick_disable();
+ 	set_clock_comparator(get_clock() + (usecs << 12));
  	__ctl_store(cr0_saved, 0, 0);
  	cr0 = (cr0_saved & 0xffff00e0) | 0x00000800;
  	__ctl_load(cr0 , 0, 0);
+ 	mask = psw_kernel_bits | PSW_MASK_WAIT | PSW_MASK_EXT;
  	lockdep_off();
! 	trace_hardirqs_on();
! 	__load_psw_mask(mask);
! 	local_irq_disable();
  	lockdep_on();
  	__ctl_load(cr0_saved, 0, 0);
  	local_tick_enable(clock_saved);
Only in linux-2.6.35.y-512ac85/arch/sh/boot/compressed: vmlinux.scr
Only in linux-2.6.35.y-512ac85/arch/sh/boot/romimage: vmlinux.scr
diff -cBr 2.6.35/arch/sparc/include/asm/openprom.h linux-2.6.35.y-512ac85/arch/sparc/include/asm/openprom.h
*** 2.6.35/arch/sparc/include/asm/openprom.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/include/asm/openprom.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 37,43 ****
  	int (*v2_dev_open)(char *devpath);
  	void (*v2_dev_close)(int d);
  	int (*v2_dev_read)(int d, char *buf, int nbytes);
! 	int (*v2_dev_write)(int d, const char *buf, int nbytes);
  	int (*v2_dev_seek)(int d, int hi, int lo);
  
  	/* Never issued (multistage load support) */
--- 37,43 ----
  	int (*v2_dev_open)(char *devpath);
  	void (*v2_dev_close)(int d);
  	int (*v2_dev_read)(int d, char *buf, int nbytes);
! 	int (*v2_dev_write)(int d, char *buf, int nbytes);
  	int (*v2_dev_seek)(int d, int hi, int lo);
  
  	/* Never issued (multistage load support) */
diff -cBr 2.6.35/arch/sparc/include/asm/oplib_32.h linux-2.6.35.y-512ac85/arch/sparc/include/asm/oplib_32.h
*** 2.6.35/arch/sparc/include/asm/oplib_32.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/include/asm/oplib_32.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 60,65 ****
--- 60,84 ----
  extern char *prom_mapio(char *virt_hint, int io_space, unsigned int phys_addr, unsigned int num_bytes);
  extern void prom_unmapio(char *virt_addr, unsigned int num_bytes);
  
+ /* Device operations. */
+ 
+ /* Open the device described by the passed string.  Note, that the format
+  * of the string is different on V0 vs. V2->higher proms.  The caller must
+  * know what he/she is doing!  Returns the device descriptor, an int.
+  */
+ extern int prom_devopen(char *device_string);
+ 
+ /* Close a previously opened device described by the passed integer
+  * descriptor.
+  */
+ extern int prom_devclose(int device_handle);
+ 
+ /* Do a seek operation on the device described by the passed integer
+  * descriptor.
+  */
+ extern void prom_seek(int device_handle, unsigned int seek_hival,
+ 		      unsigned int seek_lowval);
+ 
  /* Miscellaneous routines, don't really fit in any category per se. */
  
  /* Reboot the machine with the command line passed. */
***************
*** 102,109 ****
  /* Get the prom firmware revision. */
  extern int prom_getprev(void);
  
! /* Write a buffer of characters to the console. */
! extern void prom_console_write_buf(const char *buf, int len);
  
  /* Prom's internal routines, don't use in kernel/boot code. */
  extern void prom_printf(const char *fmt, ...);
--- 121,139 ----
  /* Get the prom firmware revision. */
  extern int prom_getprev(void);
  
! /* Character operations to/from the console.... */
! 
! /* Non-blocking get character from console. */
! extern int prom_nbgetchar(void);
! 
! /* Non-blocking put character to console. */
! extern int prom_nbputchar(char character);
! 
! /* Blocking get character from console. */
! extern char prom_getchar(void);
! 
! /* Blocking put character to console. */
! extern void prom_putchar(char character);
  
  /* Prom's internal routines, don't use in kernel/boot code. */
  extern void prom_printf(const char *fmt, ...);
***************
*** 208,213 ****
--- 238,244 ----
  extern int prom_setprop(int node, const char *prop_name, char *prop_value,
  			int value_size);
  
+ extern int prom_pathtoinode(char *path);
  extern int prom_inst2pkg(int);
  
  /* Dorking with Bus ranges... */
diff -cBr 2.6.35/arch/sparc/include/asm/oplib_64.h linux-2.6.35.y-512ac85/arch/sparc/include/asm/oplib_64.h
*** 2.6.35/arch/sparc/include/asm/oplib_64.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/include/asm/oplib_64.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 67,72 ****
--- 67,93 ----
  /* Boot argument acquisition, returns the boot command line string. */
  extern char *prom_getbootargs(void);
  
+ /* Device utilities. */
+ 
+ /* Device operations. */
+ 
+ /* Open the device described by the passed string.  Note, that the format
+  * of the string is different on V0 vs. V2->higher proms.  The caller must
+  * know what he/she is doing!  Returns the device descriptor, an int.
+  */
+ extern int prom_devopen(const char *device_string);
+ 
+ /* Close a previously opened device described by the passed integer
+  * descriptor.
+  */
+ extern int prom_devclose(int device_handle);
+ 
+ /* Do a seek operation on the device described by the passed integer
+  * descriptor.
+  */
+ extern void prom_seek(int device_handle, unsigned int seek_hival,
+ 		      unsigned int seek_lowval);
+ 
  /* Miscellaneous routines, don't really fit in any category per se. */
  
  /* Reboot the machine with the command line passed. */
***************
*** 88,101 ****
  /* Halt and power-off the machine. */
  extern void prom_halt_power_off(void) __attribute__ ((noreturn));
  
  /* Acquire the IDPROM of the root node in the prom device tree.  This
   * gets passed a buffer where you would like it stuffed.  The return value
   * is the format type of this idprom or 0xff on error.
   */
  extern unsigned char prom_get_idprom(char *idp_buffer, int idpbuf_size);
  
! /* Write a buffer of characters to the console. */
! extern void prom_console_write_buf(const char *buf, int len);
  
  /* Prom's internal routines, don't use in kernel/boot code. */
  extern void prom_printf(const char *fmt, ...);
--- 109,141 ----
  /* Halt and power-off the machine. */
  extern void prom_halt_power_off(void) __attribute__ ((noreturn));
  
+ /* Set the PROM 'sync' callback function to the passed function pointer.
+  * When the user gives the 'sync' command at the prom prompt while the
+  * kernel is still active, the prom will call this routine.
+  *
+  */
+ typedef int (*callback_func_t)(long *cmd);
+ extern void prom_setcallback(callback_func_t func_ptr);
+ 
  /* Acquire the IDPROM of the root node in the prom device tree.  This
   * gets passed a buffer where you would like it stuffed.  The return value
   * is the format type of this idprom or 0xff on error.
   */
  extern unsigned char prom_get_idprom(char *idp_buffer, int idpbuf_size);
  
! /* Character operations to/from the console.... */
! 
! /* Non-blocking get character from console. */
! extern int prom_nbgetchar(void);
! 
! /* Non-blocking put character to console. */
! extern int prom_nbputchar(char character);
! 
! /* Blocking get character from console. */
! extern char prom_getchar(void);
! 
! /* Blocking put character to console. */
! extern void prom_putchar(char character);
  
  /* Prom's internal routines, don't use in kernel/boot code. */
  extern void prom_printf(const char *fmt, ...);
***************
*** 238,244 ****
--- 278,286 ----
  extern int prom_setprop(int node, const char *prop_name, char *prop_value,
  			int value_size);
  
+ extern int prom_pathtoinode(const char *path);
  extern int prom_inst2pkg(int);
+ extern int prom_service_exists(const char *service_name);
  extern void prom_sun4v_guest_soft_state(void);
  
  extern int prom_ihandle2path(int handle, char *buffer, int bufsize);
diff -cBr 2.6.35/arch/sparc/kernel/leon_kernel.c linux-2.6.35.y-512ac85/arch/sparc/kernel/leon_kernel.c
*** 2.6.35/arch/sparc/kernel/leon_kernel.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/kernel/leon_kernel.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 114,120 ****
  	if (leon3_gptimer_regs && leon3_irqctrl_regs) {
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].val, 0);
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].rld,
! 				      (((1000000 / HZ) - 1)));
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].ctrl, 0);
  
  #ifdef CONFIG_SMP
--- 114,120 ----
  	if (leon3_gptimer_regs && leon3_irqctrl_regs) {
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].val, 0);
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].rld,
! 				      (((1000000 / 100) - 1)));
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[0].ctrl, 0);
  
  #ifdef CONFIG_SMP
***************
*** 128,134 ****
  		}
  
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].val, 0);
! 		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].rld, (((1000000/HZ) - 1)));
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].ctrl, 0);
  # endif
  
--- 128,134 ----
  		}
  
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].val, 0);
! 		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].rld, (((1000000/100) - 1)));
  		LEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[1].ctrl, 0);
  # endif
  
diff -cBr 2.6.35/arch/sparc/prom/console_32.c linux-2.6.35.y-512ac85/arch/sparc/prom/console_32.c
*** 2.6.35/arch/sparc/prom/console_32.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/console_32.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 16,41 ****
  
  extern void restore_current(void);
  
  /* Non blocking put character to console device, returns -1 if
   * unsuccessful.
   */
! static int prom_nbputchar(const char *buf)
  {
  	unsigned long flags;
  	int i = -1;
  
  	spin_lock_irqsave(&prom_lock, flags);
  	switch(prom_vers) {
  	case PROM_V0:
! 		i = (*(romvec->pv_nbputchar))(*buf);
  		break;
  	case PROM_V2:
  	case PROM_V3:
! 		if ((*(romvec->pv_v2devops).v2_dev_write)(*romvec->pv_v2bootargs.fd_stdout,
! 							  buf, 0x1) == 1)
  			i = 0;
  		break;
  	default:
  		break;
  	};
  	restore_current();
--- 16,78 ----
  
  extern void restore_current(void);
  
+ /* Non blocking get character from console input device, returns -1
+  * if no input was taken.  This can be used for polling.
+  */
+ int
+ prom_nbgetchar(void)
+ {
+ 	static char inc;
+ 	int i = -1;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&prom_lock, flags);
+ 	switch(prom_vers) {
+ 	case PROM_V0:
+ 		i = (*(romvec->pv_nbgetchar))();
+ 		break;
+ 	case PROM_V2:
+ 	case PROM_V3:
+ 		if( (*(romvec->pv_v2devops).v2_dev_read)(*romvec->pv_v2bootargs.fd_stdin , &inc, 0x1) == 1) {
+ 			i = inc;
+ 		} else {
+ 			i = -1;
+ 		}
+ 		break;
+ 	default:
+ 		i = -1;
+ 		break;
+ 	};
+ 	restore_current();
+ 	spin_unlock_irqrestore(&prom_lock, flags);
+ 	return i; /* Ugh, we could spin forever on unsupported proms ;( */
+ }
+ 
  /* Non blocking put character to console device, returns -1 if
   * unsuccessful.
   */
! int
! prom_nbputchar(char c)
  {
+ 	static char outc;
  	unsigned long flags;
  	int i = -1;
  
  	spin_lock_irqsave(&prom_lock, flags);
  	switch(prom_vers) {
  	case PROM_V0:
! 		i = (*(romvec->pv_nbputchar))(c);
  		break;
  	case PROM_V2:
  	case PROM_V3:
! 		outc = c;
! 		if( (*(romvec->pv_v2devops).v2_dev_write)(*romvec->pv_v2bootargs.fd_stdout, &outc, 0x1) == 1)
  			i = 0;
+ 		else
+ 			i = -1;
  		break;
  	default:
+ 		i = -1;
  		break;
  	};
  	restore_current();
***************
*** 43,56 ****
  	return i; /* Ugh, we could spin forever on unsupported proms ;( */
  }
  
! void prom_console_write_buf(const char *buf, int len)
  {
! 	while (len) {
! 		int n = prom_nbputchar(buf);
! 		if (n)
! 			continue;
! 		len--;
! 		buf++;
! 	}
  }
  
--- 80,97 ----
  	return i; /* Ugh, we could spin forever on unsupported proms ;( */
  }
  
! /* Blocking version of get character routine above. */
! char
! prom_getchar(void)
  {
! 	int character;
! 	while((character = prom_nbgetchar()) == -1) ;
! 	return (char) character;
  }
  
+ /* Blocking version of put character routine above. */
+ void
+ prom_putchar(char c)
+ {
+ 	while(prom_nbputchar(c) == -1) ;
+ }
diff -cBr 2.6.35/arch/sparc/prom/console_64.c linux-2.6.35.y-512ac85/arch/sparc/prom/console_64.c
*** 2.6.35/arch/sparc/prom/console_64.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/console_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 15,48 ****
  
  extern int prom_stdin, prom_stdout;
  
! static int __prom_console_write_buf(const char *buf, int len)
  {
  	unsigned long args[7];
! 	int ret;
  
  	args[0] = (unsigned long) "write";
  	args[1] = 3;
  	args[2] = 1;
  	args[3] = (unsigned int) prom_stdout;
! 	args[4] = (unsigned long) buf;
! 	args[5] = (unsigned int) len;
  	args[6] = (unsigned long) -1;
  
  	p1275_cmd_direct(args);
  
! 	ret = (int) args[6];
! 	if (ret < 0)
  		return -1;
- 	return ret;
  }
  
! void prom_console_write_buf(const char *buf, int len)
  {
! 	while (len) {
! 		int n = __prom_console_write_buf(buf, len);
! 		if (n < 0)
! 			continue;
! 		len -= n;
! 		buf += len;
! 	}
  }
--- 15,99 ----
  
  extern int prom_stdin, prom_stdout;
  
! /* Non blocking get character from console input device, returns -1
!  * if no input was taken.  This can be used for polling.
!  */
! inline int
! prom_nbgetchar(void)
  {
  	unsigned long args[7];
! 	char inc;
! 
! 	args[0] = (unsigned long) "read";
! 	args[1] = 3;
! 	args[2] = 1;
! 	args[3] = (unsigned int) prom_stdin;
! 	args[4] = (unsigned long) &inc;
! 	args[5] = 1;
! 	args[6] = (unsigned long) -1;
! 
! 	p1275_cmd_direct(args);
! 
! 	if (args[6] == 1)
! 		return inc;
! 	return -1;
! }
! 
! /* Non blocking put character to console device, returns -1 if
!  * unsuccessful.
!  */
! inline int
! prom_nbputchar(char c)
! {
! 	unsigned long args[7];
! 	char outc;
! 	
! 	outc = c;
  
  	args[0] = (unsigned long) "write";
  	args[1] = 3;
  	args[2] = 1;
  	args[3] = (unsigned int) prom_stdout;
! 	args[4] = (unsigned long) &outc;
! 	args[5] = 1;
  	args[6] = (unsigned long) -1;
  
  	p1275_cmd_direct(args);
  
! 	if (args[6] == 1)
! 		return 0;
! 	else
  		return -1;
  }
  
! /* Blocking version of get character routine above. */
! char
! prom_getchar(void)
! {
! 	int character;
! 	while((character = prom_nbgetchar()) == -1) ;
! 	return (char) character;
! }
! 
! /* Blocking version of put character routine above. */
! void
! prom_putchar(char c)
! {
! 	prom_nbputchar(c);
! }
! 
! void
! prom_puts(const char *s, int len)
  {
! 	unsigned long args[7];
! 
! 	args[0] = (unsigned long) "write";
! 	args[1] = 3;
! 	args[2] = 1;
! 	args[3] = (unsigned int) prom_stdout;
! 	args[4] = (unsigned long) s;
! 	args[5] = len;
! 	args[6] = (unsigned long) -1;
! 
! 	p1275_cmd_direct(args);
  }
diff -cBr 2.6.35/arch/sparc/prom/Makefile linux-2.6.35.y-512ac85/arch/sparc/prom/Makefile
*** 2.6.35/arch/sparc/prom/Makefile	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/Makefile	2010-11-22 14:01:26.000000000 -0500
***************
*** 6,11 ****
--- 6,12 ----
  
  lib-y                 := bootstr_$(BITS).o
  lib-$(CONFIG_SPARC32) += devmap.o
+ lib-y                 += devops_$(BITS).o
  lib-y                 += init_$(BITS).o
  lib-$(CONFIG_SPARC32) += memory.o
  lib-y                 += misc_$(BITS).o
diff -cBr 2.6.35/arch/sparc/prom/misc_64.c linux-2.6.35.y-512ac85/arch/sparc/prom/misc_64.c
*** 2.6.35/arch/sparc/prom/misc_64.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/misc_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 18,24 ****
  #include <asm/system.h>
  #include <asm/ldc.h>
  
! static int prom_service_exists(const char *service_name)
  {
  	unsigned long args[5];
  
--- 18,24 ----
  #include <asm/system.h>
  #include <asm/ldc.h>
  
! int prom_service_exists(const char *service_name)
  {
  	unsigned long args[5];
  
***************
*** 150,155 ****
--- 150,169 ----
  	prom_halt();
  }
  
+ /* Set prom sync handler to call function 'funcp'. */
+ void prom_setcallback(callback_func_t funcp)
+ {
+ 	unsigned long args[5];
+ 	if (!funcp)
+ 		return;
+ 	args[0] = (unsigned long) "set-callback";
+ 	args[1] = 1;
+ 	args[2] = 1;
+ 	args[3] = (unsigned long) funcp;
+ 	args[4] = (unsigned long) -1;
+ 	p1275_cmd_direct(args);
+ }
+ 
  /* Get the idprom and stuff it into buffer 'idbuf'.  Returns the
   * format type.  'num_bytes' is the number of bytes that your idbuf
   * has space for.  Returns 0xff on error.
diff -cBr 2.6.35/arch/sparc/prom/printf.c linux-2.6.35.y-512ac85/arch/sparc/prom/printf.c
*** 2.6.35/arch/sparc/prom/printf.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/printf.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 15,59 ****
  
  #include <linux/kernel.h>
  #include <linux/compiler.h>
- #include <linux/spinlock.h>
  
  #include <asm/openprom.h>
  #include <asm/oplib.h>
  
- #define CONSOLE_WRITE_BUF_SIZE	1024
- 
  static char ppbuf[1024];
- static char console_write_buf[CONSOLE_WRITE_BUF_SIZE];
- static DEFINE_RAW_SPINLOCK(console_write_lock);
  
  void notrace prom_write(const char *buf, unsigned int n)
  {
! 	unsigned int dest_len;
! 	unsigned long flags;
! 	char *dest;
! 
! 	dest = console_write_buf;
! 	raw_spin_lock_irqsave(&console_write_lock, flags);
! 
! 	dest_len = 0;
! 	while (n-- != 0) {
! 		char ch = *buf++;
! 		if (ch == '\n') {
! 			*dest++ = '\r';
! 			dest_len++;
! 		}
! 		*dest++ = ch;
! 		dest_len++;
! 		if (dest_len >= CONSOLE_WRITE_BUF_SIZE - 1) {
! 			prom_console_write_buf(console_write_buf, dest_len);
! 			dest = console_write_buf;
! 			dest_len = 0;
! 		}
! 	}
! 	if (dest_len)
! 		prom_console_write_buf(console_write_buf, dest_len);
  
! 	raw_spin_unlock_irqrestore(&console_write_lock, flags);
  }
  
  void notrace prom_printf(const char *fmt, ...)
--- 15,36 ----
  
  #include <linux/kernel.h>
  #include <linux/compiler.h>
  
  #include <asm/openprom.h>
  #include <asm/oplib.h>
  
  static char ppbuf[1024];
  
  void notrace prom_write(const char *buf, unsigned int n)
  {
! 	char ch;
  
! 	while (n != 0) {
! 		--n;
! 		if ((ch = *buf++) == '\n')
! 			prom_putchar('\r');
! 		prom_putchar(ch);
! 	}
  }
  
  void notrace prom_printf(const char *fmt, ...)
diff -cBr 2.6.35/arch/sparc/prom/tree_32.c linux-2.6.35.y-512ac85/arch/sparc/prom/tree_32.c
*** 2.6.35/arch/sparc/prom/tree_32.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/tree_32.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 341,343 ****
--- 341,358 ----
  	if (node == -1) return 0;
  	return node;
  }
+ 
+ /* Return 'node' assigned to a particular prom 'path'
+  * FIXME: Should work for v0 as well
+  */
+ int prom_pathtoinode(char *path)
+ {
+ 	int node, inst;
+ 	
+ 	inst = prom_devopen (path);
+ 	if (inst == -1) return 0;
+ 	node = prom_inst2pkg (inst);
+ 	prom_devclose (inst);
+ 	if (node == -1) return 0;
+ 	return node;
+ }
diff -cBr 2.6.35/arch/sparc/prom/tree_64.c linux-2.6.35.y-512ac85/arch/sparc/prom/tree_64.c
*** 2.6.35/arch/sparc/prom/tree_64.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/sparc/prom/tree_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 374,379 ****
--- 374,397 ----
  	return node;
  }
  
+ /* Return 'node' assigned to a particular prom 'path'
+  * FIXME: Should work for v0 as well
+  */
+ int
+ prom_pathtoinode(const char *path)
+ {
+ 	int node, inst;
+ 
+ 	inst = prom_devopen (path);
+ 	if (inst == 0)
+ 		return 0;
+ 	node = prom_inst2pkg(inst);
+ 	prom_devclose(inst);
+ 	if (node == -1)
+ 		return 0;
+ 	return node;
+ }
+ 
  int prom_ihandle2path(int handle, char *buffer, int bufsize)
  {
  	unsigned long args[7];
diff -cBr 2.6.35/arch/um/drivers/line.c linux-2.6.35.y-512ac85/arch/um/drivers/line.c
*** 2.6.35/arch/um/drivers/line.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/um/drivers/line.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 727,735 ****
  
  static void free_winch(struct winch *winch, int free_irq_ok)
  {
- 	if (free_irq_ok)
- 		free_irq(WINCH_IRQ, winch);
- 
  	list_del(&winch->list);
  
  	if (winch->pid != -1)
--- 727,732 ----
***************
*** 738,743 ****
--- 735,742 ----
  		os_close_file(winch->fd);
  	if (winch->stack != 0)
  		free_stack(winch->stack, 0);
+ 	if (free_irq_ok)
+ 		free_irq(WINCH_IRQ, winch);
  	kfree(winch);
  }
  
diff -cBr 2.6.35/arch/um/kernel/uml.lds.S linux-2.6.35.y-512ac85/arch/um/kernel/uml.lds.S
*** 2.6.35/arch/um/kernel/uml.lds.S	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/um/kernel/uml.lds.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 22,28 ****
    _text = .;
    _stext = .;
    __init_begin = .;
!   INIT_TEXT_SECTION(0)
    . = ALIGN(PAGE_SIZE);
  
    .text      :
--- 22,28 ----
    _text = .;
    _stext = .;
    __init_begin = .;
!   INIT_TEXT_SECTION(PAGE_SIZE)
    . = ALIGN(PAGE_SIZE);
  
    .text      :
diff -cBr 2.6.35/arch/um/os-Linux/time.c linux-2.6.35.y-512ac85/arch/um/os-Linux/time.c
*** 2.6.35/arch/um/os-Linux/time.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/um/os-Linux/time.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 60,66 ****
  long long disable_timer(void)
  {
  	struct itimerval time = ((struct itimerval) { { 0, 0 }, { 0, 0 } });
! 	long long remain, max = UM_NSEC_PER_SEC / UM_HZ;
  
  	if (setitimer(ITIMER_VIRTUAL, &time, &time) < 0)
  		printk(UM_KERN_ERR "disable_timer - setitimer failed, "
--- 60,66 ----
  long long disable_timer(void)
  {
  	struct itimerval time = ((struct itimerval) { { 0, 0 }, { 0, 0 } });
! 	int remain, max = UM_NSEC_PER_SEC / UM_HZ;
  
  	if (setitimer(ITIMER_VIRTUAL, &time, &time) < 0)
  		printk(UM_KERN_ERR "disable_timer - setitimer failed, "
diff -cBr 2.6.35/arch/x86/include/asm/acpi.h linux-2.6.35.y-512ac85/arch/x86/include/asm/acpi.h
*** 2.6.35/arch/x86/include/asm/acpi.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/acpi.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 88,94 ****
  extern int acpi_pci_disabled;
  extern int acpi_skip_timer_override;
  extern int acpi_use_timer_override;
- extern int acpi_fix_pin2_polarity;
  
  extern u8 acpi_sci_flags;
  extern int acpi_sci_override_gsi;
--- 88,93 ----
diff -cBr 2.6.35/arch/x86/include/asm/kvm_host.h linux-2.6.35.y-512ac85/arch/x86/include/asm/kvm_host.h
*** 2.6.35/arch/x86/include/asm/kvm_host.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/kvm_host.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 77,83 ****
  #define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)
  #define KVM_MIN_FREE_MMU_PAGES 5
  #define KVM_REFILL_PAGES 25
! #define KVM_MAX_CPUID_ENTRIES 80
  #define KVM_NR_FIXED_MTRR_REGION 88
  #define KVM_NR_VAR_MTRR 8
  
--- 77,83 ----
  #define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)
  #define KVM_MIN_FREE_MMU_PAGES 5
  #define KVM_REFILL_PAGES 25
! #define KVM_MAX_CPUID_ENTRIES 40
  #define KVM_NR_FIXED_MTRR_REGION 88
  #define KVM_NR_VAR_MTRR 8
  
***************
*** 673,678 ****
--- 673,692 ----
  	return (struct kvm_mmu_page *)page_private(page);
  }
  
+ static inline u16 kvm_read_fs(void)
+ {
+ 	u16 seg;
+ 	asm("mov %%fs, %0" : "=g"(seg));
+ 	return seg;
+ }
+ 
+ static inline u16 kvm_read_gs(void)
+ {
+ 	u16 seg;
+ 	asm("mov %%gs, %0" : "=g"(seg));
+ 	return seg;
+ }
+ 
  static inline u16 kvm_read_ldt(void)
  {
  	u16 ldt;
***************
*** 680,685 ****
--- 694,709 ----
  	return ldt;
  }
  
+ static inline void kvm_load_fs(u16 sel)
+ {
+ 	asm("mov %0, %%fs" : : "rm"(sel));
+ }
+ 
+ static inline void kvm_load_gs(u16 sel)
+ {
+ 	asm("mov %0, %%gs" : : "rm"(sel));
+ }
+ 
  static inline void kvm_load_ldt(u16 sel)
  {
  	asm("lldt %0" : : "rm"(sel));
diff -cBr 2.6.35/arch/x86/include/asm/mmu_context.h linux-2.6.35.y-512ac85/arch/x86/include/asm/mmu_context.h
*** 2.6.35/arch/x86/include/asm/mmu_context.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/mmu_context.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,41 ****
--- 36,43 ----
  	unsigned cpu = smp_processor_id();
  
  	if (likely(prev != next)) {
+ 		/* stop flush ipis for the previous mm */
+ 		cpumask_clear_cpu(cpu, mm_cpumask(prev));
  #ifdef CONFIG_SMP
  		percpu_write(cpu_tlbstate.state, TLBSTATE_OK);
  		percpu_write(cpu_tlbstate.active_mm, next);
***************
*** 45,53 ****
  		/* Re-load page tables */
  		load_cr3(next->pgd);
  
- 		/* stop flush ipis for the previous mm */
- 		cpumask_clear_cpu(cpu, mm_cpumask(prev));
- 
  		/*
  		 * load the LDT, if the LDT is different:
  		 */
--- 47,52 ----
diff -cBr 2.6.35/arch/x86/include/asm/msr-index.h linux-2.6.35.y-512ac85/arch/x86/include/asm/msr-index.h
*** 2.6.35/arch/x86/include/asm/msr-index.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/msr-index.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 85,99 ****
  #define MSR_IA32_MC0_ADDR		0x00000402
  #define MSR_IA32_MC0_MISC		0x00000403
  
- #define MSR_AMD64_MC0_MASK		0xc0010044
- 
  #define MSR_IA32_MCx_CTL(x)		(MSR_IA32_MC0_CTL + 4*(x))
  #define MSR_IA32_MCx_STATUS(x)		(MSR_IA32_MC0_STATUS + 4*(x))
  #define MSR_IA32_MCx_ADDR(x)		(MSR_IA32_MC0_ADDR + 4*(x))
  #define MSR_IA32_MCx_MISC(x)		(MSR_IA32_MC0_MISC + 4*(x))
  
- #define MSR_AMD64_MCx_MASK(x)		(MSR_AMD64_MC0_MASK + (x))
- 
  /* These are consecutive and not in the normal 4er MCE bank block */
  #define MSR_IA32_MC0_CTL2		0x00000280
  #define MSR_IA32_MCx_CTL2(x)		(MSR_IA32_MC0_CTL2 + (x))
--- 85,95 ----
diff -cBr 2.6.35/arch/x86/include/asm/pgtable-3level.h linux-2.6.35.y-512ac85/arch/x86/include/asm/pgtable-3level.h
*** 2.6.35/arch/x86/include/asm/pgtable-3level.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/pgtable-3level.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 69,74 ****
--- 69,76 ----
  
  static inline void pud_clear(pud_t *pudp)
  {
+ 	unsigned long pgd;
+ 
  	set_pud(pudp, __pud(0));
  
  	/*
***************
*** 77,86 ****
  	 * section 8.1: in PAE mode we explicitly have to flush the
  	 * TLB via cr3 if the top-level pgd is changed...
  	 *
! 	 * Currently all places where pud_clear() is called either have
! 	 * flush_tlb_mm() followed or don't need TLB flush (x86_64 code or
! 	 * pud_clear_bad()), so we don't need TLB flush here.
  	 */
  }
  
  #ifdef CONFIG_SMP
--- 79,91 ----
  	 * section 8.1: in PAE mode we explicitly have to flush the
  	 * TLB via cr3 if the top-level pgd is changed...
  	 *
! 	 * Make sure the pud entry we're updating is within the
! 	 * current pgd to avoid unnecessary TLB flushes.
  	 */
+ 	pgd = read_cr3();
+ 	if (__pa(pudp) >= pgd && __pa(pudp) <
+ 	    (pgd + sizeof(pgd_t)*PTRS_PER_PGD))
+ 		write_cr3(pgd);
  }
  
  #ifdef CONFIG_SMP
diff -cBr 2.6.35/arch/x86/include/asm/processor.h linux-2.6.35.y-512ac85/arch/x86/include/asm/processor.h
*** 2.6.35/arch/x86/include/asm/processor.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/processor.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 763,768 ****
--- 763,791 ----
  extern unsigned long		idle_halt;
  extern unsigned long		idle_nomwait;
  
+ /*
+  * on systems with caches, caches must be flashed as the absolute
+  * last instruction before going into a suspended halt.  Otherwise,
+  * dirty data can linger in the cache and become stale on resume,
+  * leading to strange errors.
+  *
+  * perform a variety of operations to guarantee that the compiler
+  * will not reorder instructions.  wbinvd itself is serializing
+  * so the processor will not reorder.
+  *
+  * Systems without cache can just go into halt.
+  */
+ static inline void wbinvd_halt(void)
+ {
+ 	mb();
+ 	/* check for clflush to determine if wbinvd is legal */
+ 	if (cpu_has_clflush)
+ 		asm volatile("cli; wbinvd; 1: hlt; jmp 1b" : : : "memory");
+ 	else
+ 		while (1)
+ 			halt();
+ }
+ 
  extern void enable_sep_cpu(void);
  extern int sysenter_setup(void);
  
***************
*** 1002,1024 ****
  	return ratio;
  }
  
- /*
-  * AMD errata checking
-  */
- #ifdef CONFIG_CPU_SUP_AMD
- extern const int amd_erratum_400[];
- extern bool cpu_has_amd_erratum(const int *);
- 
- #define AMD_LEGACY_ERRATUM(...)		{ -1, __VA_ARGS__, 0 }
- #define AMD_OSVW_ERRATUM(osvw_id, ...)	{ osvw_id, __VA_ARGS__, 0 }
- #define AMD_MODEL_RANGE(f, m_start, s_start, m_end, s_end) \
- 	((f << 24) | (m_start << 16) | (s_start << 12) | (m_end << 4) | (s_end))
- #define AMD_MODEL_RANGE_FAMILY(range)	(((range) >> 24) & 0xff)
- #define AMD_MODEL_RANGE_START(range)	(((range) >> 12) & 0xfff)
- #define AMD_MODEL_RANGE_END(range)	((range) & 0xfff)
- 
- #else
- #define cpu_has_amd_erratum(x)	(false)
- #endif /* CONFIG_CPU_SUP_AMD */
- 
  #endif /* _ASM_X86_PROCESSOR_H */
--- 1025,1028 ----
diff -cBr 2.6.35/arch/x86/include/asm/pvclock.h linux-2.6.35.y-512ac85/arch/x86/include/asm/pvclock.h
*** 2.6.35/arch/x86/include/asm/pvclock.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/pvclock.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 11,16 ****
  void pvclock_read_wallclock(struct pvclock_wall_clock *wall,
  			    struct pvclock_vcpu_time_info *vcpu,
  			    struct timespec *ts);
- void pvclock_resume(void);
  
  #endif /* _ASM_X86_PVCLOCK_H */
--- 11,15 ----
diff -cBr 2.6.35/arch/x86/include/asm/smpboot_hooks.h linux-2.6.35.y-512ac85/arch/x86/include/asm/smpboot_hooks.h
*** 2.6.35/arch/x86/include/asm/smpboot_hooks.h	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/include/asm/smpboot_hooks.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 34,40 ****
  	 */
  	CMOS_WRITE(0, 0xf);
  
! 	*((volatile u32 *)phys_to_virt(apic->trampoline_phys_low)) = 0;
  }
  
  static inline void __init smpboot_setup_io_apic(void)
--- 34,40 ----
  	 */
  	CMOS_WRITE(0, 0xf);
  
! 	*((volatile long *)phys_to_virt(apic->trampoline_phys_low)) = 0;
  }
  
  static inline void __init smpboot_setup_io_apic(void)
diff -cBr 2.6.35/arch/x86/Kconfig linux-2.6.35.y-512ac85/arch/x86/Kconfig
*** 2.6.35/arch/x86/Kconfig	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/Kconfig	2010-11-22 14:01:26.000000000 -0500
***************
*** 797,813 ****
  	  making when dealing with multi-core CPU chips at a cost of slightly
  	  increased overhead in some places. If unsure say N here.
  
- config IRQ_TIME_ACCOUNTING
- 	bool "Fine granularity task level IRQ time accounting"
- 	default n
- 	---help---
- 	  Select this option to enable fine granularity task irq time
- 	  accounting. This is done by reading a timestamp on each
- 	  transitions between softirq and hardirq state, so there can be a
- 	  small performance impact.
- 
- 	  If in doubt, say N here.
- 
  source "kernel/Kconfig.preempt"
  
  config X86_UP_APIC
--- 797,802 ----
diff -cBr 2.6.35/arch/x86/kernel/acpi/boot.c linux-2.6.35.y-512ac85/arch/x86/kernel/acpi/boot.c
*** 2.6.35/arch/x86/kernel/acpi/boot.c	2011-05-07 19:57:18.276750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/acpi/boot.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 72,78 ****
  int acpi_sci_override_gsi __initdata;
  int acpi_skip_timer_override __initdata;
  int acpi_use_timer_override __initdata;
- int acpi_fix_pin2_polarity __initdata;
  
  #ifdef CONFIG_X86_LOCAL_APIC
  static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
--- 72,77 ----
***************
*** 411,425 ****
  		return 0;
  	}
  
! 	if (intsrc->source_irq == 0 && intsrc->global_irq == 2) {
! 		if (acpi_skip_timer_override) {
! 			printk(PREFIX "BIOS IRQ0 pin2 override ignored.\n");
! 			return 0;
! 		}
! 		if (acpi_fix_pin2_polarity && (intsrc->inti_flags & ACPI_MADT_POLARITY_MASK)) {
! 			intsrc->inti_flags &= ~ACPI_MADT_POLARITY_MASK;
! 			printk(PREFIX "BIOS IRQ0 pin2 override: forcing polarity to high active.\n");
! 		}
  	}
  
  	mp_override_legacy_irq(intsrc->source_irq,
--- 410,419 ----
  		return 0;
  	}
  
! 	if (acpi_skip_timer_override &&
! 	    intsrc->source_irq == 0 && intsrc->global_irq == 2) {
! 		printk(PREFIX "BIOS IRQ0 pin2 override ignored.\n");
! 		return 0;
  	}
  
  	mp_override_legacy_irq(intsrc->source_irq,
diff -cBr 2.6.35/arch/x86/kernel/apic/apic.c linux-2.6.35.y-512ac85/arch/x86/kernel/apic/apic.c
*** 2.6.35/arch/x86/kernel/apic/apic.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/apic/apic.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1340,1353 ****
  
  	setup_apic_nmi_watchdog(NULL);
  	apic_pm_activate();
- 
- 	/*
- 	 * Now that local APIC setup is completed for BP, configure the fault
- 	 * handling for interrupt remapping.
- 	 */
- 	if (!smp_processor_id() && intr_remapping_enabled)
- 		enable_drhd_fault_handling();
- 
  }
  
  #ifdef CONFIG_X86_X2APIC
--- 1340,1345 ----
diff -cBr 2.6.35/arch/x86/kernel/apic/io_apic.c linux-2.6.35.y-512ac85/arch/x86/kernel/apic/io_apic.c
*** 2.6.35/arch/x86/kernel/apic/io_apic.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/apic/io_apic.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3626,3632 ****
  	msg.data |= MSI_DATA_VECTOR(cfg->vector);
  	msg.address_lo &= ~MSI_ADDR_DEST_ID_MASK;
  	msg.address_lo |= MSI_ADDR_DEST_ID(dest);
- 	msg.address_hi = MSI_ADDR_BASE_HI | MSI_ADDR_EXT_DEST_ID(dest);
  
  	dmar_msi_write(irq, &msg);
  
--- 3626,3631 ----
diff -cBr 2.6.35/arch/x86/kernel/apic/probe_64.c linux-2.6.35.y-512ac85/arch/x86/kernel/apic/probe_64.c
*** 2.6.35/arch/x86/kernel/apic/probe_64.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/apic/probe_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 76,81 ****
--- 76,88 ----
  		/* need to update phys_pkg_id */
  		apic->phys_pkg_id = apicid_phys_pkg_id;
  	}
+ 
+ 	/*
+ 	 * Now that apic routing model is selected, configure the
+ 	 * fault handling for intr remapping.
+ 	 */
+ 	if (intr_remapping_enabled)
+ 		enable_drhd_fault_handling();
  }
  
  /* Same for both flat and physical. */
diff -cBr 2.6.35/arch/x86/kernel/cpu/amd.c linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/amd.c
*** 2.6.35/arch/x86/kernel/cpu/amd.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/amd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 305,311 ****
  	/* use socket ID also for last level cache */
  	per_cpu(cpu_llc_id, cpu) = c->phys_proc_id;
  	/* fixup topology information on multi-node processors */
! 	amd_fixup_dcm(c);
  #endif
  }
  
--- 305,312 ----
  	/* use socket ID also for last level cache */
  	per_cpu(cpu_llc_id, cpu) = c->phys_proc_id;
  	/* fixup topology information on multi-node processors */
! 	if ((c->x86 == 0x10) && (c->x86_model == 9))
! 		amd_fixup_dcm(c);
  #endif
  }
  
***************
*** 564,592 ****
  		}
  	}
  #endif
- 
- 	/* As a rule processors have APIC timer running in deep C states */
- 	if (c->x86 >= 0xf && !cpu_has_amd_erratum(amd_erratum_400))
- 		set_cpu_cap(c, X86_FEATURE_ARAT);
- 
- 	/*
- 	 * Disable GART TLB Walk Errors on Fam10h. We do this here
- 	 * because this is always needed when GART is enabled, even in a
- 	 * kernel which has no MCE support built in.
- 	 */
- 	if (c->x86 == 0x10) {
- 		/*
- 		 * BIOS should disable GartTlbWlk Errors themself. If
- 		 * it doesn't do it here as suggested by the BKDG.
- 		 *
- 		 * Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=33012
- 		 */
- 		u64 mask;
- 
- 		rdmsrl(MSR_AMD64_MCx_MASK(4), mask);
- 		mask |= (1 << 10);
- 		wrmsrl(MSR_AMD64_MCx_MASK(4), mask);
- 	}
  }
  
  #ifdef CONFIG_X86_32
--- 565,570 ----
***************
*** 631,698 ****
  };
  
  cpu_dev_register(amd_cpu_dev);
- 
- /*
-  * AMD errata checking
-  *
-  * Errata are defined as arrays of ints using the AMD_LEGACY_ERRATUM() or
-  * AMD_OSVW_ERRATUM() macros. The latter is intended for newer errata that
-  * have an OSVW id assigned, which it takes as first argument. Both take a
-  * variable number of family-specific model-stepping ranges created by
-  * AMD_MODEL_RANGE(). Each erratum also has to be declared as extern const
-  * int[] in arch/x86/include/asm/processor.h.
-  *
-  * Example:
-  *
-  * const int amd_erratum_319[] =
-  *	AMD_LEGACY_ERRATUM(AMD_MODEL_RANGE(0x10, 0x2, 0x1, 0x4, 0x2),
-  *			   AMD_MODEL_RANGE(0x10, 0x8, 0x0, 0x8, 0x0),
-  *			   AMD_MODEL_RANGE(0x10, 0x9, 0x0, 0x9, 0x0));
-  */
- 
- const int amd_erratum_400[] =
- 	AMD_OSVW_ERRATUM(1, AMD_MODEL_RANGE(0xf, 0x41, 0x2, 0xff, 0xf),
- 			    AMD_MODEL_RANGE(0x10, 0x2, 0x1, 0xff, 0xf));
- 
- 
- bool cpu_has_amd_erratum(const int *erratum)
- {
- 	struct cpuinfo_x86 *cpu = &current_cpu_data;
- 	int osvw_id = *erratum++;
- 	u32 range;
- 	u32 ms;
- 
- 	/*
- 	 * If called early enough that current_cpu_data hasn't been initialized
- 	 * yet, fall back to boot_cpu_data.
- 	 */
- 	if (cpu->x86 == 0)
- 		cpu = &boot_cpu_data;
- 
- 	if (cpu->x86_vendor != X86_VENDOR_AMD)
- 		return false;
- 
- 	if (osvw_id >= 0 && osvw_id < 65536 &&
- 	    cpu_has(cpu, X86_FEATURE_OSVW)) {
- 		u64 osvw_len;
- 
- 		rdmsrl(MSR_AMD64_OSVW_ID_LENGTH, osvw_len);
- 		if (osvw_id < osvw_len) {
- 			u64 osvw_bits;
- 
- 			rdmsrl(MSR_AMD64_OSVW_STATUS + (osvw_id >> 6),
- 			    osvw_bits);
- 			return osvw_bits & (1ULL << (osvw_id & 0x3f));
- 		}
- 	}
- 
- 	/* OSVW unavailable or ID unknown, match family-model-stepping range */
- 	ms = (cpu->x86_model << 4) | cpu->x86_mask;
- 	while ((range = *erratum++))
- 		if ((cpu->x86 == AMD_MODEL_RANGE_FAMILY(range)) &&
- 		    (ms >= AMD_MODEL_RANGE_START(range)) &&
- 		    (ms <= AMD_MODEL_RANGE_END(range)))
- 			return true;
- 
- 	return false;
- }
--- 609,611 ----
diff -cBr 2.6.35/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c
*** 2.6.35/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 704,710 ****
  		per_cpu(acfreq_data, policy->cpu) = NULL;
  		acpi_processor_unregister_performance(data->acpi_data,
  						      policy->cpu);
- 		kfree(data->freq_table);
  		kfree(data);
  	}
  
--- 704,709 ----
diff -cBr 2.6.35/arch/x86/kernel/cpu/mtrr/main.c linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/mtrr/main.c
*** 2.6.35/arch/x86/kernel/cpu/mtrr/main.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/cpu/mtrr/main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 292,315 ****
  
  	/*
  	 * HACK!
! 	 *
! 	 * We use this same function to initialize the mtrrs during boot,
! 	 * resume, runtime cpu online and on an explicit request to set a
! 	 * specific MTRR.
! 	 *
! 	 * During boot or suspend, the state of the boot cpu's mtrrs has been
! 	 * saved, and we want to replicate that across all the cpus that come
! 	 * online (either at the end of boot or resume or during a runtime cpu
! 	 * online). If we're doing that, @reg is set to something special and on
! 	 * this cpu we still do mtrr_if->set_all(). During boot/resume, this
! 	 * is unnecessary if at this point we are still on the cpu that started
! 	 * the boot/resume sequence. But there is no guarantee that we are still
! 	 * on the same cpu. So we do mtrr_if->set_all() on this cpu aswell to be
! 	 * sure that we are in sync with everyone else.
  	 */
  	if (reg != ~0U)
  		mtrr_if->set(reg, base, size, type);
! 	else
  		mtrr_if->set_all();
  
  	/* Wait for the others */
--- 292,305 ----
  
  	/*
  	 * HACK!
! 	 * We use this same function to initialize the mtrrs on boot.
! 	 * The state of the boot cpu's mtrrs has been saved, and we want
! 	 * to replicate across all the APs.
! 	 * If we're doing that @reg is set to something special...
  	 */
  	if (reg != ~0U)
  		mtrr_if->set(reg, base, size, type);
! 	else if (!mtrr_aps_delayed_init)
  		mtrr_if->set_all();
  
  	/* Wait for the others */
***************
*** 803,823 ****
  }
  
  /*
!  * Delayed MTRR initialization for all AP's
   */
  void mtrr_aps_init(void)
  {
  	if (!use_intel())
  		return;
  
- 	/*
- 	 * Check if someone has requested the delay of AP MTRR initialization,
- 	 * by doing set_mtrr_aps_delayed_init(), prior to this point. If not,
- 	 * then we are done.
- 	 */
- 	if (!mtrr_aps_delayed_init)
- 		return;
- 
  	set_mtrr(~0U, 0, 0, 0);
  	mtrr_aps_delayed_init = false;
  }
--- 793,805 ----
  }
  
  /*
!  * MTRR initialization for all AP's
   */
  void mtrr_aps_init(void)
  {
  	if (!use_intel())
  		return;
  
  	set_mtrr(~0U, 0, 0, 0);
  	mtrr_aps_delayed_init = false;
  }
diff -cBr 2.6.35/arch/x86/kernel/e820.c linux-2.6.35.y-512ac85/arch/x86/kernel/e820.c
*** 2.6.35/arch/x86/kernel/e820.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/e820.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 980,1000 ****
  	if (!p)
  		return -EINVAL;
  
- 	if (!strcmp(p, "nopentium")) {
  #ifdef CONFIG_X86_32
  		setup_clear_cpu_cap(X86_FEATURE_PSE);
  		return 0;
- #else
- 		printk(KERN_WARNING "mem=nopentium ignored! (only supported on x86_32)\n");
- 		return -EINVAL;
- #endif
  	}
  
  	userdef = 1;
  	mem_size = memparse(p, &p);
- 	/* don't remove all of memory when handling "mem={invalid}" param */
- 	if (mem_size == 0)
- 		return -EINVAL;
  	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
  
  	return 0;
--- 980,994 ----
  	if (!p)
  		return -EINVAL;
  
  #ifdef CONFIG_X86_32
+ 	if (!strcmp(p, "nopentium")) {
  		setup_clear_cpu_cap(X86_FEATURE_PSE);
  		return 0;
  	}
+ #endif
  
  	userdef = 1;
  	mem_size = memparse(p, &p);
  	e820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
  
  	return 0;
diff -cBr 2.6.35/arch/x86/kernel/early-quirks.c linux-2.6.35.y-512ac85/arch/x86/kernel/early-quirks.c
*** 2.6.35/arch/x86/kernel/early-quirks.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/early-quirks.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 145,154 ****
  
  static u32 __init ati_sbx00_rev(int num, int slot, int func)
  {
! 	u32 d;
  
  	d = read_pci_config(num, slot, func, 0x8);
  	d &= 0xff;
  
  	return d;
  }
--- 145,159 ----
  
  static u32 __init ati_sbx00_rev(int num, int slot, int func)
  {
! 	u32 old, d;
  
+ 	d = read_pci_config(num, slot, func, 0x70);
+ 	old = d;
+ 	d &= ~(1<<8);
+ 	write_pci_config(num, slot, func, 0x70, d);
  	d = read_pci_config(num, slot, func, 0x8);
  	d &= 0xff;
+ 	write_pci_config(num, slot, func, 0x70, old);
  
  	return d;
  }
***************
*** 157,175 ****
  {
  	u32 d, rev;
  
! 	rev = ati_sbx00_rev(num, slot, func);
! 	if (rev >= 0x40)
! 		acpi_fix_pin2_polarity = 1;
! 
! 	/*
! 	 * SB600: revisions 0x11, 0x12, 0x13, 0x14, ...
! 	 * SB700: revisions 0x39, 0x3a, ...
! 	 * SB800: revisions 0x40, 0x41, ...
! 	 */
! 	if (rev >= 0x39)
  		return;
  
! 	if (acpi_use_timer_override)
  		return;
  
  	/* check for IRQ0 interrupt swap */
--- 162,172 ----
  {
  	u32 d, rev;
  
! 	if (acpi_use_timer_override)
  		return;
  
! 	rev = ati_sbx00_rev(num, slot, func);
! 	if (rev > 0x13)
  		return;
  
  	/* check for IRQ0 interrupt swap */
diff -cBr 2.6.35/arch/x86/kernel/entry_64.S linux-2.6.35.y-512ac85/arch/x86/kernel/entry_64.S
*** 2.6.35/arch/x86/kernel/entry_64.S	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/entry_64.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 1268,1274 ****
  	decl PER_CPU_VAR(irq_count)
  	jmp  error_exit
  	CFI_ENDPROC
! END(xen_do_hypervisor_callback)
  
  /*
   * Hypervisor uses this for application faults while it executes.
--- 1268,1274 ----
  	decl PER_CPU_VAR(irq_count)
  	jmp  error_exit
  	CFI_ENDPROC
! END(do_hypervisor_callback)
  
  /*
   * Hypervisor uses this for application faults while it executes.
diff -cBr 2.6.35/arch/x86/kernel/hw_breakpoint.c linux-2.6.35.y-512ac85/arch/x86/kernel/hw_breakpoint.c
*** 2.6.35/arch/x86/kernel/hw_breakpoint.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/hw_breakpoint.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 421,430 ****
  	dr6_p = (unsigned long *)ERR_PTR(args->err);
  	dr6 = *dr6_p;
  
- 	/* If it's a single step, TRAP bits are random */
- 	if (dr6 & DR_STEP)
- 		return NOTIFY_DONE;
- 
  	/* Do an early return if no trap bits are set in DR6 */
  	if ((dr6 & DR_TRAP_BITS) == 0)
  		return NOTIFY_DONE;
--- 421,426 ----
diff -cBr 2.6.35/arch/x86/kernel/microcode_amd.c linux-2.6.35.y-512ac85/arch/x86/kernel/microcode_amd.c
*** 2.6.35/arch/x86/kernel/microcode_amd.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/microcode_amd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 66,71 ****
--- 66,72 ----
  	unsigned int			mpb[0];
  };
  
+ #define UCODE_MAX_SIZE			2048
  #define UCODE_CONTAINER_SECTION_HDR	8
  #define UCODE_CONTAINER_HEADER_SIZE	12
  
***************
*** 124,160 ****
  	return 1;
  }
  
- static unsigned int verify_ucode_size(int cpu, const u8 *buf, unsigned int size)
- {
- 	struct cpuinfo_x86 *c = &cpu_data(cpu);
- 	unsigned int max_size, actual_size;
- 
- #define F1XH_MPB_MAX_SIZE 2048
- #define F14H_MPB_MAX_SIZE 1824
- #define F15H_MPB_MAX_SIZE 4096
- 
- 	switch (c->x86) {
- 	case 0x14:
- 		max_size = F14H_MPB_MAX_SIZE;
- 		break;
- 	case 0x15:
- 		max_size = F15H_MPB_MAX_SIZE;
- 		break;
- 	default:
- 		max_size = F1XH_MPB_MAX_SIZE;
- 		break;
- 	}
- 
- 	actual_size = buf[4] + (buf[5] << 8);
- 
- 	if (actual_size > size || actual_size > max_size) {
- 		pr_err("section size mismatch\n");
- 		return 0;
- 	}
- 
- 	return actual_size;
- }
- 
  static int apply_microcode_amd(int cpu)
  {
  	u32 rev, dummy;
--- 125,130 ----
***************
*** 192,202 ****
  }
  
  static void *
! get_next_ucode(int cpu, const u8 *buf, unsigned int size, unsigned int *mc_size)
  {
! 	unsigned int actual_size = 0;
  	u8 section_hdr[UCODE_CONTAINER_SECTION_HDR];
! 	void *mc = NULL;
  
  	if (get_ucode_data(section_hdr, buf, UCODE_CONTAINER_SECTION_HDR))
  		return NULL;
--- 162,172 ----
  }
  
  static void *
! get_next_ucode(const u8 *buf, unsigned int size, unsigned int *mc_size)
  {
! 	unsigned int total_size;
  	u8 section_hdr[UCODE_CONTAINER_SECTION_HDR];
! 	void *mc;
  
  	if (get_ucode_data(section_hdr, buf, UCODE_CONTAINER_SECTION_HDR))
  		return NULL;
***************
*** 206,223 ****
  		return NULL;
  	}
  
! 	actual_size = verify_ucode_size(cpu, buf, size);
! 	if (!actual_size)
! 		return NULL;
  
! 	mc = vmalloc(actual_size);
! 	if (!mc)
  		return NULL;
  
! 	memset(mc, 0, actual_size);
! 	get_ucode_data(mc, buf + UCODE_CONTAINER_SECTION_HDR, actual_size);
! 	*mc_size = actual_size + UCODE_CONTAINER_SECTION_HDR;
! 
  	return mc;
  }
  
--- 176,198 ----
  		return NULL;
  	}
  
! 	total_size = (unsigned long) (section_hdr[4] + (section_hdr[5] << 8));
  
! 	if (total_size > size || total_size > UCODE_MAX_SIZE) {
! 		pr_err("error: size mismatch\n");
  		return NULL;
+ 	}
  
! 	mc = vmalloc(UCODE_MAX_SIZE);
! 	if (mc) {
! 		memset(mc, 0, UCODE_MAX_SIZE);
! 		if (get_ucode_data(mc, buf + UCODE_CONTAINER_SECTION_HDR,
! 				   total_size)) {
! 			vfree(mc);
! 			mc = NULL;
! 		} else
! 			*mc_size = total_size + UCODE_CONTAINER_SECTION_HDR;
! 	}
  	return mc;
  }
  
***************
*** 283,289 ****
  		unsigned int uninitialized_var(mc_size);
  		struct microcode_header_amd *mc_header;
  
! 		mc = get_next_ucode(cpu, ucode_ptr, leftover, &mc_size);
  		if (!mc)
  			break;
  
--- 258,264 ----
  		unsigned int uninitialized_var(mc_size);
  		struct microcode_header_amd *mc_header;
  
! 		mc = get_next_ucode(ucode_ptr, leftover, &mc_size);
  		if (!mc)
  			break;
  
diff -cBr 2.6.35/arch/x86/kernel/microcode_intel.c linux-2.6.35.y-512ac85/arch/x86/kernel/microcode_intel.c
*** 2.6.35/arch/x86/kernel/microcode_intel.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/microcode_intel.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 364,370 ****
  
  		/* For performance reasons, reuse mc area when possible */
  		if (!mc || mc_size > curr_mc_size) {
! 			vfree(mc);
  			mc = vmalloc(mc_size);
  			if (!mc)
  				break;
--- 364,371 ----
  
  		/* For performance reasons, reuse mc area when possible */
  		if (!mc || mc_size > curr_mc_size) {
! 			if (mc)
! 				vfree(mc);
  			mc = vmalloc(mc_size);
  			if (!mc)
  				break;
***************
*** 373,383 ****
  
  		if (get_ucode_data(mc, ucode_ptr, mc_size) ||
  		    microcode_sanity_check(mc) < 0) {
  			break;
  		}
  
  		if (get_matching_microcode(&uci->cpu_sig, mc, new_rev)) {
! 			vfree(new_mc);
  			new_rev = mc_header.rev;
  			new_mc  = mc;
  			mc = NULL;	/* trigger new vmalloc */
--- 374,386 ----
  
  		if (get_ucode_data(mc, ucode_ptr, mc_size) ||
  		    microcode_sanity_check(mc) < 0) {
+ 			vfree(mc);
  			break;
  		}
  
  		if (get_matching_microcode(&uci->cpu_sig, mc, new_rev)) {
! 			if (new_mc)
! 				vfree(new_mc);
  			new_rev = mc_header.rev;
  			new_mc  = mc;
  			mc = NULL;	/* trigger new vmalloc */
***************
*** 387,396 ****
  		leftover  -= mc_size;
  	}
  
! 	vfree(mc);
  
  	if (leftover) {
! 		vfree(new_mc);
  		state = UCODE_ERROR;
  		goto out;
  	}
--- 390,401 ----
  		leftover  -= mc_size;
  	}
  
! 	if (mc)
! 		vfree(mc);
  
  	if (leftover) {
! 		if (new_mc)
! 			vfree(new_mc);
  		state = UCODE_ERROR;
  		goto out;
  	}
***************
*** 400,406 ****
  		goto out;
  	}
  
! 	vfree(uci->mc);
  	uci->mc = (struct microcode_intel *)new_mc;
  
  	pr_debug("CPU%d found a matching microcode update with version 0x%x (current=0x%x)\n",
--- 405,412 ----
  		goto out;
  	}
  
! 	if (uci->mc)
! 		vfree(uci->mc);
  	uci->mc = (struct microcode_intel *)new_mc;
  
  	pr_debug("CPU%d found a matching microcode update with version 0x%x (current=0x%x)\n",
diff -cBr 2.6.35/arch/x86/kernel/pci-gart_64.c linux-2.6.35.y-512ac85/arch/x86/kernel/pci-gart_64.c
*** 2.6.35/arch/x86/kernel/pci-gart_64.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/pci-gart_64.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 80,88 ****
  #define AGPEXTERN
  #endif
  
- /* GART can only remap to physical addresses < 1TB */
- #define GART_MAX_PHYS_ADDR	(1ULL << 40)
- 
  /* backdoor interface to AGP driver */
  AGPEXTERN int agp_memory_reserved;
  AGPEXTERN __u32 *agp_gatt_table;
--- 80,85 ----
***************
*** 214,226 ****
  				size_t size, int dir, unsigned long align_mask)
  {
  	unsigned long npages = iommu_num_pages(phys_mem, size, PAGE_SIZE);
! 	unsigned long iommu_page;
  	int i;
  
- 	if (unlikely(phys_mem + size > GART_MAX_PHYS_ADDR))
- 		return bad_dma_addr;
- 
- 	iommu_page = alloc_iommu(dev, npages, align_mask);
  	if (iommu_page == -1) {
  		if (!nonforced_iommu(dev, phys_mem, size))
  			return phys_mem;
--- 211,219 ----
  				size_t size, int dir, unsigned long align_mask)
  {
  	unsigned long npages = iommu_num_pages(phys_mem, size, PAGE_SIZE);
! 	unsigned long iommu_page = alloc_iommu(dev, npages, align_mask);
  	int i;
  
  	if (iommu_page == -1) {
  		if (!nonforced_iommu(dev, phys_mem, size))
  			return phys_mem;
diff -cBr 2.6.35/arch/x86/kernel/process.c linux-2.6.35.y-512ac85/arch/x86/kernel/process.c
*** 2.6.35/arch/x86/kernel/process.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/process.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 525,530 ****
--- 525,566 ----
  	return (edx & MWAIT_EDX_C1);
  }
  
+ /*
+  * Check for AMD CPUs, where APIC timer interrupt does not wake up CPU from C1e.
+  * For more information see
+  * - Erratum #400 for NPT family 0xf and family 0x10 CPUs
+  * - Erratum #365 for family 0x11 (not affected because C1e not in use)
+  */
+ static int __cpuinit check_c1e_idle(const struct cpuinfo_x86 *c)
+ {
+ 	u64 val;
+ 	if (c->x86_vendor != X86_VENDOR_AMD)
+ 		goto no_c1e_idle;
+ 
+ 	/* Family 0x0f models < rev F do not have C1E */
+ 	if (c->x86 == 0x0F && c->x86_model >= 0x40)
+ 		return 1;
+ 
+ 	if (c->x86 == 0x10) {
+ 		/*
+ 		 * check OSVW bit for CPUs that are not affected
+ 		 * by erratum #400
+ 		 */
+ 		if (cpu_has(c, X86_FEATURE_OSVW)) {
+ 			rdmsrl(MSR_AMD64_OSVW_ID_LENGTH, val);
+ 			if (val >= 2) {
+ 				rdmsrl(MSR_AMD64_OSVW_STATUS, val);
+ 				if (!(val & BIT(1)))
+ 					goto no_c1e_idle;
+ 			}
+ 		}
+ 		return 1;
+ 	}
+ 
+ no_c1e_idle:
+ 	return 0;
+ }
+ 
  static cpumask_var_t c1e_mask;
  static int c1e_detected;
  
***************
*** 602,609 ****
  		 */
  		printk(KERN_INFO "using mwait in idle threads.\n");
  		pm_idle = mwait_idle;
! 	} else if (cpu_has_amd_erratum(amd_erratum_400)) {
! 		/* E400: APIC timer interrupt does not wake up CPU from C1e */
  		printk(KERN_INFO "using C1E aware idle routine\n");
  		pm_idle = c1e_idle;
  	} else
--- 638,644 ----
  		 */
  		printk(KERN_INFO "using mwait in idle threads.\n");
  		pm_idle = mwait_idle;
! 	} else if (check_c1e_idle(c)) {
  		printk(KERN_INFO "using C1E aware idle routine\n");
  		pm_idle = c1e_idle;
  	} else
diff -cBr 2.6.35/arch/x86/kernel/pvclock.c linux-2.6.35.y-512ac85/arch/x86/kernel/pvclock.c
*** 2.6.35/arch/x86/kernel/pvclock.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/pvclock.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 120,130 ****
  
  static atomic64_t last_value = ATOMIC64_INIT(0);
  
- void pvclock_resume(void)
- {
- 	atomic64_set(&last_value, 0);
- }
- 
  cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)
  {
  	struct pvclock_shadow_time shadow;
--- 120,125 ----
diff -cBr 2.6.35/arch/x86/kernel/smpboot.c linux-2.6.35.y-512ac85/arch/x86/kernel/smpboot.c
*** 2.6.35/arch/x86/kernel/smpboot.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/smpboot.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1387,1480 ****
  	local_irq_disable();
  }
  
- #define MWAIT_SUBSTATE_MASK		0xf
- #define MWAIT_SUBSTATE_SIZE		4
- 
- #define CPUID_MWAIT_LEAF		5
- #define CPUID5_ECX_EXTENSIONS_SUPPORTED 0x1
- 
- /*
-  * We need to flush the caches before going to sleep, lest we have
-  * dirty data in our caches when we come back up.
-  */
- static inline void mwait_play_dead(void)
- {
- 	unsigned int eax, ebx, ecx, edx;
- 	unsigned int highest_cstate = 0;
- 	unsigned int highest_subcstate = 0;
- 	int i;
- 	void *mwait_ptr;
- 
- 	if (!cpu_has(&current_cpu_data, X86_FEATURE_MWAIT))
- 		return;
- 	if (!cpu_has(&current_cpu_data, X86_FEATURE_CLFLSH))
- 		return;
- 	if (current_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)
- 		return;
- 
- 	eax = CPUID_MWAIT_LEAF;
- 	ecx = 0;
- 	native_cpuid(&eax, &ebx, &ecx, &edx);
- 
- 	/*
- 	 * eax will be 0 if EDX enumeration is not valid.
- 	 * Initialized below to cstate, sub_cstate value when EDX is valid.
- 	 */
- 	if (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED)) {
- 		eax = 0;
- 	} else {
- 		edx >>= MWAIT_SUBSTATE_SIZE;
- 		for (i = 0; i < 7 && edx; i++, edx >>= MWAIT_SUBSTATE_SIZE) {
- 			if (edx & MWAIT_SUBSTATE_MASK) {
- 				highest_cstate = i;
- 				highest_subcstate = edx & MWAIT_SUBSTATE_MASK;
- 			}
- 		}
- 		eax = (highest_cstate << MWAIT_SUBSTATE_SIZE) |
- 			(highest_subcstate - 1);
- 	}
- 
- 	/*
- 	 * This should be a memory location in a cache line which is
- 	 * unlikely to be touched by other processors.  The actual
- 	 * content is immaterial as it is not actually modified in any way.
- 	 */
- 	mwait_ptr = &current_thread_info()->flags;
- 
- 	wbinvd();
- 
- 	while (1) {
- 		/*
- 		 * The CLFLUSH is a workaround for erratum AAI65 for
- 		 * the Xeon 7400 series.  It's not clear it is actually
- 		 * needed, but it should be harmless in either case.
- 		 * The WBINVD is insufficient due to the spurious-wakeup
- 		 * case where we return around the loop.
- 		 */
- 		clflush(mwait_ptr);
- 		__monitor(mwait_ptr, 0, 0);
- 		mb();
- 		__mwait(eax, 0);
- 	}
- }
- 
- static inline void hlt_play_dead(void)
- {
- 	if (current_cpu_data.x86 >= 4)
- 		wbinvd();
- 
- 	while (1) {
- 		native_halt();
- 	}
- }
- 
  void native_play_dead(void)
  {
  	play_dead_common();
  	tboot_shutdown(TB_SHUTDOWN_WFS);
! 
! 	mwait_play_dead();	/* Only returns on failure */
! 	hlt_play_dead();
  }
  
  #else /* ... !CONFIG_HOTPLUG_CPU */
--- 1387,1397 ----
  	local_irq_disable();
  }
  
  void native_play_dead(void)
  {
  	play_dead_common();
  	tboot_shutdown(TB_SHUTDOWN_WFS);
! 	wbinvd_halt();
  }
  
  #else /* ... !CONFIG_HOTPLUG_CPU */
diff -cBr 2.6.35/arch/x86/kernel/tsc.c linux-2.6.35.y-512ac85/arch/x86/kernel/tsc.c
*** 2.6.35/arch/x86/kernel/tsc.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/tsc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 104,117 ****
  
  __setup("notsc", notsc_setup);
  
- static int no_sched_irq_time;
- 
  static int __init tsc_setup(char *str)
  {
  	if (!strcmp(str, "reliable"))
  		tsc_clocksource_reliable = 1;
- 	if (!strncmp(str, "noirqtime", 9))
- 		no_sched_irq_time = 1;
  	return 1;
  }
  
--- 104,113 ----
***************
*** 806,812 ****
  	if (!tsc_unstable) {
  		tsc_unstable = 1;
  		sched_clock_stable = 0;
- 		disable_sched_clock_irqtime();
  		printk(KERN_INFO "Marking TSC unstable due to %s\n", reason);
  		/* Change only the rating, when not registered */
  		if (clocksource_tsc.mult)
--- 802,807 ----
***************
*** 995,1003 ****
  	/* now allow native_sched_clock() to use rdtsc */
  	tsc_disabled = 0;
  
- 	if (!no_sched_irq_time)
- 		enable_sched_clock_irqtime();
- 
  	lpj = ((u64)tsc_khz * 1000);
  	do_div(lpj, HZ);
  	lpj_fine = lpj;
--- 990,995 ----
diff -cBr 2.6.35/arch/x86/kernel/xsave.c linux-2.6.35.y-512ac85/arch/x86/kernel/xsave.c
*** 2.6.35/arch/x86/kernel/xsave.c	2011-05-07 19:57:18.286750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kernel/xsave.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 305,312 ****
   */
  static void __init setup_xstate_init(void)
  {
! 	init_xstate_buf = alloc_bootmem_align(xstate_size,
! 			      __alignof__(struct xsave_struct));
  	init_xstate_buf->i387.mxcsr = MXCSR_DEFAULT;
  }
  
--- 305,311 ----
   */
  static void __init setup_xstate_init(void)
  {
! 	init_xstate_buf = alloc_bootmem(xstate_size);
  	init_xstate_buf->i387.mxcsr = MXCSR_DEFAULT;
  }
  
diff -cBr 2.6.35/arch/x86/kvm/i8259.c linux-2.6.35.y-512ac85/arch/x86/kvm/i8259.c
*** 2.6.35/arch/x86/kvm/i8259.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kvm/i8259.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 553,560 ****
  	s->irq_request_opaque = kvm;
  	s->pics[0].pics_state = s;
  	s->pics[1].pics_state = s;
- 	s->pics[0].isr_ack = 0xff;
- 	s->pics[1].isr_ack = 0xff;
  
  	/*
  	 * Initialize PIO device
--- 553,558 ----
diff -cBr 2.6.35/arch/x86/kvm/svm.c linux-2.6.35.y-512ac85/arch/x86/kvm/svm.c
*** 2.6.35/arch/x86/kvm/svm.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kvm/svm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3096,3103 ****
  	sync_lapic_to_cr8(vcpu);
  
  	save_host_msrs(vcpu);
! 	savesegment(fs, fs_selector);
! 	savesegment(gs, gs_selector);
  	ldt_selector = kvm_read_ldt();
  	svm->vmcb->save.cr2 = vcpu->arch.cr2;
  	/* required for live migration with NPT */
--- 3096,3103 ----
  	sync_lapic_to_cr8(vcpu);
  
  	save_host_msrs(vcpu);
! 	fs_selector = kvm_read_fs();
! 	gs_selector = kvm_read_gs();
  	ldt_selector = kvm_read_ldt();
  	svm->vmcb->save.cr2 = vcpu->arch.cr2;
  	/* required for live migration with NPT */
***************
*** 3184,3198 ****
  	vcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
  	vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
  
! 	load_host_msrs(vcpu);
  	kvm_load_ldt(ldt_selector);
! 	loadsegment(fs, fs_selector);
! #ifdef CONFIG_X86_64
! 	load_gs_index(gs_selector);
! 	wrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);
! #else
! 	loadsegment(gs, gs_selector);
! #endif
  
  	reload_tss(vcpu);
  
--- 3184,3193 ----
  	vcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
  	vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
  
! 	kvm_load_fs(fs_selector);
! 	kvm_load_gs(gs_selector);
  	kvm_load_ldt(ldt_selector);
! 	load_host_msrs(vcpu);
  
  	reload_tss(vcpu);
  
diff -cBr 2.6.35/arch/x86/kvm/vmx.c linux-2.6.35.y-512ac85/arch/x86/kvm/vmx.c
*** 2.6.35/arch/x86/kvm/vmx.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kvm/vmx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 746,752 ****
  	 */
  	vmx->host_state.ldt_sel = kvm_read_ldt();
  	vmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;
! 	savesegment(fs, vmx->host_state.fs_sel);
  	if (!(vmx->host_state.fs_sel & 7)) {
  		vmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);
  		vmx->host_state.fs_reload_needed = 0;
--- 746,752 ----
  	 */
  	vmx->host_state.ldt_sel = kvm_read_ldt();
  	vmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;
! 	vmx->host_state.fs_sel = kvm_read_fs();
  	if (!(vmx->host_state.fs_sel & 7)) {
  		vmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);
  		vmx->host_state.fs_reload_needed = 0;
***************
*** 754,760 ****
  		vmcs_write16(HOST_FS_SELECTOR, 0);
  		vmx->host_state.fs_reload_needed = 1;
  	}
! 	savesegment(gs, vmx->host_state.gs_sel);
  	if (!(vmx->host_state.gs_sel & 7))
  		vmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);
  	else {
--- 754,760 ----
  		vmcs_write16(HOST_FS_SELECTOR, 0);
  		vmx->host_state.fs_reload_needed = 1;
  	}
! 	vmx->host_state.gs_sel = kvm_read_gs();
  	if (!(vmx->host_state.gs_sel & 7))
  		vmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);
  	else {
***************
*** 771,779 ****
  #endif
  
  #ifdef CONFIG_X86_64
! 	rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
! 	if (is_long_mode(&vmx->vcpu))
  		wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
  #endif
  	for (i = 0; i < vmx->save_nmsrs; ++i)
  		kvm_set_shared_msr(vmx->guest_msrs[i].index,
--- 771,780 ----
  #endif
  
  #ifdef CONFIG_X86_64
! 	if (is_long_mode(&vmx->vcpu)) {
! 		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
  		wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
+ 	}
  #endif
  	for (i = 0; i < vmx->save_nmsrs; ++i)
  		kvm_set_shared_msr(vmx->guest_msrs[i].index,
***************
*** 783,810 ****
  
  static void __vmx_load_host_state(struct vcpu_vmx *vmx)
  {
  	if (!vmx->host_state.loaded)
  		return;
  
  	++vmx->vcpu.stat.host_state_reload;
  	vmx->host_state.loaded = 0;
! #ifdef CONFIG_X86_64
! 	if (is_long_mode(&vmx->vcpu))
! 		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
! #endif
  	if (vmx->host_state.gs_ldt_reload_needed) {
  		kvm_load_ldt(vmx->host_state.ldt_sel);
  #ifdef CONFIG_X86_64
! 		load_gs_index(vmx->host_state.gs_sel);
! #else
! 		loadsegment(gs, vmx->host_state.gs_sel);
  #endif
  	}
- 	if (vmx->host_state.fs_reload_needed)
- 		loadsegment(fs, vmx->host_state.fs_sel);
  	reload_tss();
  #ifdef CONFIG_X86_64
! 	wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
  #endif
  	load_gdt(&__get_cpu_var(host_gdt));
  }
--- 784,817 ----
  
  static void __vmx_load_host_state(struct vcpu_vmx *vmx)
  {
+ 	unsigned long flags;
+ 
  	if (!vmx->host_state.loaded)
  		return;
  
  	++vmx->vcpu.stat.host_state_reload;
  	vmx->host_state.loaded = 0;
! 	if (vmx->host_state.fs_reload_needed)
! 		kvm_load_fs(vmx->host_state.fs_sel);
  	if (vmx->host_state.gs_ldt_reload_needed) {
  		kvm_load_ldt(vmx->host_state.ldt_sel);
+ 		/*
+ 		 * If we have to reload gs, we must take care to
+ 		 * preserve our gs base.
+ 		 */
+ 		local_irq_save(flags);
+ 		kvm_load_gs(vmx->host_state.gs_sel);
  #ifdef CONFIG_X86_64
! 		wrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));
  #endif
+ 		local_irq_restore(flags);
  	}
  	reload_tss();
  #ifdef CONFIG_X86_64
! 	if (is_long_mode(&vmx->vcpu)) {
! 		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
! 		wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
! 	}
  #endif
  	load_gdt(&__get_cpu_var(host_gdt));
  }
***************
*** 2511,2518 ****
  	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
  	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
  	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
! 	vmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */
! 	vmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */
  	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
  #ifdef CONFIG_X86_64
  	rdmsrl(MSR_FS_BASE, a);
--- 2518,2525 ----
  	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
  	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
  	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
! 	vmcs_write16(HOST_FS_SELECTOR, kvm_read_fs());    /* 22.2.4 */
! 	vmcs_write16(HOST_GS_SELECTOR, kvm_read_gs());    /* 22.2.4 */
  	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
  #ifdef CONFIG_X86_64
  	rdmsrl(MSR_FS_BASE, a);
diff -cBr 2.6.35/arch/x86/kvm/x86.c linux-2.6.35.y-512ac85/arch/x86/kvm/x86.c
*** 2.6.35/arch/x86/kvm/x86.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/kvm/x86.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2220,2226 ****
  		!kvm_exception_is_soft(vcpu->arch.exception.nr);
  	events->exception.nr = vcpu->arch.exception.nr;
  	events->exception.has_error_code = vcpu->arch.exception.has_error_code;
- 	events->exception.pad = 0;
  	events->exception.error_code = vcpu->arch.exception.error_code;
  
  	events->interrupt.injected =
--- 2220,2225 ----
***************
*** 2234,2247 ****
  	events->nmi.injected = vcpu->arch.nmi_injected;
  	events->nmi.pending = vcpu->arch.nmi_pending;
  	events->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);
- 	events->nmi.pad = 0;
  
  	events->sipi_vector = vcpu->arch.sipi_vector;
  
  	events->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
  			 | KVM_VCPUEVENT_VALID_SIPI_VECTOR
  			 | KVM_VCPUEVENT_VALID_SHADOW);
! 	memset(&events->reserved, 0, sizeof(events->reserved));
  	vcpu_put(vcpu);
  }
  
--- 2233,2245 ----
  	events->nmi.injected = vcpu->arch.nmi_injected;
  	events->nmi.pending = vcpu->arch.nmi_pending;
  	events->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);
  
  	events->sipi_vector = vcpu->arch.sipi_vector;
  
  	events->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
  			 | KVM_VCPUEVENT_VALID_SIPI_VECTOR
  			 | KVM_VCPUEVENT_VALID_SHADOW);
! 
  	vcpu_put(vcpu);
  }
  
***************
*** 2291,2297 ****
  	dbgregs->dr6 = vcpu->arch.dr6;
  	dbgregs->dr7 = vcpu->arch.dr7;
  	dbgregs->flags = 0;
- 	memset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));
  
  	vcpu_put(vcpu);
  }
--- 2289,2294 ----
***************
*** 2759,2765 ****
  		sizeof(ps->channels));
  	ps->flags = kvm->arch.vpit->pit_state.flags;
  	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
- 	memset(&ps->reserved, 0, sizeof(ps->reserved));
  	return r;
  }
  
--- 2756,2761 ----
***************
*** 2829,2834 ****
--- 2825,2834 ----
  	if (is_dirty) {
  		struct kvm_memslots *slots, *old_slots;
  
+ 		spin_lock(&kvm->mmu_lock);
+ 		kvm_mmu_slot_remove_write_access(kvm, log->slot);
+ 		spin_unlock(&kvm->mmu_lock);
+ 
  		slots = kzalloc(sizeof(struct kvm_memslots), GFP_KERNEL);
  		if (!slots)
  			goto out_free;
***************
*** 2841,2851 ****
  		synchronize_srcu_expedited(&kvm->srcu);
  		dirty_bitmap = old_slots->memslots[log->slot].dirty_bitmap;
  		kfree(old_slots);
- 
- 		spin_lock(&kvm->mmu_lock);
- 		kvm_mmu_slot_remove_write_access(kvm, log->slot);
- 		spin_unlock(&kvm->mmu_lock);
- 
  	}
  
  	r = 0;
--- 2841,2846 ----
***************
*** 3157,3163 ****
  		now_ns = timespec_to_ns(&now);
  		user_ns.clock = kvm->arch.kvmclock_offset + now_ns;
  		user_ns.flags = 0;
- 		memset(&user_ns.pad, 0, sizeof(user_ns.pad));
  
  		r = -EFAULT;
  		if (copy_to_user(argp, &user_ns, sizeof(user_ns)))
--- 3152,3157 ----
diff -cBr 2.6.35/arch/x86/lib/semaphore_32.S linux-2.6.35.y-512ac85/arch/x86/lib/semaphore_32.S
*** 2.6.35/arch/x86/lib/semaphore_32.S	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/lib/semaphore_32.S	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,42 ****
   */
  #ifdef CONFIG_SMP
  ENTRY(__write_lock_failed)
! 	CFI_STARTPROC
  	FRAME
  2: 	LOCK_PREFIX
  	addl	$ RW_LOCK_BIAS,(%eax)
--- 36,42 ----
   */
  #ifdef CONFIG_SMP
  ENTRY(__write_lock_failed)
! 	CFI_STARTPROC simple
  	FRAME
  2: 	LOCK_PREFIX
  	addl	$ RW_LOCK_BIAS,(%eax)
diff -cBr 2.6.35/arch/x86/mm/fault.c linux-2.6.35.y-512ac85/arch/x86/mm/fault.c
*** 2.6.35/arch/x86/mm/fault.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/mm/fault.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 831,843 ****
  	       unsigned long address, unsigned int fault)
  {
  	if (fault & VM_FAULT_OOM) {
- 		/* Kernel mode? Handle exceptions or die: */
- 		if (!(error_code & PF_USER)) {
- 			up_read(&current->mm->mmap_sem);
- 			no_context(regs, error_code, address);
- 			return;
- 		}
- 
  		out_of_memory(regs, error_code, address);
  	} else {
  		if (fault & (VM_FAULT_SIGBUS|VM_FAULT_HWPOISON))
--- 831,836 ----
diff -cBr 2.6.35/arch/x86/mm/pgtable.c linux-2.6.35.y-512ac85/arch/x86/mm/pgtable.c
*** 2.6.35/arch/x86/mm/pgtable.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/mm/pgtable.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 160,166 ****
  	 * section 8.1: in PAE mode we explicitly have to flush the
  	 * TLB via cr3 if the top-level pgd is changed...
  	 */
! 	flush_tlb_mm(mm);
  }
  #else  /* !CONFIG_X86_PAE */
  
--- 160,167 ----
  	 * section 8.1: in PAE mode we explicitly have to flush the
  	 * TLB via cr3 if the top-level pgd is changed...
  	 */
! 	if (mm == current->active_mm)
! 		write_cr3(read_cr3());
  }
  #else  /* !CONFIG_X86_PAE */
  
diff -cBr 2.6.35/arch/x86/oprofile/op_model_amd.c linux-2.6.35.y-512ac85/arch/x86/oprofile/op_model_amd.c
*** 2.6.35/arch/x86/oprofile/op_model_amd.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/oprofile/op_model_amd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 484,512 ****
  	return 0;
  }
  
! /*
!  * check and reserve APIC extended interrupt LVT offset for IBS if
!  * available
!  *
!  * init_ibs() preforms implicitly cpu-local operations, so pin this
!  * thread to its current CPU
!  */
! 
  static void init_ibs(void)
  {
- 	preempt_disable();
- 
  	ibs_caps = get_ibs_caps();
  	if (!ibs_caps)
! 		goto out;
  
! 	if (__init_ibs_nmi() < 0)
  		ibs_caps = 0;
! 	else
! 		printk(KERN_INFO "oprofile: AMD IBS detected (0x%08x)\n", ibs_caps);
  
! out:
! 	preempt_enable();
  }
  
  static int (*create_arch_files)(struct super_block *sb, struct dentry *root);
--- 484,504 ----
  	return 0;
  }
  
! /* initialize the APIC for the IBS interrupts if available */
  static void init_ibs(void)
  {
  	ibs_caps = get_ibs_caps();
+ 
  	if (!ibs_caps)
! 		return;
  
! 	if (__init_ibs_nmi()) {
  		ibs_caps = 0;
! 		return;
! 	}
  
! 	printk(KERN_INFO "oprofile: AMD IBS detected (0x%08x)\n",
! 	       (unsigned)ibs_caps);
  }
  
  static int (*create_arch_files)(struct super_block *sb, struct dentry *root);
diff -cBr 2.6.35/arch/x86/vdso/Makefile linux-2.6.35.y-512ac85/arch/x86/vdso/Makefile
*** 2.6.35/arch/x86/vdso/Makefile	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/vdso/Makefile	2010-11-22 14:01:26.000000000 -0500
***************
*** 25,31 ****
  
  export CPPFLAGS_vdso.lds += -P -C
  
! VDSO_LDFLAGS_vdso.lds = -m64 -Wl,-soname=linux-vdso.so.1 \
  		      	-Wl,-z,max-page-size=4096 -Wl,-z,common-page-size=4096
  
  $(obj)/vdso.o: $(src)/vdso.S $(obj)/vdso.so
--- 25,31 ----
  
  export CPPFLAGS_vdso.lds += -P -C
  
! VDSO_LDFLAGS_vdso.lds = -m elf_x86_64 -Wl,-soname=linux-vdso.so.1 \
  		      	-Wl,-z,max-page-size=4096 -Wl,-z,common-page-size=4096
  
  $(obj)/vdso.o: $(src)/vdso.S $(obj)/vdso.so
***************
*** 69,75 ****
  vdso32-images			= $(vdso32.so-y:%=vdso32-%.so)
  
  CPPFLAGS_vdso32.lds = $(CPPFLAGS_vdso.lds)
! VDSO_LDFLAGS_vdso32.lds = -m32 -Wl,-soname=linux-gate.so.1
  
  # This makes sure the $(obj) subdirectory exists even though vdso32/
  # is not a kbuild sub-make subdirectory.
--- 69,75 ----
  vdso32-images			= $(vdso32.so-y:%=vdso32-%.so)
  
  CPPFLAGS_vdso32.lds = $(CPPFLAGS_vdso.lds)
! VDSO_LDFLAGS_vdso32.lds = -m elf_i386 -Wl,-soname=linux-gate.so.1
  
  # This makes sure the $(obj) subdirectory exists even though vdso32/
  # is not a kbuild sub-make subdirectory.
diff -cBr 2.6.35/arch/x86/xen/enlighten.c linux-2.6.35.y-512ac85/arch/x86/xen/enlighten.c
*** 2.6.35/arch/x86/xen/enlighten.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/xen/enlighten.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1000,1005 ****
--- 1000,1009 ----
  {
  	struct sched_shutdown r = { .reason = reason };
  
+ #ifdef CONFIG_SMP
+ 	stop_other_cpus();
+ #endif
+ 
  	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
  		BUG();
  }
diff -cBr 2.6.35/arch/x86/xen/mmu.c linux-2.6.35.y-512ac85/arch/x86/xen/mmu.c
*** 2.6.35/arch/x86/xen/mmu.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/xen/mmu.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1641,1646 ****
--- 1641,1649 ----
  		for (pteidx = 0; pteidx < PTRS_PER_PTE; pteidx++, pfn++) {
  			pte_t pte;
  
+ 			if (pfn > max_pfn_mapped)
+ 				max_pfn_mapped = pfn;
+ 
  			if (!pte_none(pte_page[pteidx]))
  				continue;
  
***************
*** 1684,1695 ****
  	pud_t *l3;
  	pmd_t *l2;
  
- 	/* max_pfn_mapped is the last pfn mapped in the initial memory
- 	 * mappings. Considering that on Xen after the kernel mappings we
- 	 * have the mappings of some pages that don't exist in pfn space, we
- 	 * set max_pfn_mapped to the last real pfn mapped. */
- 	max_pfn_mapped = PFN_DOWN(__pa(xen_start_info->mfn_list));
- 
  	/* Zap identity mapping */
  	init_level4_pgt[0] = __pgd(0);
  
--- 1687,1692 ----
***************
*** 1753,1759 ****
  {
  	pmd_t *kernel_pmd;
  
! 	max_pfn_mapped = PFN_DOWN(__pa(xen_start_info->mfn_list));
  
  	kernel_pmd = m2v(pgd[KERNEL_PGD_BOUNDARY].pgd);
  	memcpy(level2_kernel_pgt, kernel_pmd, sizeof(pmd_t) * PTRS_PER_PMD);
--- 1750,1758 ----
  {
  	pmd_t *kernel_pmd;
  
! 	max_pfn_mapped = PFN_DOWN(__pa(xen_start_info->pt_base) +
! 				  xen_start_info->nr_pt_frames * PAGE_SIZE +
! 				  512*1024);
  
  	kernel_pmd = m2v(pgd[KERNEL_PGD_BOUNDARY].pgd);
  	memcpy(level2_kernel_pgt, kernel_pmd, sizeof(pmd_t) * PTRS_PER_PMD);
diff -cBr 2.6.35/arch/x86/xen/time.c linux-2.6.35.y-512ac85/arch/x86/xen/time.c
*** 2.6.35/arch/x86/xen/time.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/arch/x86/xen/time.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 425,432 ****
  {
  	int cpu;
  
- 	pvclock_resume();
- 
  	if (xen_clockevent != &xen_vcpuop_clockevent)
  		return;
  
--- 425,430 ----
diff -cBr 2.6.35/block/blk-map.c linux-2.6.35.y-512ac85/block/blk-map.c
*** 2.6.35/block/blk-map.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/block/blk-map.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 205,212 ****
  			unaligned = 1;
  			break;
  		}
- 		if (!iov[i].iov_len)
- 			return -EINVAL;
  	}
  
  	if (unaligned || (q->dma_pad_mask & len) || map_data)
--- 205,210 ----
diff -cBr 2.6.35/block/blk-merge.c linux-2.6.35.y-512ac85/block/blk-merge.c
*** 2.6.35/block/blk-merge.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/block/blk-merge.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 22,28 ****
  		return 0;
  
  	fbio = bio;
! 	cluster = blk_queue_cluster(q);
  	seg_size = 0;
  	phys_size = nr_phys_segs = 0;
  	for_each_bio(bio) {
--- 22,28 ----
  		return 0;
  
  	fbio = bio;
! 	cluster = test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
  	seg_size = 0;
  	phys_size = nr_phys_segs = 0;
  	for_each_bio(bio) {
***************
*** 88,94 ****
  static int blk_phys_contig_segment(struct request_queue *q, struct bio *bio,
  				   struct bio *nxt)
  {
! 	if (!blk_queue_cluster(q))
  		return 0;
  
  	if (bio->bi_seg_back_size + nxt->bi_seg_front_size >
--- 88,94 ----
  static int blk_phys_contig_segment(struct request_queue *q, struct bio *bio,
  				   struct bio *nxt)
  {
! 	if (!test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
  		return 0;
  
  	if (bio->bi_seg_back_size + nxt->bi_seg_front_size >
***************
*** 124,130 ****
  	int nsegs, cluster;
  
  	nsegs = 0;
! 	cluster = blk_queue_cluster(q);
  
  	/*
  	 * for each bio in rq
--- 124,130 ----
  	int nsegs, cluster;
  
  	nsegs = 0;
! 	cluster = test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
  
  	/*
  	 * for each bio in rq
diff -cBr 2.6.35/block/blk-settings.c linux-2.6.35.y-512ac85/block/blk-settings.c
*** 2.6.35/block/blk-settings.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/block/blk-settings.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 108,114 ****
  	lim->alignment_offset = 0;
  	lim->io_opt = 0;
  	lim->misaligned = 0;
! 	lim->cluster = 1;
  }
  EXPORT_SYMBOL(blk_set_default_limits);
  
--- 108,114 ----
  	lim->alignment_offset = 0;
  	lim->io_opt = 0;
  	lim->misaligned = 0;
! 	lim->no_cluster = 0;
  }
  EXPORT_SYMBOL(blk_set_default_limits);
  
***************
*** 326,332 ****
   *   hardware can operate on without reverting to read-modify-write
   *   operations.
   */
! void blk_queue_physical_block_size(struct request_queue *q, unsigned int size)
  {
  	q->limits.physical_block_size = size;
  
--- 326,332 ----
   *   hardware can operate on without reverting to read-modify-write
   *   operations.
   */
! void blk_queue_physical_block_size(struct request_queue *q, unsigned short size)
  {
  	q->limits.physical_block_size = size;
  
***************
*** 451,456 ****
--- 451,465 ----
  void blk_queue_stack_limits(struct request_queue *t, struct request_queue *b)
  {
  	blk_stack_limits(&t->limits, &b->limits, 0);
+ 
+ 	if (!t->queue_lock)
+ 		WARN_ON_ONCE(1);
+ 	else if (!test_bit(QUEUE_FLAG_CLUSTER, &b->queue_flags)) {
+ 		unsigned long flags;
+ 		spin_lock_irqsave(t->queue_lock, flags);
+ 		queue_flag_clear(QUEUE_FLAG_CLUSTER, t);
+ 		spin_unlock_irqrestore(t->queue_lock, flags);
+ 	}
  }
  EXPORT_SYMBOL(blk_queue_stack_limits);
  
***************
*** 521,527 ****
  	t->io_min = max(t->io_min, b->io_min);
  	t->io_opt = lcm(t->io_opt, b->io_opt);
  
! 	t->cluster &= b->cluster;
  	t->discard_zeroes_data &= b->discard_zeroes_data;
  
  	/* Physical block size a multiple of the logical block size? */
--- 530,536 ----
  	t->io_min = max(t->io_min, b->io_min);
  	t->io_opt = lcm(t->io_opt, b->io_opt);
  
! 	t->no_cluster |= b->no_cluster;
  	t->discard_zeroes_data &= b->discard_zeroes_data;
  
  	/* Physical block size a multiple of the logical block size? */
***************
*** 617,622 ****
--- 626,632 ----
  		       sector_t offset)
  {
  	struct request_queue *t = disk->queue;
+ 	struct request_queue *b = bdev_get_queue(bdev);
  
  	if (bdev_stack_limits(&t->limits, bdev, offset >> 9) < 0) {
  		char top[BDEVNAME_SIZE], bottom[BDEVNAME_SIZE];
***************
*** 627,632 ****
--- 637,653 ----
  		printk(KERN_NOTICE "%s: Warning: Device %s is misaligned\n",
  		       top, bottom);
  	}
+ 
+ 	if (!t->queue_lock)
+ 		WARN_ON_ONCE(1);
+ 	else if (!test_bit(QUEUE_FLAG_CLUSTER, &b->queue_flags)) {
+ 		unsigned long flags;
+ 
+ 		spin_lock_irqsave(t->queue_lock, flags);
+ 		if (!test_bit(QUEUE_FLAG_CLUSTER, &b->queue_flags))
+ 			queue_flag_clear(QUEUE_FLAG_CLUSTER, t);
+ 		spin_unlock_irqrestore(t->queue_lock, flags);
+ 	}
  }
  EXPORT_SYMBOL(disk_stack_limits);
  
diff -cBr 2.6.35/block/blk-sysfs.c linux-2.6.35.y-512ac85/block/blk-sysfs.c
*** 2.6.35/block/blk-sysfs.c	2011-05-07 19:57:18.296750002 -0400
--- linux-2.6.35.y-512ac85/block/blk-sysfs.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 114,120 ****
  
  static ssize_t queue_max_segment_size_show(struct request_queue *q, char *page)
  {
! 	if (blk_queue_cluster(q))
  		return queue_var_show(queue_max_segment_size(q), (page));
  
  	return queue_var_show(PAGE_CACHE_SIZE, (page));
--- 114,120 ----
  
  static ssize_t queue_max_segment_size_show(struct request_queue *q, char *page)
  {
! 	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
  		return queue_var_show(queue_max_segment_size(q), (page));
  
  	return queue_var_show(PAGE_CACHE_SIZE, (page));
***************
*** 502,511 ****
  		return ret;
  
  	ret = kobject_add(&q->kobj, kobject_get(&dev->kobj), "%s", "queue");
! 	if (ret < 0) {
! 		blk_trace_remove_sysfs(dev);
  		return ret;
- 	}
  
  	kobject_uevent(&q->kobj, KOBJ_ADD);
  
--- 502,509 ----
  		return ret;
  
  	ret = kobject_add(&q->kobj, kobject_get(&dev->kobj), "%s", "queue");
! 	if (ret < 0)
  		return ret;
  
  	kobject_uevent(&q->kobj, KOBJ_ADD);
  
diff -cBr 2.6.35/block/genhd.c linux-2.6.35.y-512ac85/block/genhd.c
*** 2.6.35/block/genhd.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/block/genhd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 541,555 ****
  	disk->major = MAJOR(devt);
  	disk->first_minor = MINOR(devt);
  
- 	/* Register BDI before referencing it from bdev */
- 	bdi = &disk->queue->backing_dev_info;
- 	bdi_register_dev(bdi, disk_devt(disk));
- 
  	blk_register_region(disk_devt(disk), disk->minors, NULL,
  			    exact_match, exact_lock, disk);
  	register_disk(disk);
  	blk_register_queue(disk);
  
  	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
  				   "bdi");
  	WARN_ON(retval);
--- 541,553 ----
  	disk->major = MAJOR(devt);
  	disk->first_minor = MINOR(devt);
  
  	blk_register_region(disk_devt(disk), disk->minors, NULL,
  			    exact_match, exact_lock, disk);
  	register_disk(disk);
  	blk_register_queue(disk);
  
+ 	bdi = &disk->queue->backing_dev_info;
+ 	bdi_register_dev(bdi, disk_devt(disk));
  	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
  				   "bdi");
  	WARN_ON(retval);
diff -cBr 2.6.35/block/scsi_ioctl.c linux-2.6.35.y-512ac85/block/scsi_ioctl.c
*** 2.6.35/block/scsi_ioctl.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/block/scsi_ioctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 321,367 ****
  	if (hdr->iovec_count) {
  		const int size = sizeof(struct sg_iovec) * hdr->iovec_count;
  		size_t iov_data_len;
! 		struct sg_iovec *sg_iov;
! 		struct iovec *iov;
! 		int i;
  
! 		sg_iov = kmalloc(size, GFP_KERNEL);
! 		if (!sg_iov) {
  			ret = -ENOMEM;
  			goto out;
  		}
  
! 		if (copy_from_user(sg_iov, hdr->dxferp, size)) {
! 			kfree(sg_iov);
  			ret = -EFAULT;
  			goto out;
  		}
  
- 		/*
- 		 * Sum up the vecs, making sure they don't overflow
- 		 */
- 		iov = (struct iovec *) sg_iov;
- 		iov_data_len = 0;
- 		for (i = 0; i < hdr->iovec_count; i++) {
- 			if (iov_data_len + iov[i].iov_len < iov_data_len) {
- 				kfree(sg_iov);
- 				ret = -EINVAL;
- 				goto out;
- 			}
- 			iov_data_len += iov[i].iov_len;
- 		}
- 
  		/* SG_IO howto says that the shorter of the two wins */
  		if (hdr->dxfer_len < iov_data_len) {
! 			hdr->iovec_count = iov_shorten(iov,
  						       hdr->iovec_count,
  						       hdr->dxfer_len);
  			iov_data_len = hdr->dxfer_len;
  		}
  
! 		ret = blk_rq_map_user_iov(q, rq, NULL, sg_iov, hdr->iovec_count,
  					  iov_data_len, GFP_KERNEL);
! 		kfree(sg_iov);
  	} else if (hdr->dxfer_len)
  		ret = blk_rq_map_user(q, rq, NULL, hdr->dxferp, hdr->dxfer_len,
  				      GFP_KERNEL);
--- 321,353 ----
  	if (hdr->iovec_count) {
  		const int size = sizeof(struct sg_iovec) * hdr->iovec_count;
  		size_t iov_data_len;
! 		struct sg_iovec *iov;
  
! 		iov = kmalloc(size, GFP_KERNEL);
! 		if (!iov) {
  			ret = -ENOMEM;
  			goto out;
  		}
  
! 		if (copy_from_user(iov, hdr->dxferp, size)) {
! 			kfree(iov);
  			ret = -EFAULT;
  			goto out;
  		}
  
  		/* SG_IO howto says that the shorter of the two wins */
+ 		iov_data_len = iov_length((struct iovec *)iov,
+ 					  hdr->iovec_count);
  		if (hdr->dxfer_len < iov_data_len) {
! 			hdr->iovec_count = iov_shorten((struct iovec *)iov,
  						       hdr->iovec_count,
  						       hdr->dxfer_len);
  			iov_data_len = hdr->dxfer_len;
  		}
  
! 		ret = blk_rq_map_user_iov(q, rq, NULL, iov, hdr->iovec_count,
  					  iov_data_len, GFP_KERNEL);
! 		kfree(iov);
  	} else if (hdr->dxfer_len)
  		ret = blk_rq_map_user(q, rq, NULL, hdr->dxferp, hdr->dxfer_len,
  				      GFP_KERNEL);
Only in 2.6.35: build.sh
Only in 2.6.35: diff
Only in 2.6.35/Documentation: android.txt
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/dvb: dvbstb.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: crop.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: fieldseq_bt.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: fieldseq_tb.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: vbi_525.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: vbi_625.pdf
Only in linux-2.6.35.y-512ac85/Documentation/DocBook/v4l: vbi_hsync.pdf
diff -cBr 2.6.35/Documentation/i2c/instantiating-devices linux-2.6.35.y-512ac85/Documentation/i2c/instantiating-devices
*** 2.6.35/Documentation/i2c/instantiating-devices	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/Documentation/i2c/instantiating-devices	2010-11-22 14:01:26.000000000 -0500
***************
*** 100,106 ****
  	(...)
  	i2c_adap = i2c_get_adapter(2);
  	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
! 	strlcpy(i2c_info.type, "isp1301_pnx", I2C_NAME_SIZE);
  	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
  						   normal_i2c);
  	i2c_put_adapter(i2c_adap);
--- 100,106 ----
  	(...)
  	i2c_adap = i2c_get_adapter(2);
  	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
! 	strlcpy(i2c_info.name, "isp1301_pnx", I2C_NAME_SIZE);
  	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
  						   normal_i2c);
  	i2c_put_adapter(i2c_adap);
diff -cBr 2.6.35/Documentation/kernel-parameters.txt linux-2.6.35.y-512ac85/Documentation/kernel-parameters.txt
*** 2.6.35/Documentation/kernel-parameters.txt	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/Documentation/kernel-parameters.txt	2010-11-22 14:01:26.000000000 -0500
***************
*** 917,923 ****
  			     controller
  	i8042.nopnp	[HW] Don't use ACPIPnP / PnPBIOS to discover KBD/AUX
  			     controllers
- 	i8042.notimeout	[HW] Ignore timeout condition signalled by conroller
  	i8042.panicblink=
  			[HW] Frequency with which keyboard LEDs should blink
  			     when kernel panics (default is 0.5 sec)
--- 917,922 ----
***************
*** 2672,2681 ****
  			disables clocksource verification at runtime.
  			Used to enable high-resolution timer mode on older
  			hardware, and in virtualized environment.
- 			[x86] noirqtime: Do not use TSC to do irq accounting.
- 			Used to run time disable IRQ_TIME_ACCOUNTING on any
- 			platforms where RDTSC is slow and this accounting
- 			can add overhead.
  
  	turbografx.map[2|3]=	[HW,JOY]
  			TurboGraFX parallel port interface
--- 2671,2676 ----
diff -cBr 2.6.35/Documentation/power/interface.txt linux-2.6.35.y-512ac85/Documentation/power/interface.txt
*** 2.6.35/Documentation/power/interface.txt	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/Documentation/power/interface.txt	2010-11-22 14:01:26.000000000 -0500
***************
*** 57,63 ****
  suspend image will be as small as possible.
  
  Reading from this file will display the current image size limit, which
! is set to 2/5 of available RAM by default.
  
  /sys/power/pm_trace controls the code which saves the last PM event point in
  the RTC across reboots, so that you can debug a machine that just hangs
--- 57,63 ----
  suspend image will be as small as possible.
  
  Reading from this file will display the current image size limit, which
! is set to 500 MB by default.
  
  /sys/power/pm_trace controls the code which saves the last PM event point in
  the RTC across reboots, so that you can debug a machine that just hangs
diff -cBr 2.6.35/Documentation/power/runtime_pm.txt linux-2.6.35.y-512ac85/Documentation/power/runtime_pm.txt
*** 2.6.35/Documentation/power/runtime_pm.txt	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/Documentation/power/runtime_pm.txt	2010-11-22 14:01:26.000000000 -0500
***************
*** 336,343 ****
        zero)
  
    bool pm_runtime_suspended(struct device *dev);
!     - return true if the device's runtime PM status is 'suspended' and its
!       'power.disable_depth' field is equal to zero, or false otherwise
  
    void pm_runtime_allow(struct device *dev);
      - set the power.runtime_auto flag for the device and decrease its usage
--- 336,343 ----
        zero)
  
    bool pm_runtime_suspended(struct device *dev);
!     - return true if the device's runtime PM status is 'suspended', or false
!       otherwise
  
    void pm_runtime_allow(struct device *dev);
      - set the power.runtime_auto flag for the device and decrease its usage
diff -cBr 2.6.35/drivers/acpi/acpica/dswexec.c linux-2.6.35.y-512ac85/drivers/acpi/acpica/dswexec.c
*** 2.6.35/drivers/acpi/acpica/dswexec.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/drivers/acpi/acpica/dswexec.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 300,324 ****
  			 * we must enter this object into the namespace.  The created
  			 * object is temporary and will be deleted upon completion of
  			 * the execution of this method.
- 			 *
- 			 * Note 10/2010: Except for the Scope() op. This opcode does
- 			 * not actually create a new object, it refers to an existing
- 			 * object. However, for Scope(), we want to indeed open a
- 			 * new scope.
  			 */
! 			if (op->common.aml_opcode != AML_SCOPE_OP) {
! 				status =
! 				    acpi_ds_load2_begin_op(walk_state, NULL);
! 			} else {
! 				status =
! 				    acpi_ds_scope_stack_push(op->named.node,
! 							     op->named.node->
! 							     type, walk_state);
! 				if (ACPI_FAILURE(status)) {
! 					return_ACPI_STATUS(status);
! 				}
! 			}
  		}
  		break;
  
  	case AML_CLASS_EXECUTE:
--- 300,309 ----
  			 * we must enter this object into the namespace.  The created
  			 * object is temporary and will be deleted upon completion of
  			 * the execution of this method.
  			 */
! 			status = acpi_ds_load2_begin_op(walk_state, NULL);
  		}
+ 
  		break;
  
  	case AML_CLASS_EXECUTE:
diff -cBr 2.6.35/drivers/acpi/battery.c linux-2.6.35.y-512ac85/drivers/acpi/battery.c
*** 2.6.35/drivers/acpi/battery.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/drivers/acpi/battery.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 98,104 ****
  	 * due to bad math.
  	 */
  	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
- 	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,
  };
  
  struct acpi_battery {
--- 98,103 ----
***************
*** 414,421 ****
  		result = extract_package(battery, buffer.pointer,
  				info_offsets, ARRAY_SIZE(info_offsets));
  	kfree(buffer.pointer);
- 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
- 		battery->full_charge_capacity = battery->design_capacity;
  	return result;
  }
  
--- 413,418 ----
***************
*** 452,461 ****
  	    battery->rate_now != -1)
  		battery->rate_now = abs((s16)battery->rate_now);
  
- 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
- 	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
- 		battery->capacity_now = (battery->capacity_now *
- 				battery->full_charge_capacity) / 100;
  	return result;
  }
  
--- 449,454 ----
***************
*** 569,601 ****
  	}
  }
  
- /*
-  * According to the ACPI spec, some kinds of primary batteries can
-  * report percentage battery remaining capacity directly to OS.
-  * In this case, it reports the Last Full Charged Capacity == 100
-  * and BatteryPresentRate == 0xFFFFFFFF.
-  *
-  * Now we found some battery reports percentage remaining capacity
-  * even if it's rechargeable.
-  * https://bugzilla.kernel.org/show_bug.cgi?id=15979
-  *
-  * Handle this correctly so that they won't break userspace.
-  */
- static void acpi_battery_quirks2(struct acpi_battery *battery)
- {
- 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
- 		return ;
- 
-         if (battery->full_charge_capacity == 100 &&
-             battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&
-             battery->capacity_now >=0 && battery->capacity_now <= 100) {
- 		set_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags);
- 		battery->full_charge_capacity = battery->design_capacity;
- 		battery->capacity_now = (battery->capacity_now *
- 				battery->full_charge_capacity) / 100;
- 	}
- }
- 
  static int acpi_battery_update(struct acpi_battery *battery)
  {
  	int result, old_present = acpi_battery_present(battery);
--- 562,567 ----
***************
*** 621,629 ****
  	if (!battery->bat.dev)
  		sysfs_add_battery(battery);
  #endif
! 	result = acpi_battery_get_state(battery);
! 	acpi_battery_quirks2(battery);
! 	return result;
  }
  
  /* --------------------------------------------------------------------------
--- 587,593 ----
  	if (!battery->bat.dev)
  		sysfs_add_battery(battery);
  #endif
! 	return acpi_battery_get_state(battery);
  }
  
  /* --------------------------------------------------------------------------
diff -cBr 2.6.35/drivers/acpi/debug.c linux-2.6.35.y-512ac85/drivers/acpi/debug.c
*** 2.6.35/drivers/acpi/debug.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/drivers/acpi/debug.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 258,264 ****
  	if (!acpi_dir)
  		goto err;
  
! 	cm_dentry = debugfs_create_file("custom_method", S_IWUSR,
  					acpi_dir, NULL, &cm_fops);
  	if (!cm_dentry)
  		goto err;
--- 258,264 ----
  	if (!acpi_dir)
  		goto err;
  
! 	cm_dentry = debugfs_create_file("custom_method", S_IWUGO,
  					acpi_dir, NULL, &cm_fops);
  	if (!cm_dentry)
  		goto err;
diff -cBr 2.6.35/drivers/acpi/ec.c linux-2.6.35.y-512ac85/drivers/acpi/ec.c
*** 2.6.35/drivers/acpi/ec.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/drivers/acpi/ec.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1006,1014 ****
  	ec_flag_msi, "MSI hardware", {
  	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-Star")}, NULL},
  	{
- 	ec_flag_msi, "MSI hardware", {
- 	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-STAR")}, NULL},
- 	{
  	ec_validate_ecdt, "ASUS hardware", {
  	DMI_MATCH(DMI_BIOS_VENDOR, "ASUS") }, NULL},
  	{},
--- 1006,1011 ----
diff -cBr 2.6.35/drivers/ata/ahci.c linux-2.6.35.y-512ac85/drivers/ata/ahci.c
*** 2.6.35/drivers/ata/ahci.c	2011-05-07 19:57:18.306750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/ahci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 248,258 ****
  	{ PCI_VDEVICE(INTEL, 0x1c05), board_ahci }, /* CPT RAID */
  	{ PCI_VDEVICE(INTEL, 0x1c06), board_ahci }, /* CPT RAID */
  	{ PCI_VDEVICE(INTEL, 0x1c07), board_ahci }, /* CPT RAID */
- 	{ PCI_VDEVICE(INTEL, 0x1d02), board_ahci }, /* PBG AHCI */
- 	{ PCI_VDEVICE(INTEL, 0x1d04), board_ahci }, /* PBG RAID */
- 	{ PCI_VDEVICE(INTEL, 0x1d06), board_ahci }, /* PBG RAID */
- 	{ PCI_VDEVICE(INTEL, 0x2826), board_ahci }, /* PBG RAID */
- 	{ PCI_VDEVICE(INTEL, 0x2323), board_ahci }, /* DH89xxCC AHCI */
  
  	/* JMicron 360/1/3/5/6, match class to avoid IDE function */
  	{ PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
--- 248,253 ----
diff -cBr 2.6.35/drivers/ata/libata-core.c linux-2.6.35.y-512ac85/drivers/ata/libata-core.c
*** 2.6.35/drivers/ata/libata-core.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/libata-core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 4946,4951 ****
--- 4946,4954 ----
  {
  	struct ata_device *dev = qc->dev;
  
+ 	if (ata_tag_internal(qc->tag))
+ 		return;
+ 
  	if (ata_is_nodata(qc->tf.protocol))
  		return;
  
***************
*** 4989,5011 ****
  		if (unlikely(qc->err_mask))
  			qc->flags |= ATA_QCFLAG_FAILED;
  
- 		/*
- 		 * Finish internal commands without any further processing
- 		 * and always with the result TF filled.
- 		 */
- 		if (unlikely(ata_tag_internal(qc->tag))) {
- 			fill_result_tf(qc);
- 			__ata_qc_complete(qc);
- 			return;
- 		}
- 
- 		/*
- 		 * Non-internal qc has failed.  Fill the result TF and
- 		 * summon EH.
- 		 */
  		if (unlikely(qc->flags & ATA_QCFLAG_FAILED)) {
  			fill_result_tf(qc);
! 			ata_qc_schedule_eh(qc);
  			return;
  		}
  
--- 4992,5005 ----
  		if (unlikely(qc->err_mask))
  			qc->flags |= ATA_QCFLAG_FAILED;
  
  		if (unlikely(qc->flags & ATA_QCFLAG_FAILED)) {
+ 			/* always fill result TF for failed qc */
  			fill_result_tf(qc);
! 
! 			if (!ata_tag_internal(qc->tag))
! 				ata_qc_schedule_eh(qc);
! 			else
! 				__ata_qc_complete(qc);
  			return;
  		}
  
diff -cBr 2.6.35/drivers/ata/libata-scsi.c linux-2.6.35.y-512ac85/drivers/ata/libata-scsi.c
*** 2.6.35/drivers/ata/libata-scsi.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/libata-scsi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2577,2587 ****
  		 *
  		 * If door lock fails, always clear sdev->locked to
  		 * avoid this infinite loop.
- 		 *
- 		 * This may happen before SCSI scan is complete.  Make
- 		 * sure qc->dev->sdev isn't NULL before dereferencing.
  		 */
! 		if (qc->cdb[0] == ALLOW_MEDIUM_REMOVAL && qc->dev->sdev)
  			qc->dev->sdev->locked = 0;
  
  		qc->scsicmd->result = SAM_STAT_CHECK_CONDITION;
--- 2577,2584 ----
  		 *
  		 * If door lock fails, always clear sdev->locked to
  		 * avoid this infinite loop.
  		 */
! 		if (qc->cdb[0] == ALLOW_MEDIUM_REMOVAL)
  			qc->dev->sdev->locked = 0;
  
  		qc->scsicmd->result = SAM_STAT_CHECK_CONDITION;
diff -cBr 2.6.35/drivers/ata/libata-sff.c linux-2.6.35.y-512ac85/drivers/ata/libata-sff.c
*** 2.6.35/drivers/ata/libata-sff.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/libata-sff.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1515,1524 ****
  		if (!(qc->dev->flags & ATA_DFLAG_CDB_INTR))
  			return ata_sff_idle_irq(ap);
  		break;
! 	case HSM_ST_IDLE:
! 		return ata_sff_idle_irq(ap);
! 	default:
  		break;
  	}
  
  	/* check main status, clearing INTRQ if needed */
--- 1515,1525 ----
  		if (!(qc->dev->flags & ATA_DFLAG_CDB_INTR))
  			return ata_sff_idle_irq(ap);
  		break;
! 	case HSM_ST:
! 	case HSM_ST_LAST:
  		break;
+ 	default:
+ 		return ata_sff_idle_irq(ap);
  	}
  
  	/* check main status, clearing INTRQ if needed */
diff -cBr 2.6.35/drivers/ata/pata_mpc52xx.c linux-2.6.35.y-512ac85/drivers/ata/pata_mpc52xx.c
*** 2.6.35/drivers/ata/pata_mpc52xx.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/pata_mpc52xx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 610,616 ****
  };
  
  static struct ata_port_operations mpc52xx_ata_port_ops = {
! 	.inherits		= &ata_bmdma_port_ops,
  	.sff_dev_select		= mpc52xx_ata_dev_select,
  	.set_piomode		= mpc52xx_ata_set_piomode,
  	.set_dmamode		= mpc52xx_ata_set_dmamode,
--- 610,616 ----
  };
  
  static struct ata_port_operations mpc52xx_ata_port_ops = {
! 	.inherits		= &ata_sff_port_ops,
  	.sff_dev_select		= mpc52xx_ata_dev_select,
  	.set_piomode		= mpc52xx_ata_set_piomode,
  	.set_dmamode		= mpc52xx_ata_set_dmamode,
diff -cBr 2.6.35/drivers/ata/sata_via.c linux-2.6.35.y-512ac85/drivers/ata/sata_via.c
*** 2.6.35/drivers/ata/sata_via.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ata/sata_via.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 538,544 ****
  	return 0;
  }
  
! static void svia_configure(struct pci_dev *pdev, int board_id)
  {
  	u8 tmp8;
  
--- 538,544 ----
  	return 0;
  }
  
! static void svia_configure(struct pci_dev *pdev)
  {
  	u8 tmp8;
  
***************
*** 577,583 ****
  	}
  
  	/*
! 	 * vt6420/1 has problems talking to some drives.  The following
  	 * is the fix from Joseph Chan <JosephChan@via.com.tw>.
  	 *
  	 * When host issues HOLD, device may send up to 20DW of data
--- 577,583 ----
  	}
  
  	/*
! 	 * vt6421 has problems talking to some drives.  The following
  	 * is the fix from Joseph Chan <JosephChan@via.com.tw>.
  	 *
  	 * When host issues HOLD, device may send up to 20DW of data
***************
*** 596,604 ****
  	 *
  	 * https://bugzilla.kernel.org/show_bug.cgi?id=15173
  	 * http://article.gmane.org/gmane.linux.ide/46352
- 	 * http://thread.gmane.org/gmane.linux.kernel/1062139
  	 */
! 	if (board_id == vt6420 || board_id == vt6421) {
  		pci_read_config_byte(pdev, 0x52, &tmp8);
  		tmp8 |= 1 << 2;
  		pci_write_config_byte(pdev, 0x52, tmp8);
--- 596,603 ----
  	 *
  	 * https://bugzilla.kernel.org/show_bug.cgi?id=15173
  	 * http://article.gmane.org/gmane.linux.ide/46352
  	 */
! 	if (pdev->device == 0x3249) {
  		pci_read_config_byte(pdev, 0x52, &tmp8);
  		tmp8 |= 1 << 2;
  		pci_write_config_byte(pdev, 0x52, tmp8);
***************
*** 653,659 ****
  	if (rc)
  		return rc;
  
! 	svia_configure(pdev, board_id);
  
  	pci_set_master(pdev);
  	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
--- 652,658 ----
  	if (rc)
  		return rc;
  
! 	svia_configure(pdev);
  
  	pci_set_master(pdev);
  	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
diff -cBr 2.6.35/drivers/atm/solos-pci.c linux-2.6.35.y-512ac85/drivers/atm/solos-pci.c
*** 2.6.35/drivers/atm/solos-pci.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/atm/solos-pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 695,701 ****
  					      size);
  			}
  			if (atmdebug) {
! 				dev_info(&card->dev->dev, "Received: port %d\n", port);
  				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
  					 size, le16_to_cpu(header->vpi),
  					 le16_to_cpu(header->vci));
--- 695,701 ----
  					      size);
  			}
  			if (atmdebug) {
! 				dev_info(&card->dev->dev, "Received: device %d\n", port);
  				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
  					 size, le16_to_cpu(header->vpi),
  					 le16_to_cpu(header->vci));
***************
*** 1015,1029 ****
  
  			/* Clean up and free oldskb now it's gone */
  			if (atmdebug) {
- 				struct pkt_hdr *header = (void *)oldskb->data;
- 				int size = le16_to_cpu(header->size);
- 
- 				skb_pull(oldskb, sizeof(*header));
  				dev_info(&card->dev->dev, "Transmitted: port %d\n",
  					 port);
- 				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
- 					 size, le16_to_cpu(header->vpi),
- 					 le16_to_cpu(header->vci));
  				print_buffer(oldskb);
  			}
  
--- 1015,1022 ----
diff -cBr 2.6.35/drivers/block/cciss.h linux-2.6.35.y-512ac85/drivers/block/cciss.h
*** 2.6.35/drivers/block/cciss.h	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/block/cciss.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 173,179 ****
  	 printk("Sending %x - down to controller\n", c->busaddr );
  #endif /* CCISS_DEBUG */ 
           writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
- 	readl(h->vaddr + SA5_REQUEST_PORT_OFFSET);
  	 h->commands_outstanding++;
  	 if ( h->commands_outstanding > h->max_outstanding)
  		h->max_outstanding = h->commands_outstanding;
--- 173,178 ----
diff -cBr 2.6.35/drivers/block/pktcdvd.c linux-2.6.35.y-512ac85/drivers/block/pktcdvd.c
*** 2.6.35/drivers/block/pktcdvd.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/block/pktcdvd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2368,2374 ****
  	pkt_shrink_pktlist(pd);
  }
  
! static struct pktcdvd_device *pkt_find_dev_from_minor(unsigned int dev_minor)
  {
  	if (dev_minor >= MAX_WRITERS)
  		return NULL;
--- 2368,2374 ----
  	pkt_shrink_pktlist(pd);
  }
  
! static struct pktcdvd_device *pkt_find_dev_from_minor(int dev_minor)
  {
  	if (dev_minor >= MAX_WRITERS)
  		return NULL;
diff -cBr 2.6.35/drivers/block/xen-blkfront.c linux-2.6.35.y-512ac85/drivers/block/xen-blkfront.c
*** 2.6.35/drivers/block/xen-blkfront.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/block/xen-blkfront.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 69,75 ****
  
  static const struct block_device_operations xlvbd_block_fops;
  
! #define BLK_RING_SIZE __CONST_RING_SIZE(blkif, PAGE_SIZE)
  
  /*
   * We have one of these per vbd, whether ide, scsi or 'other'.  They
--- 69,75 ----
  
  static const struct block_device_operations xlvbd_block_fops;
  
! #define BLK_RING_SIZE __RING_SIZE((struct blkif_sring *)0, PAGE_SIZE)
  
  /*
   * We have one of these per vbd, whether ide, scsi or 'other'.  They
diff -cBr 2.6.35/drivers/bluetooth/btusb.c linux-2.6.35.y-512ac85/drivers/bluetooth/btusb.c
*** 2.6.35/drivers/bluetooth/btusb.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/bluetooth/btusb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 62,70 ****
  	/* Apple iMac11,1 */
  	{ USB_DEVICE(0x05ac, 0x8215) },
  
- 	/* Apple MacBookPro8,2 */
- 	{ USB_DEVICE(0x05ac, 0x821a) },
- 
  	/* AVM BlueFRITZ! USB v2.0 */
  	{ USB_DEVICE(0x057c, 0x3800) },
  
--- 62,67 ----
diff -cBr 2.6.35/drivers/char/agp/intel-agp.c linux-2.6.35.y-512ac85/drivers/char/agp/intel-agp.c
*** 2.6.35/drivers/char/agp/intel-agp.c	2011-05-07 19:57:18.326750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/agp/intel-agp.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1048,1054 ****
  	ID(PCI_DEVICE_ID_INTEL_G45_HB),
  	ID(PCI_DEVICE_ID_INTEL_G41_HB),
  	ID(PCI_DEVICE_ID_INTEL_B43_HB),
- 	ID(PCI_DEVICE_ID_INTEL_B43_1_HB),
  	ID(PCI_DEVICE_ID_INTEL_IRONLAKE_D_HB),
  	ID(PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB),
  	ID(PCI_DEVICE_ID_INTEL_IRONLAKE_MA_HB),
--- 1048,1053 ----
diff -cBr 2.6.35/drivers/char/agp/intel-gtt.c linux-2.6.35.y-512ac85/drivers/char/agp/intel-gtt.c
*** 2.6.35/drivers/char/agp/intel-gtt.c	2011-05-07 19:57:18.336750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/agp/intel-gtt.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 531,537 ****
  
  	pci_read_config_word(agp_bridge->dev, I830_GMCH_CTRL, &gmch_ctrl);
  
! 	if (IS_G33 || IS_I965) {
  		u32 pgetbl_ctl;
  		pgetbl_ctl = readl(intel_private.registers+I810_PGETBL_CTL);
  
--- 531,537 ----
  
  	pci_read_config_word(agp_bridge->dev, I830_GMCH_CTRL, &gmch_ctrl);
  
! 	if (IS_I965) {
  		u32 pgetbl_ctl;
  		pgetbl_ctl = readl(intel_private.registers+I810_PGETBL_CTL);
  
***************
*** 564,569 ****
--- 564,585 ----
  			size = 512;
  		}
  		size += 4; /* add in BIOS popup space */
+ 	} else if (IS_G33 && !IS_PINEVIEW) {
+ 	/* G33's GTT size defined in gmch_ctrl */
+ 		switch (gmch_ctrl & G33_PGETBL_SIZE_MASK) {
+ 		case G33_PGETBL_SIZE_1M:
+ 			size = 1024;
+ 			break;
+ 		case G33_PGETBL_SIZE_2M:
+ 			size = 2048;
+ 			break;
+ 		default:
+ 			dev_info(&agp_bridge->dev->dev,
+ 				 "unknown page table size 0x%x, assuming 512KB\n",
+ 				(gmch_ctrl & G33_PGETBL_SIZE_MASK));
+ 			size = 512;
+ 		}
+ 		size += 4;
  	} else if (IS_G4X || IS_PINEVIEW) {
  		/* On 4 series hardware, GTT stolen is separate from graphics
  		 * stolen, ignore it in stolen gtt entries counting.  However,
***************
*** 1234,1264 ****
  	int size;
  
  	if (IS_G33) {
! 		u32 pgetbl_ctl;
! 		pgetbl_ctl = readl(intel_private.registers+I810_PGETBL_CTL);
  
! 		switch (pgetbl_ctl & I965_PGETBL_SIZE_MASK) {
! 		case I965_PGETBL_SIZE_128KB:
! 			size = 128;
! 			break;
! 		case I965_PGETBL_SIZE_256KB:
! 			size = 256;
! 			break;
! 		case I965_PGETBL_SIZE_512KB:
  			size = 512;
  			break;
! 		case I965_PGETBL_SIZE_1MB:
  			size = 1024;
  			break;
! 		case I965_PGETBL_SIZE_2MB:
! 			size = 2048;
! 			break;
! 		case I965_PGETBL_SIZE_1_5MB:
! 			size = 1024 + 512;
  			break;
  		default:
! 			dev_info(&intel_private.pcidev->dev,
! 				 "unknown page table size, assuming 512KB\n");
  			size = 512;
  		}
  	} else {
--- 1250,1273 ----
  	int size;
  
  	if (IS_G33) {
! 		u16 gmch_ctrl;
  
! 		/* G33's GTT size defined in gmch_ctrl */
! 		pci_read_config_word(agp_bridge->dev, I830_GMCH_CTRL, &gmch_ctrl);
! 		switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
! 		case I830_GMCH_GMS_STOLEN_512:
  			size = 512;
  			break;
! 		case I830_GMCH_GMS_STOLEN_1024:
  			size = 1024;
  			break;
! 		case I830_GMCH_GMS_STOLEN_8192:
! 			size = 8*1024;
  			break;
  		default:
! 			dev_info(&agp_bridge->dev->dev,
! 				 "unknown page table size 0x%x, assuming 512KB\n",
! 				(gmch_ctrl & I830_GMCH_GMS_MASK));
  			size = 512;
  		}
  	} else {
***************
*** 1290,1303 ****
  	pci_read_config_dword(intel_private.pcidev, I915_MMADDR, &temp);
  	pci_read_config_dword(intel_private.pcidev, I915_PTEADDR, &temp2);
  
- 	temp &= 0xfff80000;
- 
- 	intel_private.registers = ioremap(temp, 128 * 4096);
- 	if (!intel_private.registers) {
- 		iounmap(intel_private.gtt);
- 		return -ENOMEM;
- 	}
- 
  	gtt_map_size = intel_i915_get_gtt_size();
  
  	intel_private.gtt = ioremap(temp2, gtt_map_size);
--- 1299,1304 ----
***************
*** 1306,1311 ****
--- 1307,1320 ----
  
  	intel_private.gtt_total_size = gtt_map_size / 4;
  
+ 	temp &= 0xfff80000;
+ 
+ 	intel_private.registers = ioremap(temp, 128 * 4096);
+ 	if (!intel_private.registers) {
+ 		iounmap(intel_private.gtt);
+ 		return -ENOMEM;
+ 	}
+ 
  	temp = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
  	global_cache_flush();	/* FIXME: ? */
  
Only in 2.6.35/drivers/char: dcc_tty.c
diff -cBr 2.6.35/drivers/char/hpet.c linux-2.6.35.y-512ac85/drivers/char/hpet.c
*** 2.6.35/drivers/char/hpet.c	2011-05-07 19:57:18.336750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/hpet.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 479,499 ****
  	if (irq) {
  		unsigned long irq_flags;
  
- 		if (devp->hd_flags & HPET_SHARED_IRQ) {
- 			/*
- 			 * To prevent the interrupt handler from seeing an
- 			 * unwanted interrupt status bit, program the timer
- 			 * so that it will not fire in the near future ...
- 			 */
- 			writel(readl(&timer->hpet_config) & ~Tn_TYPE_CNF_MASK,
- 			       &timer->hpet_config);
- 			write_counter(read_counter(&hpet->hpet_mc),
- 				      &timer->hpet_compare);
- 			/* ... and clear any left-over status. */
- 			isr = 1 << (devp - devp->hd_hpets->hp_dev);
- 			writel(isr, &hpet->hpet_isr);
- 		}
- 
  		sprintf(devp->hd_name, "hpet%d", (int)(devp - hpetp->hp_dev));
  		irq_flags = devp->hd_flags & HPET_SHARED_IRQ
  						? IRQF_SHARED : IRQF_DISABLED;
--- 479,484 ----
***************
*** 985,992 ****
  		return -ENODEV;
  
  	if (!data.hd_address || !data.hd_nirqs) {
- 		if (data.hd_address)
- 			iounmap(data.hd_address);
  		printk("%s: no address or irqs in _CRS\n", __func__);
  		return -ENODEV;
  	}
--- 970,975 ----
diff -cBr 2.6.35/drivers/char/ipmi/ipmi_si_intf.c linux-2.6.35.y-512ac85/drivers/char/ipmi/ipmi_si_intf.c
*** 2.6.35/drivers/char/ipmi/ipmi_si_intf.c	2011-05-07 19:57:18.336750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/ipmi/ipmi_si_intf.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1662,1678 ****
  	return 0;
  }
  
- static struct smi_info *smi_info_alloc(void)
- {
- 	struct smi_info *info = kzalloc(sizeof(*info), GFP_KERNEL);
- 
- 	if (info) {
- 		spin_lock_init(&info->si_lock);
- 		spin_lock_init(&info->msg_lock);
- 	}
- 	return info;
- }
- 
  static int hotmod_handler(const char *val, struct kernel_param *kp)
  {
  	char *str = kstrdup(val, GFP_KERNEL);
--- 1662,1667 ----
***************
*** 1787,1793 ****
  		}
  
  		if (op == HM_ADD) {
! 			info = smi_info_alloc();
  			if (!info) {
  				rv = -ENOMEM;
  				goto out;
--- 1776,1782 ----
  		}
  
  		if (op == HM_ADD) {
! 			info = kzalloc(sizeof(*info), GFP_KERNEL);
  			if (!info) {
  				rv = -ENOMEM;
  				goto out;
***************
*** 1849,1855 ****
  		if (!ports[i] && !addrs[i])
  			continue;
  
! 		info = smi_info_alloc();
  		if (!info)
  			return;
  
--- 1838,1844 ----
  		if (!ports[i] && !addrs[i])
  			continue;
  
! 		info = kzalloc(sizeof(*info), GFP_KERNEL);
  		if (!info)
  			return;
  
***************
*** 2036,2042 ****
  	else
  		addr_space = IPMI_IO_ADDR_SPACE;
  
! 	info = smi_info_alloc();
  	if (!info) {
  		printk(KERN_ERR PFX "Could not allocate SI data (3)\n");
  		return -ENOMEM;
--- 2025,2031 ----
  	else
  		addr_space = IPMI_IO_ADDR_SPACE;
  
! 	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info) {
  		printk(KERN_ERR PFX "Could not allocate SI data (3)\n");
  		return -ENOMEM;
***************
*** 2140,2146 ****
  	if (!acpi_dev)
  		return -ENODEV;
  
! 	info = smi_info_alloc();
  	if (!info)
  		return -ENOMEM;
  
--- 2129,2135 ----
  	if (!acpi_dev)
  		return -ENODEV;
  
! 	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info)
  		return -ENOMEM;
  
***************
*** 2318,2324 ****
  {
  	struct smi_info *info;
  
! 	info = smi_info_alloc();
  	if (!info) {
  		printk(KERN_ERR PFX "Could not allocate SI data\n");
  		return;
--- 2307,2313 ----
  {
  	struct smi_info *info;
  
! 	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info) {
  		printk(KERN_ERR PFX "Could not allocate SI data\n");
  		return;
***************
*** 2419,2425 ****
  	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
  	struct smi_info *info;
  
! 	info = smi_info_alloc();
  	if (!info)
  		return -ENOMEM;
  
--- 2408,2414 ----
  	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
  	struct smi_info *info;
  
! 	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info)
  		return -ENOMEM;
  
***************
*** 2557,2563 ****
  		return -EINVAL;
  	}
  
! 	info = smi_info_alloc();
  
  	if (!info) {
  		dev_err(&dev->dev,
--- 2546,2552 ----
  		return -EINVAL;
  	}
  
! 	info = kzalloc(sizeof(*info), GFP_KERNEL);
  
  	if (!info) {
  		dev_err(&dev->dev,
***************
*** 2999,3005 ****
  		if (check_legacy_ioport(ipmi_defaults[i].port))
  			continue;
  #endif
! 		info = smi_info_alloc();
  		if (!info)
  			return;
  
--- 2988,2994 ----
  		if (check_legacy_ioport(ipmi_defaults[i].port))
  			continue;
  #endif
! 		info = kzalloc(sizeof(*info), GFP_KERNEL);
  		if (!info)
  			return;
  
***************
*** 3122,3127 ****
--- 3111,3119 ----
  		goto out_err;
  	}
  
+ 	spin_lock_init(&(new_smi->si_lock));
+ 	spin_lock_init(&(new_smi->msg_lock));
+ 
  	/* Do low-level detection first. */
  	if (new_smi->handlers->detect(new_smi->si_sm)) {
  		if (new_smi->addr_source)
diff -cBr 2.6.35/drivers/char/n_gsm.c linux-2.6.35.y-512ac85/drivers/char/n_gsm.c
*** 2.6.35/drivers/char/n_gsm.c	2011-05-07 19:57:18.336750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/n_gsm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 717,724 ****
  		if (msg->len < 128)
  			*--dp = (msg->len << 1) | EA;
  		else {
! 			*--dp = (msg->len >> 7);	/* bits 7 - 15 */
! 			*--dp = (msg->len & 127) << 1;	/* bits 0 - 6 */
  		}
  	}
  
--- 717,724 ----
  		if (msg->len < 128)
  			*--dp = (msg->len << 1) | EA;
  		else {
! 			*--dp = (msg->len >> 6) | EA;
! 			*--dp = (msg->len & 127) << 1;
  		}
  	}
  
***************
*** 969,976 ****
  {
  	struct gsm_msg *msg;
  	msg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->ftype);
- 	if (msg == NULL)
- 		return;
  	msg->data[0] = (cmd & 0xFE) << 1 | EA;	/* Clear C/R */
  	msg->data[1] = (dlen << 1) | EA;
  	memcpy(msg->data + 2, data, dlen);
--- 969,974 ----
diff -cBr 2.6.35/drivers/char/ramoops.c linux-2.6.35.y-512ac85/drivers/char/ramoops.c
*** 2.6.35/drivers/char/ramoops.c	2011-05-07 19:57:18.336750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/ramoops.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 27,32 ****
--- 27,33 ----
  #include <linux/ioport.h>
  
  #define RAMOOPS_KERNMSG_HDR "===="
+ #define RAMOOPS_HEADER_SIZE   (5 + sizeof(struct timeval))
  
  #define RECORD_SIZE 4096
  
***************
*** 62,69 ****
  			struct ramoops_context, dump);
  	unsigned long s1_start, s2_start;
  	unsigned long l1_cpy, l2_cpy;
! 	int res, hdr_size;
! 	char *buf, *buf_orig;
  	struct timeval timestamp;
  
  	/* Only dump oopses if dump_oops is set */
--- 63,70 ----
  			struct ramoops_context, dump);
  	unsigned long s1_start, s2_start;
  	unsigned long l1_cpy, l2_cpy;
! 	int res;
! 	char *buf;
  	struct timeval timestamp;
  
  	/* Only dump oopses if dump_oops is set */
***************
*** 71,78 ****
  		return;
  
  	buf = (char *)(cxt->virt_addr + (cxt->count * RECORD_SIZE));
- 	buf_orig = buf;
- 
  	memset(buf, '\0', RECORD_SIZE);
  	res = sprintf(buf, "%s", RAMOOPS_KERNMSG_HDR);
  	buf += res;
--- 72,77 ----
***************
*** 80,88 ****
  	res = sprintf(buf, "%lu.%lu\n", (long)timestamp.tv_sec, (long)timestamp.tv_usec);
  	buf += res;
  
! 	hdr_size = buf - buf_orig;
! 	l2_cpy = min(l2, (unsigned long)(RECORD_SIZE - hdr_size));
! 	l1_cpy = min(l1, (unsigned long)(RECORD_SIZE - hdr_size) - l2_cpy);
  
  	s2_start = l2 - l2_cpy;
  	s1_start = l1 - l1_cpy;
--- 79,86 ----
  	res = sprintf(buf, "%lu.%lu\n", (long)timestamp.tv_sec, (long)timestamp.tv_usec);
  	buf += res;
  
! 	l2_cpy = min(l2, (unsigned long)(RECORD_SIZE - RAMOOPS_HEADER_SIZE));
! 	l1_cpy = min(l1, (unsigned long)(RECORD_SIZE - RAMOOPS_HEADER_SIZE) - l2_cpy);
  
  	s2_start = l2 - l2_cpy;
  	s1_start = l1 - l1_cpy;
Only in 2.6.35/drivers/char: s3c_mem.c
Only in 2.6.35/drivers/char: s3c_mem.h
diff -cBr 2.6.35/drivers/char/tpm/tpm.c linux-2.6.35.y-512ac85/drivers/char/tpm/tpm.c
*** 2.6.35/drivers/char/tpm/tpm.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/tpm/tpm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 354,367 ****
  		    tpm_protected_ordinal_duration[ordinal &
  						   TPM_PROTECTED_ORDINAL_MASK];
  
! 	if (duration_idx != TPM_UNDEFINED) {
  		duration = chip->vendor.duration[duration_idx];
! 		/* if duration is 0, it's because chip->vendor.duration wasn't */
! 		/* filled yet, so we set the lowest timeout just to give enough */
! 		/* time for tpm_get_timeouts() to succeed */
! 		return (duration <= 0 ? HZ : duration);
! 	} else
  		return 2 * 60 * HZ;
  }
  EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);
  
--- 354,365 ----
  		    tpm_protected_ordinal_duration[ordinal &
  						   TPM_PROTECTED_ORDINAL_MASK];
  
! 	if (duration_idx != TPM_UNDEFINED)
  		duration = chip->vendor.duration[duration_idx];
! 	if (duration <= 0)
  		return 2 * 60 * HZ;
+ 	else
+ 		return duration;
  }
  EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);
  
***************
*** 567,577 ****
  	if (rc)
  		return;
  
! 	if (be32_to_cpu(tpm_cmd.header.out.return_code) != 0 ||
! 	    be32_to_cpu(tpm_cmd.header.out.length)
! 	    != sizeof(tpm_cmd.header.out) + sizeof(u32) + 3 * sizeof(u32))
  		return;
- 
  	duration_cap = &tpm_cmd.params.getcap_out.cap.duration;
  	chip->vendor.duration[TPM_SHORT] =
  	    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));
--- 565,573 ----
  	if (rc)
  		return;
  
! 	if (be32_to_cpu(tpm_cmd.header.out.return_code)
! 	    != 3 * sizeof(u32))
  		return;
  	duration_cap = &tpm_cmd.params.getcap_out.cap.duration;
  	chip->vendor.duration[TPM_SHORT] =
  	    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));
***************
*** 915,932 ****
  }
  EXPORT_SYMBOL_GPL(tpm_show_caps_1_2);
  
- ssize_t tpm_show_timeouts(struct device *dev, struct device_attribute *attr,
- 			  char *buf)
- {
- 	struct tpm_chip *chip = dev_get_drvdata(dev);
- 
- 	return sprintf(buf, "%d %d %d\n",
- 	               jiffies_to_usecs(chip->vendor.duration[TPM_SHORT]),
- 	               jiffies_to_usecs(chip->vendor.duration[TPM_MEDIUM]),
- 	               jiffies_to_usecs(chip->vendor.duration[TPM_LONG]));
- }
- EXPORT_SYMBOL_GPL(tpm_show_timeouts);
- 
  ssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,
  			const char *buf, size_t count)
  {
--- 911,916 ----
***************
*** 970,976 ****
  		return -EBUSY;
  	}
  
! 	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
  	if (chip->data_buffer == NULL) {
  		clear_bit(0, &chip->is_open);
  		put_device(chip->dev);
--- 954,960 ----
  		return -EBUSY;
  	}
  
! 	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
  	if (chip->data_buffer == NULL) {
  		clear_bit(0, &chip->is_open);
  		put_device(chip->dev);
diff -cBr 2.6.35/drivers/char/tpm/tpm.h linux-2.6.35.y-512ac85/drivers/char/tpm/tpm.h
*** 2.6.35/drivers/char/tpm/tpm.h	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/tpm/tpm.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 56,63 ****
  				char *);
  extern ssize_t tpm_show_temp_deactivated(struct device *,
  					 struct device_attribute *attr, char *);
- extern ssize_t tpm_show_timeouts(struct device *,
- 				 struct device_attribute *attr, char *);
  
  struct tpm_chip;
  
--- 56,61 ----
diff -cBr 2.6.35/drivers/char/tpm/tpm_tis.c linux-2.6.35.y-512ac85/drivers/char/tpm/tpm_tis.c
*** 2.6.35/drivers/char/tpm/tpm_tis.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/tpm/tpm_tis.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 355,361 ****
  		   NULL);
  static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps_1_2, NULL);
  static DEVICE_ATTR(cancel, S_IWUSR | S_IWGRP, NULL, tpm_store_cancel);
- static DEVICE_ATTR(timeouts, S_IRUGO, tpm_show_timeouts, NULL);
  
  static struct attribute *tis_attrs[] = {
  	&dev_attr_pubek.attr,
--- 355,360 ----
***************
*** 365,372 ****
  	&dev_attr_owned.attr,
  	&dev_attr_temp_deactivated.attr,
  	&dev_attr_caps.attr,
! 	&dev_attr_cancel.attr,
! 	&dev_attr_timeouts.attr, NULL,
  };
  
  static struct attribute_group tis_attr_grp = {
--- 364,370 ----
  	&dev_attr_owned.attr,
  	&dev_attr_temp_deactivated.attr,
  	&dev_attr_caps.attr,
! 	&dev_attr_cancel.attr, NULL,
  };
  
  static struct attribute_group tis_attr_grp = {
diff -cBr 2.6.35/drivers/char/tty_buffer.c linux-2.6.35.y-512ac85/drivers/char/tty_buffer.c
*** 2.6.35/drivers/char/tty_buffer.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/tty_buffer.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 413,420 ****
  	spin_lock_irqsave(&tty->buf.lock, flags);
  
  	if (!test_and_set_bit(TTY_FLUSHING, &tty->flags)) {
! 		struct tty_buffer *head, *tail = tty->buf.tail;
! 		int seen_tail = 0;
  		while ((head = tty->buf.head) != NULL) {
  			int count;
  			char *char_buf;
--- 413,419 ----
  	spin_lock_irqsave(&tty->buf.lock, flags);
  
  	if (!test_and_set_bit(TTY_FLUSHING, &tty->flags)) {
! 		struct tty_buffer *head;
  		while ((head = tty->buf.head) != NULL) {
  			int count;
  			char *char_buf;
***************
*** 424,438 ****
  			if (!count) {
  				if (head->next == NULL)
  					break;
- 				/*
- 				  There's a possibility tty might get new buffer
- 				  added during the unlock window below. We could
- 				  end up spinning in here forever hogging the CPU
- 				  completely. To avoid this let's have a rest each
- 				  time we processed the tail buffer.
- 				*/
- 				if (tail == head)
- 					seen_tail = 1;
  				tty->buf.head = head->next;
  				tty_buffer_free(tty, head);
  				continue;
--- 423,428 ----
***************
*** 442,448 ****
  			   line discipline as we want to empty the queue */
  			if (test_bit(TTY_FLUSHPENDING, &tty->flags))
  				break;
! 			if (!tty->receive_room || seen_tail) {
  				schedule_delayed_work(&tty->buf.work, 1);
  				break;
  			}
--- 432,438 ----
  			   line discipline as we want to empty the queue */
  			if (test_bit(TTY_FLUSHPENDING, &tty->flags))
  				break;
! 			if (!tty->receive_room) {
  				schedule_delayed_work(&tty->buf.work, 1);
  				break;
  			}
diff -cBr 2.6.35/drivers/char/tty_ldisc.c linux-2.6.35.y-512ac85/drivers/char/tty_ldisc.c
*** 2.6.35/drivers/char/tty_ldisc.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/tty_ldisc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 47,53 ****
  
  static DEFINE_SPINLOCK(tty_ldisc_lock);
  static DECLARE_WAIT_QUEUE_HEAD(tty_ldisc_wait);
- static DECLARE_WAIT_QUEUE_HEAD(tty_ldisc_idle);
  /* Line disc dispatch table */
  static struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];
  
--- 47,52 ----
***************
*** 84,90 ****
  		return;
  	}
  	local_irq_restore(flags);
- 	wake_up(&tty_ldisc_idle);
  }
  
  /**
--- 83,88 ----
***************
*** 452,459 ****
                  /* BKL here locks verus a hangup event */
  		lock_kernel();
  		ret = ld->ops->open(tty);
- 		if (ret)
- 			clear_bit(TTY_LDISC_OPEN, &tty->flags);
  		unlock_kernel();
  		return ret;
  	}
--- 450,455 ----
***************
*** 534,556 ****
  }
  
  /**
-  *	tty_ldisc_wait_idle	-	wait for the ldisc to become idle
-  *	@tty: tty to wait for
-  *
-  *	Wait for the line discipline to become idle. The discipline must
-  *	have been halted for this to guarantee it remains idle.
-  */
- static int tty_ldisc_wait_idle(struct tty_struct *tty)
- {
- 	int ret;
- 	ret = wait_event_interruptible_timeout(tty_ldisc_idle,
- 			atomic_read(&tty->ldisc->users) == 1, 5 * HZ);
- 	if (ret < 0)
- 		return ret;
- 	return ret > 0 ? 0 : -EBUSY;
- }
- 
- /**
   *	tty_set_ldisc		-	set line discipline
   *	@tty: the terminal to set
   *	@ldisc: the line discipline
--- 530,535 ----
***************
*** 653,669 ****
  
  	flush_scheduled_work();
  
- 	retval = tty_ldisc_wait_idle(tty);
- 
  	mutex_lock(&tty->ldisc_mutex);
  	lock_kernel();
- 
- 	/* handle wait idle failure locked */
- 	if (retval) {
- 		tty_ldisc_put(new_ldisc);
- 		goto enable;
- 	}
- 
  	if (test_bit(TTY_HUPPED, &tty->flags)) {
  		/* We were raced by the hangup method. It will have stomped
  		   the ldisc data and closed the ldisc down */
--- 632,639 ----
***************
*** 697,703 ****
  
  	tty_ldisc_put(o_ldisc);
  
- enable:
  	/*
  	 *	Allow ldisc referencing to occur again
  	 */
--- 667,672 ----
***************
*** 743,754 ****
   *	state closed
   */
  
! static int tty_ldisc_reinit(struct tty_struct *tty, int ldisc)
  {
! 	struct tty_ldisc *ld = tty_ldisc_get(ldisc);
! 
! 	if (IS_ERR(ld))
! 		return -1;
  
  	tty_ldisc_close(tty, tty->ldisc);
  	tty_ldisc_put(tty->ldisc);
--- 712,720 ----
   *	state closed
   */
  
! static void tty_ldisc_reinit(struct tty_struct *tty, int ldisc)
  {
! 	struct tty_ldisc *ld;
  
  	tty_ldisc_close(tty, tty->ldisc);
  	tty_ldisc_put(tty->ldisc);
***************
*** 756,765 ****
  	/*
  	 *	Switch the line discipline back
  	 */
  	tty_ldisc_assign(tty, ld);
  	tty_set_termios_ldisc(tty, ldisc);
- 
- 	return 0;
  }
  
  /**
--- 722,731 ----
  	/*
  	 *	Switch the line discipline back
  	 */
+ 	ld = tty_ldisc_get(ldisc);
+ 	BUG_ON(IS_ERR(ld));
  	tty_ldisc_assign(tty, ld);
  	tty_set_termios_ldisc(tty, ldisc);
  }
  
  /**
***************
*** 821,836 ****
  	   a FIXME */
  	if (tty->ldisc) {	/* Not yet closed */
  		if (reset == 0) {
! 
! 			if (!tty_ldisc_reinit(tty, tty->termios->c_line))
! 				err = tty_ldisc_open(tty, tty->ldisc);
! 			else
! 				err = 1;
  		}
  		/* If the re-open fails or we reset then go to N_TTY. The
  		   N_TTY open cannot fail */
  		if (reset || err) {
! 			BUG_ON(tty_ldisc_reinit(tty, N_TTY));
  			WARN_ON(tty_ldisc_open(tty, tty->ldisc));
  		}
  		tty_ldisc_enable(tty);
--- 787,799 ----
  	   a FIXME */
  	if (tty->ldisc) {	/* Not yet closed */
  		if (reset == 0) {
! 			tty_ldisc_reinit(tty, tty->termios->c_line);
! 			err = tty_ldisc_open(tty, tty->ldisc);
  		}
  		/* If the re-open fails or we reset then go to N_TTY. The
  		   N_TTY open cannot fail */
  		if (reset || err) {
! 			tty_ldisc_reinit(tty, N_TTY);
  			WARN_ON(tty_ldisc_open(tty, tty->ldisc));
  		}
  		tty_ldisc_enable(tty);
diff -cBr 2.6.35/drivers/char/vt_ioctl.c linux-2.6.35.y-512ac85/drivers/char/vt_ioctl.c
*** 2.6.35/drivers/char/vt_ioctl.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/char/vt_ioctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 503,509 ****
  	struct kbd_struct * kbd;
  	unsigned int console;
  	unsigned char ucval;
- 	unsigned int uival;
  	void __user *up = (void __user *)arg;
  	int i, perm;
  	int ret = 0;
--- 503,508 ----
***************
*** 658,664 ****
  		break;
  
  	case KDGETMODE:
! 		uival = vc->vc_mode;
  		goto setint;
  
  	case KDMAPDISP:
--- 657,663 ----
  		break;
  
  	case KDGETMODE:
! 		ucval = vc->vc_mode;
  		goto setint;
  
  	case KDMAPDISP:
***************
*** 696,702 ****
  		break;
  
  	case KDGKBMODE:
! 		uival = ((kbd->kbdmode == VC_RAW) ? K_RAW :
  				 (kbd->kbdmode == VC_MEDIUMRAW) ? K_MEDIUMRAW :
  				 (kbd->kbdmode == VC_UNICODE) ? K_UNICODE :
  				 K_XLATE);
--- 695,701 ----
  		break;
  
  	case KDGKBMODE:
! 		ucval = ((kbd->kbdmode == VC_RAW) ? K_RAW :
  				 (kbd->kbdmode == VC_MEDIUMRAW) ? K_MEDIUMRAW :
  				 (kbd->kbdmode == VC_UNICODE) ? K_UNICODE :
  				 K_XLATE);
***************
*** 718,726 ****
  		break;
  
  	case KDGKBMETA:
! 		uival = (vc_kbd_mode(kbd, VC_META) ? K_ESCPREFIX : K_METABIT);
  	setint:
! 		ret = put_user(uival, (int __user *)arg);
  		break;
  
  	case KDGETKEYCODE:
--- 717,725 ----
  		break;
  
  	case KDGKBMETA:
! 		ucval = (vc_kbd_mode(kbd, VC_META) ? K_ESCPREFIX : K_METABIT);
  	setint:
! 		ret = put_user(ucval, (int __user *)arg);
  		break;
  
  	case KDGETKEYCODE:
***************
*** 950,956 ****
  		for (i = 0; i < MAX_NR_CONSOLES; ++i)
  			if (! VT_IS_IN_USE(i))
  				break;
! 		uival = i < MAX_NR_CONSOLES ? (i+1) : -1;
  		goto setint;		 
  
  	/*
--- 949,955 ----
  		for (i = 0; i < MAX_NR_CONSOLES; ++i)
  			if (! VT_IS_IN_USE(i))
  				break;
! 		ucval = i < MAX_NR_CONSOLES ? (i+1) : -1;
  		goto setint;		 
  
  	/*
Only in 2.6.35/drivers/cpufreq: cpufreq_interactive.c
Only in 2.6.35/drivers/cpufreq: cpufreq_smartass.c
diff -cBr 2.6.35/drivers/crypto/padlock-aes.c linux-2.6.35.y-512ac85/drivers/crypto/padlock-aes.c
*** 2.6.35/drivers/crypto/padlock-aes.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/crypto/padlock-aes.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 286,292 ****
  	if (initial)
  		asm volatile (".byte 0xf3,0x0f,0xa7,0xd0"	/* rep xcryptcbc */
  			      : "+S" (input), "+D" (output), "+a" (iv)
! 			      : "d" (control_word), "b" (key), "c" (initial));
  
  	asm volatile (".byte 0xf3,0x0f,0xa7,0xd0"	/* rep xcryptcbc */
  		      : "+S" (input), "+D" (output), "+a" (iv)
--- 286,292 ----
  	if (initial)
  		asm volatile (".byte 0xf3,0x0f,0xa7,0xd0"	/* rep xcryptcbc */
  			      : "+S" (input), "+D" (output), "+a" (iv)
! 			      : "d" (control_word), "b" (key), "c" (count));
  
  	asm volatile (".byte 0xf3,0x0f,0xa7,0xd0"	/* rep xcryptcbc */
  		      : "+S" (input), "+D" (output), "+a" (iv)
diff -cBr 2.6.35/drivers/dma/mv_xor.c linux-2.6.35.y-512ac85/drivers/dma/mv_xor.c
*** 2.6.35/drivers/dma/mv_xor.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/dma/mv_xor.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 449,455 ****
  static void mv_xor_tasklet(unsigned long data)
  {
  	struct mv_xor_chan *chan = (struct mv_xor_chan *) data;
! 	mv_xor_slot_cleanup(chan);
  }
  
  static struct mv_xor_desc_slot *
--- 449,455 ----
  static void mv_xor_tasklet(unsigned long data)
  {
  	struct mv_xor_chan *chan = (struct mv_xor_chan *) data;
! 	__mv_xor_slot_cleanup(chan);
  }
  
  static struct mv_xor_desc_slot *
diff -cBr 2.6.35/drivers/edac/amd64_edac.c linux-2.6.35.y-512ac85/drivers/edac/amd64_edac.c
*** 2.6.35/drivers/edac/amd64_edac.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/edac/amd64_edac.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1567,1573 ****
  	debugf1("   HoleOffset=0x%x  HoleValid=0x%x IntlvSel=0x%x\n",
  			hole_off, hole_valid, intlv_sel);
  
! 	if (intlv_en &&
  	    (intlv_sel != ((sys_addr >> 12) & intlv_en)))
  		return -EINVAL;
  
--- 1567,1573 ----
  	debugf1("   HoleOffset=0x%x  HoleValid=0x%x IntlvSel=0x%x\n",
  			hole_off, hole_valid, intlv_sel);
  
! 	if (intlv_en ||
  	    (intlv_sel != ((sys_addr >> 12) & intlv_en)))
  		return -EINVAL;
  
diff -cBr 2.6.35/drivers/edac/edac_mc.c linux-2.6.35.y-512ac85/drivers/edac/edac_mc.c
*** 2.6.35/drivers/edac/edac_mc.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/edac/edac_mc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 575,590 ****
  		return NULL;
  	}
  
  	del_mc_from_global_list(mci);
  	mutex_unlock(&mem_ctls_mutex);
  
! 	/* flush workq processes */
  	edac_mc_workq_teardown(mci);
- 
- 	/* marking MCI offline */
- 	mci->op_state = OP_OFFLINE;
- 
- 	/* remove from sysfs */
  	edac_remove_sysfs_mci_device(mci);
  
  	edac_printk(KERN_INFO, EDAC_MC,
--- 575,588 ----
  		return NULL;
  	}
  
+ 	/* marking MCI offline */
+ 	mci->op_state = OP_OFFLINE;
+ 
  	del_mc_from_global_list(mci);
  	mutex_unlock(&mem_ctls_mutex);
  
! 	/* flush workq processes and remove sysfs */
  	edac_mc_workq_teardown(mci);
  	edac_remove_sysfs_mci_device(mci);
  
  	edac_printk(KERN_INFO, EDAC_MC,
diff -cBr 2.6.35/drivers/firewire/ohci.c linux-2.6.35.y-512ac85/drivers/firewire/ohci.c
*** 2.6.35/drivers/firewire/ohci.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/firewire/ohci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 684,690 ****
  	d = &ab->descriptor;
  
  	if (d->res_count == 0) {
! 		size_t size, size2, rest, pktsize, size3, offset;
  		dma_addr_t start_bus;
  		void *start;
  
--- 684,690 ----
  	d = &ab->descriptor;
  
  	if (d->res_count == 0) {
! 		size_t size, rest, offset;
  		dma_addr_t start_bus;
  		void *start;
  
***************
*** 695,755 ****
  		 */
  
  		offset = offsetof(struct ar_buffer, data);
! 		start = ab;
  		start_bus = le32_to_cpu(ab->descriptor.data_address) - offset;
- 		buffer = ab->data;
  
  		ab = ab->next;
  		d = &ab->descriptor;
! 		size = start + PAGE_SIZE - ctx->pointer;
! 		/* valid buffer data in the next page */
  		rest = le16_to_cpu(d->req_count) - le16_to_cpu(d->res_count);
- 		/* what actually fits in this page */
- 		size2 = min(rest, (size_t)PAGE_SIZE - offset - size);
  		memmove(buffer, ctx->pointer, size);
! 		memcpy(buffer + size, ab->data, size2);
! 
! 		while (size > 0) {
! 			void *next = handle_ar_packet(ctx, buffer);
! 			pktsize = next - buffer;
! 			if (pktsize >= size) {
! 				/*
! 				 * We have handled all the data that was
! 				 * originally in this page, so we can now
! 				 * continue in the next page.
! 				 */
! 				buffer = next;
! 				break;
! 			}
! 			/* move the next packet to the start of the buffer */
! 			memmove(buffer, next, size + size2 - pktsize);
! 			size -= pktsize;
! 			/* fill up this page again */
! 			size3 = min(rest - size2,
! 				    (size_t)PAGE_SIZE - offset - size - size2);
! 			memcpy(buffer + size + size2,
! 			       (void *) ab->data + size2, size3);
! 			size2 += size3;
! 		}
! 
! 		if (rest > 0) {
! 			/* handle the packets that are fully in the next page */
! 			buffer = (void *) ab->data +
! 					(buffer - (start + offset + size));
! 			end = (void *) ab->data + rest;
! 
! 			while (buffer < end)
! 				buffer = handle_ar_packet(ctx, buffer);
! 
! 			ctx->current_buffer = ab;
! 			ctx->pointer = end;
! 
! 			dma_free_coherent(ohci->card.device, PAGE_SIZE,
! 					  start, start_bus);
! 			ar_context_add_page(ctx);
! 		} else {
! 			ctx->pointer = start + PAGE_SIZE;
! 		}
  	} else {
  		buffer = ctx->pointer;
  		ctx->pointer = end =
--- 695,719 ----
  		 */
  
  		offset = offsetof(struct ar_buffer, data);
! 		start = buffer = ab;
  		start_bus = le32_to_cpu(ab->descriptor.data_address) - offset;
  
  		ab = ab->next;
  		d = &ab->descriptor;
! 		size = buffer + PAGE_SIZE - ctx->pointer;
  		rest = le16_to_cpu(d->req_count) - le16_to_cpu(d->res_count);
  		memmove(buffer, ctx->pointer, size);
! 		memcpy(buffer + size, ab->data, rest);
! 		ctx->current_buffer = ab;
! 		ctx->pointer = (void *) ab->data + rest;
! 		end = buffer + size + rest;
! 
! 		while (buffer < end)
! 			buffer = handle_ar_packet(ctx, buffer);
! 
! 		dma_free_coherent(ohci->card.device, PAGE_SIZE,
! 				  start, start_bus);
! 		ar_context_add_page(ctx);
  	} else {
  		buffer = ctx->pointer;
  		ctx->pointer = end =
diff -cBr 2.6.35/drivers/firmware/dcdbas.c linux-2.6.35.y-512ac85/drivers/firmware/dcdbas.c
*** 2.6.35/drivers/firmware/dcdbas.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/firmware/dcdbas.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 268,277 ****
  	}
  
  	/* generate SMI */
- 	/* inb to force posted write through and make SMI happen now */
  	asm volatile (
! 		"outb %b0,%w1\n"
! 		"inb %w1"
  		: /* no output args */
  		: "a" (smi_cmd->command_code),
  		  "d" (smi_cmd->command_address),
--- 268,275 ----
  	}
  
  	/* generate SMI */
  	asm volatile (
! 		"outb %b0,%w1"
  		: /* no output args */
  		: "a" (smi_cmd->command_code),
  		  "d" (smi_cmd->command_address),
diff -cBr 2.6.35/drivers/gpio/cs5535-gpio.c linux-2.6.35.y-512ac85/drivers/gpio/cs5535-gpio.c
*** 2.6.35/drivers/gpio/cs5535-gpio.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpio/cs5535-gpio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 56,84 ****
   * registers, see include/linux/cs5535.h.
   */
  
- static void errata_outl(struct cs5535_gpio_chip *chip, u32 val,
- 		unsigned int reg)
- {
- 	unsigned long addr = chip->base + 0x80 + reg;
- 
- 	/*
- 	 * According to the CS5536 errata (#36), after suspend
- 	 * a write to the high bank GPIO register will clear all
- 	 * non-selected bits; the recommended workaround is a
- 	 * read-modify-write operation.
- 	 *
- 	 * Don't apply this errata to the edge status GPIOs, as writing
- 	 * to their lower bits will clear them.
- 	 */
- 	if (reg != GPIO_POSITIVE_EDGE_STS && reg != GPIO_NEGATIVE_EDGE_STS) {
- 		if (val & 0xffff)
- 			val |= (inl(addr) & 0xffff); /* ignore the high bits */
- 		else
- 			val |= (inl(addr) ^ (val >> 16));
- 	}
- 	outl(val, addr);
- }
- 
  static void __cs5535_gpio_set(struct cs5535_gpio_chip *chip, unsigned offset,
  		unsigned int reg)
  {
--- 56,61 ----
***************
*** 87,93 ****
  		outl(1 << offset, chip->base + reg);
  	else
  		/* high bank register */
! 		errata_outl(chip, 1 << (offset - 16), reg);
  }
  
  void cs5535_gpio_set(unsigned offset, unsigned int reg)
--- 64,70 ----
  		outl(1 << offset, chip->base + reg);
  	else
  		/* high bank register */
! 		outl(1 << (offset - 16), chip->base + 0x80 + reg);
  }
  
  void cs5535_gpio_set(unsigned offset, unsigned int reg)
***************
*** 109,115 ****
  		outl(1 << (offset + 16), chip->base + reg);
  	else
  		/* high bank register */
! 		errata_outl(chip, 1 << offset, reg);
  }
  
  void cs5535_gpio_clear(unsigned offset, unsigned int reg)
--- 86,92 ----
  		outl(1 << (offset + 16), chip->base + reg);
  	else
  		/* high bank register */
! 		outl(1 << offset, chip->base + 0x80 + reg);
  }
  
  void cs5535_gpio_clear(unsigned offset, unsigned int reg)
diff -cBr 2.6.35/drivers/gpio/rdc321x-gpio.c linux-2.6.35.y-512ac85/drivers/gpio/rdc321x-gpio.c
*** 2.6.35/drivers/gpio/rdc321x-gpio.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpio/rdc321x-gpio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 135,141 ****
  	struct rdc321x_gpio *rdc321x_gpio_dev;
  	struct rdc321x_gpio_pdata *pdata;
  
! 	pdata = platform_get_drvdata(pdev);
  	if (!pdata) {
  		dev_err(&pdev->dev, "no platform data supplied\n");
  		return -ENODEV;
--- 135,141 ----
  	struct rdc321x_gpio *rdc321x_gpio_dev;
  	struct rdc321x_gpio_pdata *pdata;
  
! 	pdata = pdev->dev.platform_data;
  	if (!pdata) {
  		dev_err(&pdev->dev, "no platform data supplied\n");
  		return -ENODEV;
diff -cBr 2.6.35/drivers/gpu/drm/drm_crtc.c linux-2.6.35.y-512ac85/drivers/gpu/drm/drm_crtc.c
*** 2.6.35/drivers/gpu/drm/drm_crtc.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/drm_crtc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 155,166 ****
  	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO", 0 },
  	{ DRM_MODE_CONNECTOR_LVDS, "LVDS", 0 },
  	{ DRM_MODE_CONNECTOR_Component, "Component", 0 },
! 	{ DRM_MODE_CONNECTOR_9PinDIN, "DIN", 0 },
! 	{ DRM_MODE_CONNECTOR_DisplayPort, "DP", 0 },
! 	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI-A", 0 },
! 	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI-B", 0 },
  	{ DRM_MODE_CONNECTOR_TV, "TV", 0 },
! 	{ DRM_MODE_CONNECTOR_eDP, "eDP", 0 },
  };
  
  static struct drm_prop_enum_list drm_encoder_enum_list[] =
--- 155,166 ----
  	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO", 0 },
  	{ DRM_MODE_CONNECTOR_LVDS, "LVDS", 0 },
  	{ DRM_MODE_CONNECTOR_Component, "Component", 0 },
! 	{ DRM_MODE_CONNECTOR_9PinDIN, "9-pin DIN", 0 },
! 	{ DRM_MODE_CONNECTOR_DisplayPort, "DisplayPort", 0 },
! 	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI Type A", 0 },
! 	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI Type B", 0 },
  	{ DRM_MODE_CONNECTOR_TV, "TV", 0 },
! 	{ DRM_MODE_CONNECTOR_eDP, "Embedded DisplayPort", 0 },
  };
  
  static struct drm_prop_enum_list drm_encoder_enum_list[] =
diff -cBr 2.6.35/drivers/gpu/drm/drm_irq.c linux-2.6.35.y-512ac85/drivers/gpu/drm/drm_irq.c
*** 2.6.35/drivers/gpu/drm/drm_irq.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/drm_irq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 545,552 ****
  		    struct drm_file *file_priv)
  {
  	struct drm_modeset_ctl *modeset = data;
! 	int ret = 0;
! 	unsigned int crtc;
  
  	/* If drm_vblank_init() hasn't been called yet, just no-op */
  	if (!dev->num_crtcs)
--- 545,551 ----
  		    struct drm_file *file_priv)
  {
  	struct drm_modeset_ctl *modeset = data;
! 	int crtc, ret = 0;
  
  	/* If drm_vblank_init() hasn't been called yet, just no-op */
  	if (!dev->num_crtcs)
diff -cBr 2.6.35/drivers/gpu/drm/i915/i915_dma.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/i915_dma.c
*** 2.6.35/drivers/gpu/drm/i915/i915_dma.c	2011-05-07 19:57:18.346750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/i915_dma.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2297,2305 ****
  		i915_gem_lastclose(dev);
  
  		intel_cleanup_overlay(dev);
- 
- 		if (!I915_NEED_GFX_HWS(dev))
- 			i915_free_hws(dev);
  	}
  
  	intel_teardown_mchbar(dev);
--- 2297,2302 ----
diff -cBr 2.6.35/drivers/gpu/drm/i915/i915_reg.h linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/i915_reg.h
*** 2.6.35/drivers/gpu/drm/i915/i915_reg.h	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/i915_reg.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 2709,2717 ****
  #define FDI_RXB_CHICKEN         0xc2010
  #define  FDI_RX_PHASE_SYNC_POINTER_ENABLE       (1)
  
- #define SOUTH_DSPCLK_GATE_D	0xc2020
- #define  PCH_DPLSUNIT_CLOCK_GATE_DISABLE (1<<29)
- 
  /* CPU: FDI_TX */
  #define FDI_TXA_CTL             0x60100
  #define FDI_TXB_CTL             0x61100
--- 2709,2714 ----
diff -cBr 2.6.35/drivers/gpu/drm/i915/intel_display.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_display.c
*** 2.6.35/drivers/gpu/drm/i915/intel_display.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_display.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 5416,5428 ****
  		I915_WRITE(PCH_DSPCLK_GATE_D, dspclk_gate);
  
  		/*
- 		 * On Ibex Peak and Cougar Point, we need to disable clock
- 		 * gating for the panel power sequencer or it will fail to
- 		 * start up when no ports are active.
- 		 */
- 		I915_WRITE(SOUTH_DSPCLK_GATE_D, PCH_DPLSUNIT_CLOCK_GATE_DISABLE);
- 
- 		/*
  		 * According to the spec the following bits should be set in
  		 * order to enable memory self-refresh
  		 * The bit 22/21 of 0x42004
--- 5416,5421 ----
diff -cBr 2.6.35/drivers/gpu/drm/i915/intel_dp.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_dp.c
*** 2.6.35/drivers/gpu/drm/i915/intel_dp.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_dp.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 416,422 ****
  	uint16_t address = algo_data->address;
  	uint8_t msg[5];
  	uint8_t reply[2];
- 	unsigned retry;
  	int msg_bytes;
  	int reply_bytes;
  	int ret;
--- 416,421 ----
***************
*** 451,483 ****
  		break;
  	}
  
! 	for (retry = 0; retry < 5; retry++) {
! 		ret = intel_dp_aux_ch(intel_encoder,
! 				      msg, msg_bytes,
! 				      reply, reply_bytes);
  		if (ret < 0) {
  			DRM_DEBUG_KMS("aux_ch failed %d\n", ret);
  			return ret;
  		}
- 
- 		switch (reply[0] & AUX_NATIVE_REPLY_MASK) {
- 		case AUX_NATIVE_REPLY_ACK:
- 			/* I2C-over-AUX Reply field is only valid
- 			 * when paired with AUX ACK.
- 			 */
- 			break;
- 		case AUX_NATIVE_REPLY_NACK:
- 			DRM_DEBUG_KMS("aux_ch native nack\n");
- 			return -EREMOTEIO;
- 		case AUX_NATIVE_REPLY_DEFER:
- 			udelay(100);
- 			continue;
- 		default:
- 			DRM_ERROR("aux_ch invalid native reply 0x%02x\n",
- 				  reply[0]);
- 			return -EREMOTEIO;
- 		}
- 
  		switch (reply[0] & AUX_I2C_REPLY_MASK) {
  		case AUX_I2C_REPLY_ACK:
  			if (mode == MODE_I2C_READ) {
--- 450,463 ----
  		break;
  	}
  
! 	for (;;) {
! 	  ret = intel_dp_aux_ch(intel_encoder,
! 				msg, msg_bytes,
! 				reply, reply_bytes);
  		if (ret < 0) {
  			DRM_DEBUG_KMS("aux_ch failed %d\n", ret);
  			return ret;
  		}
  		switch (reply[0] & AUX_I2C_REPLY_MASK) {
  		case AUX_I2C_REPLY_ACK:
  			if (mode == MODE_I2C_READ) {
***************
*** 485,504 ****
  			}
  			return reply_bytes - 1;
  		case AUX_I2C_REPLY_NACK:
! 			DRM_DEBUG_KMS("aux_i2c nack\n");
  			return -EREMOTEIO;
  		case AUX_I2C_REPLY_DEFER:
! 			DRM_DEBUG_KMS("aux_i2c defer\n");
  			udelay(100);
  			break;
  		default:
! 			DRM_ERROR("aux_i2c invalid reply 0x%02x\n", reply[0]);
  			return -EREMOTEIO;
  		}
  	}
- 
- 	DRM_ERROR("too many retries, giving up\n");
- 	return -EREMOTEIO;
  }
  
  static int
--- 465,481 ----
  			}
  			return reply_bytes - 1;
  		case AUX_I2C_REPLY_NACK:
! 			DRM_DEBUG_KMS("aux_ch nack\n");
  			return -EREMOTEIO;
  		case AUX_I2C_REPLY_DEFER:
! 			DRM_DEBUG_KMS("aux_ch defer\n");
  			udelay(100);
  			break;
  		default:
! 			DRM_ERROR("aux_ch invalid reply 0x%02x\n", reply[0]);
  			return -EREMOTEIO;
  		}
  	}
  }
  
  static int
diff -cBr 2.6.35/drivers/gpu/drm/i915/intel_lvds.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_lvds.c
*** 2.6.35/drivers/gpu/drm/i915/intel_lvds.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_lvds.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 811,824 ****
  	},
  	{
  		.callback = intel_no_lvds_dmi_callback,
- 		.ident = "AOpen i915GMm-HFS",
- 		.matches = {
- 			DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
- 			DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
- 		},
- 	},
- 	{
- 		.callback = intel_no_lvds_dmi_callback,
  		.ident = "Aopen i945GTt-VFA",
  		.matches = {
  			DMI_MATCH(DMI_PRODUCT_VERSION, "AO00001JW"),
--- 811,816 ----
diff -cBr 2.6.35/drivers/gpu/drm/i915/intel_overlay.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_overlay.c
*** 2.6.35/drivers/gpu/drm/i915/intel_overlay.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_overlay.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1364,1375 ****
                          goto out_free_bo;
                  }
  		overlay->flip_addr = overlay->reg_bo->gtt_offset;
- 
- 		ret = i915_gem_object_set_to_gtt_domain(reg_bo, true);
- 		if (ret) {
-                         DRM_ERROR("failed to move overlay register bo into the GTT\n");
-                         goto out_unpin_bo;
-                 }
  	} else {
  		ret = i915_gem_attach_phys_object(dev, reg_bo,
  				I915_GEM_PHYS_OVERLAY_REGS);
--- 1364,1369 ----
***************
*** 1401,1408 ****
  	DRM_INFO("initialized overlay support\n");
  	return;
  
- out_unpin_bo:
- 	i915_gem_object_unpin(reg_bo);
  out_free_bo:
  	drm_gem_object_unreference(reg_bo);
  out_free:
--- 1395,1400 ----
diff -cBr 2.6.35/drivers/gpu/drm/i915/intel_sdvo.c linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_sdvo.c
*** 2.6.35/drivers/gpu/drm/i915/intel_sdvo.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/i915/intel_sdvo.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1580,1589 ****
  
  	intel_sdvo_write_cmd(intel_encoder,
  			     SDVO_CMD_GET_ATTACHED_DISPLAYS, NULL, 0);
! 	/* add 30ms delay when the output type might be TV */
! 	if (sdvo_priv->caps.output_flags &
! 	    (SDVO_OUTPUT_SVID0 | SDVO_OUTPUT_CVBS0))
!  		mdelay(30);
  	status = intel_sdvo_read_response(intel_encoder, &response, 2);
  
  	DRM_DEBUG_KMS("SDVO response %d %d\n", response & 0xff, response >> 8);
--- 1580,1589 ----
  
  	intel_sdvo_write_cmd(intel_encoder,
  			     SDVO_CMD_GET_ATTACHED_DISPLAYS, NULL, 0);
! 	if (sdvo_priv->is_tv) {
! 		/* add 30ms delay when the output type is SDVO-TV */
! 		mdelay(30);
! 	}
  	status = intel_sdvo_read_response(intel_encoder, &response, 2);
  
  	DRM_DEBUG_KMS("SDVO response %d %d\n", response & 0xff, response >> 8);
diff -cBr 2.6.35/drivers/gpu/drm/Kconfig linux-2.6.35.y-512ac85/drivers/gpu/drm/Kconfig
*** 2.6.35/drivers/gpu/drm/Kconfig	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/Kconfig	2010-11-22 14:01:26.000000000 -0500
***************
*** 96,105 ****
  config DRM_I915
  	tristate "i915 driver"
  	depends on AGP_INTEL
- 	# we need shmfs for the swappable backing store, and in particular
- 	# the shmem_readpage() which depends upon tmpfs
  	select SHMEM
- 	select TMPFS
  	select DRM_KMS_HELPER
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
--- 96,102 ----
diff -cBr 2.6.35/drivers/gpu/drm/nouveau/nouveau_drv.h linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nouveau_drv.h
*** 2.6.35/drivers/gpu/drm/nouveau/nouveau_drv.h	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nouveau_drv.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 522,533 ****
  	struct work_struct irq_work;
  	struct work_struct hpd_work;
  
- 	struct {
- 		spinlock_t lock;
- 		uint32_t hpd0_bits;
- 		uint32_t hpd1_bits;
- 	} hpd_state;
- 
  	struct list_head vbl_waiting;
  
  	struct {
--- 522,527 ----
diff -cBr 2.6.35/drivers/gpu/drm/nouveau/nouveau_irq.c linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nouveau_irq.c
*** 2.6.35/drivers/gpu/drm/nouveau/nouveau_irq.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nouveau_irq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 52,58 ****
  	if (dev_priv->card_type == NV_50) {
  		INIT_WORK(&dev_priv->irq_work, nv50_display_irq_handler_bh);
  		INIT_WORK(&dev_priv->hpd_work, nv50_display_irq_hotplug_bh);
- 		spin_lock_init(&dev_priv->hpd_state.lock);
  		INIT_LIST_HEAD(&dev_priv->vbl_waiting);
  	}
  }
--- 52,57 ----
diff -cBr 2.6.35/drivers/gpu/drm/nouveau/nv50_display.c linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nv50_display.c
*** 2.6.35/drivers/gpu/drm/nouveau/nv50_display.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/nouveau/nv50_display.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 930,947 ****
  	struct drm_connector *connector;
  	const uint32_t gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
  	uint32_t unplug_mask, plug_mask, change_mask;
! 	uint32_t hpd0, hpd1;
  
! 	spin_lock_irq(&dev_priv->hpd_state.lock);
! 	hpd0 = dev_priv->hpd_state.hpd0_bits;
! 	dev_priv->hpd_state.hpd0_bits = 0;
! 	hpd1 = dev_priv->hpd_state.hpd1_bits;
! 	dev_priv->hpd_state.hpd1_bits = 0;
! 	spin_unlock_irq(&dev_priv->hpd_state.lock);
! 
! 	hpd0 &= nv_rd32(dev, 0xe050);
  	if (dev_priv->chipset >= 0x90)
! 		hpd1 &= nv_rd32(dev, 0xe070);
  
  	plug_mask   = (hpd0 & 0x0000ffff) | (hpd1 << 16);
  	unplug_mask = (hpd0 >> 16) | (hpd1 & 0xffff0000);
--- 930,940 ----
  	struct drm_connector *connector;
  	const uint32_t gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
  	uint32_t unplug_mask, plug_mask, change_mask;
! 	uint32_t hpd0, hpd1 = 0;
  
! 	hpd0 = nv_rd32(dev, 0xe054) & nv_rd32(dev, 0xe050);
  	if (dev_priv->chipset >= 0x90)
! 		hpd1 = nv_rd32(dev, 0xe074) & nv_rd32(dev, 0xe070);
  
  	plug_mask   = (hpd0 & 0x0000ffff) | (hpd1 << 16);
  	unplug_mask = (hpd0 >> 16) | (hpd1 & 0xffff0000);
***************
*** 983,988 ****
--- 976,985 ----
  			helper->dpms(connector->encoder, DRM_MODE_DPMS_OFF);
  	}
  
+ 	nv_wr32(dev, 0xe054, nv_rd32(dev, 0xe054));
+ 	if (dev_priv->chipset >= 0x90)
+ 		nv_wr32(dev, 0xe074, nv_rd32(dev, 0xe074));
+ 
  	drm_helper_hpd_irq_event(dev);
  }
  
***************
*** 993,1014 ****
  	uint32_t delayed = 0;
  
  	if (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_HOTPLUG) {
! 		uint32_t hpd0_bits, hpd1_bits = 0;
! 
! 		hpd0_bits = nv_rd32(dev, 0xe054);
! 		nv_wr32(dev, 0xe054, hpd0_bits);
! 
! 		if (dev_priv->chipset >= 0x90) {
! 			hpd1_bits = nv_rd32(dev, 0xe074);
! 			nv_wr32(dev, 0xe074, hpd1_bits);
! 		}
! 
! 		spin_lock(&dev_priv->hpd_state.lock);
! 		dev_priv->hpd_state.hpd0_bits |= hpd0_bits;
! 		dev_priv->hpd_state.hpd1_bits |= hpd1_bits;
! 		spin_unlock(&dev_priv->hpd_state.lock);
! 
! 		queue_work(dev_priv->wq, &dev_priv->hpd_work);
  	}
  
  	while (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_DISPLAY) {
--- 990,997 ----
  	uint32_t delayed = 0;
  
  	if (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_HOTPLUG) {
! 		if (!work_pending(&dev_priv->hpd_work))
! 			queue_work(dev_priv->wq, &dev_priv->hpd_work);
  	}
  
  	while (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_DISPLAY) {
diff -cBr 2.6.35/drivers/gpu/drm/radeon/atombios_crtc.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/atombios_crtc.c
*** 2.6.35/drivers/gpu/drm/radeon/atombios_crtc.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/atombios_crtc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 259,266 ****
  	case DRM_MODE_DPMS_SUSPEND:
  	case DRM_MODE_DPMS_OFF:
  		drm_vblank_pre_modeset(dev, radeon_crtc->crtc_id);
! 		if (radeon_crtc->enabled)
! 			atombios_blank_crtc(crtc, ATOM_ENABLE);
  		if (ASIC_IS_DCE3(rdev))
  			atombios_enable_crtc_memreq(crtc, ATOM_DISABLE);
  		atombios_enable_crtc(crtc, ATOM_DISABLE);
--- 259,265 ----
  	case DRM_MODE_DPMS_SUSPEND:
  	case DRM_MODE_DPMS_OFF:
  		drm_vblank_pre_modeset(dev, radeon_crtc->crtc_id);
! 		atombios_blank_crtc(crtc, ATOM_ENABLE);
  		if (ASIC_IS_DCE3(rdev))
  			atombios_enable_crtc_memreq(crtc, ATOM_DISABLE);
  		atombios_enable_crtc(crtc, ATOM_DISABLE);
diff -cBr 2.6.35/drivers/gpu/drm/radeon/atom.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/atom.c
*** 2.6.35/drivers/gpu/drm/radeon/atom.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/atom.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 131,137 ****
  		case ATOM_IIO_MOVE_INDEX:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 3));
  			temp |=
  			    ((index >> CU8(base + 2)) &
  			     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +
--- 131,137 ----
  		case ATOM_IIO_MOVE_INDEX:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 2));
  			temp |=
  			    ((index >> CU8(base + 2)) &
  			     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +
***************
*** 141,147 ****
  		case ATOM_IIO_MOVE_DATA:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 3));
  			temp |=
  			    ((data >> CU8(base + 2)) &
  			     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +
--- 141,147 ----
  		case ATOM_IIO_MOVE_DATA:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 2));
  			temp |=
  			    ((data >> CU8(base + 2)) &
  			     (0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +
***************
*** 151,157 ****
  		case ATOM_IIO_MOVE_ATTR:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 3));
  			temp |=
  			    ((ctx->
  			      io_attr >> CU8(base + 2)) & (0xFFFFFFFF >> (32 -
--- 151,157 ----
  		case ATOM_IIO_MOVE_ATTR:
  			temp &=
  			    ~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<
! 			      CU8(base + 2));
  			temp |=
  			    ((ctx->
  			      io_attr >> CU8(base + 2)) & (0xFFFFFFFF >> (32 -
diff -cBr 2.6.35/drivers/gpu/drm/radeon/evergreen.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/evergreen.c
*** 2.6.35/drivers/gpu/drm/radeon/evergreen.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/evergreen.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1406,1411 ****
--- 1406,1412 ----
  static int evergreen_gpu_soft_reset(struct radeon_device *rdev)
  {
  	struct evergreen_mc_save save;
+ 	u32 srbm_reset = 0;
  	u32 grbm_reset = 0;
  
  	dev_info(rdev->dev, "GPU softreset \n");
***************
*** 1444,1449 ****
--- 1445,1460 ----
  	udelay(50);
  	WREG32(GRBM_SOFT_RESET, 0);
  	(void)RREG32(GRBM_SOFT_RESET);
+ 
+ 	/* reset all the system blocks */
+ 	srbm_reset = SRBM_SOFT_RESET_ALL_MASK;
+ 
+ 	dev_info(rdev->dev, "  SRBM_SOFT_RESET=0x%08X\n", srbm_reset);
+ 	WREG32(SRBM_SOFT_RESET, srbm_reset);
+ 	(void)RREG32(SRBM_SOFT_RESET);
+ 	udelay(50);
+ 	WREG32(SRBM_SOFT_RESET, 0);
+ 	(void)RREG32(SRBM_SOFT_RESET);
  	/* Wait a little for things to settle down */
  	udelay(50);
  	dev_info(rdev->dev, "  GRBM_STATUS=0x%08X\n",
***************
*** 1454,1459 ****
--- 1465,1474 ----
  		RREG32(GRBM_STATUS_SE1));
  	dev_info(rdev->dev, "  SRBM_STATUS=0x%08X\n",
  		RREG32(SRBM_STATUS));
+ 	/* After reset we need to reinit the asic as GPU often endup in an
+ 	 * incoherent state.
+ 	 */
+ 	atom_asic_init(rdev->mode_info.atom_context);
  	evergreen_mc_resume(rdev, &save);
  	return 0;
  }
***************
*** 2065,2075 ****
  {
  	int r;
  
- 	/* reset the asic, the gfx blocks are often in a bad state
- 	 * after the driver is unloaded or after a resume
- 	 */
- 	if (radeon_asic_reset(rdev))
- 		dev_warn(rdev->dev, "GPU reset failed !\n");
  	/* Do not reset GPU before posting, on rv770 hw unlike on r500 hw,
  	 * posting will perform necessary task to bring back GPU into good
  	 * shape.
--- 2080,2085 ----
***************
*** 2171,2181 ****
  	r = radeon_atombios_init(rdev);
  	if (r)
  		return r;
- 	/* reset the asic, the gfx blocks are often in a bad state
- 	 * after the driver is unloaded or after a resume
- 	 */
- 	if (radeon_asic_reset(rdev))
- 		dev_warn(rdev->dev, "GPU reset failed !\n");
  	/* Post card if necessary */
  	if (!evergreen_card_posted(rdev)) {
  		if (!rdev->bios) {
--- 2181,2186 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r100.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r100.c
*** 2.6.35/drivers/gpu/drm/radeon/r100.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r100.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2321,2329 ****
  		/* Fix for RN50, M6, M7 with 8/16/32(??) MBs of VRAM - 
  		 * Novell bug 204882 + along with lots of ubuntu ones
  		 */
- 		if (rdev->mc.aper_size > config_aper_size)
- 			config_aper_size = rdev->mc.aper_size;
- 
  		if (config_aper_size > rdev->mc.real_vram_size)
  			rdev->mc.mc_vram_size = config_aper_size;
  		else
--- 2321,2326 ----
***************
*** 3232,3239 ****
  	for (u = 0; u < track->num_texture; u++) {
  		if (!track->textures[u].enabled)
  			continue;
- 		if (track->textures[u].lookup_disable)
- 			continue;
  		robj = track->textures[u].robj;
  		if (robj == NULL) {
  			DRM_ERROR("No texture bound to unit %u\n", u);
--- 3229,3234 ----
***************
*** 3467,3473 ****
  		track->textures[i].robj = NULL;
  		/* CS IB emission code makes sure texture unit are disabled */
  		track->textures[i].enabled = false;
- 		track->textures[i].lookup_disable = false;
  		track->textures[i].roundup_w = true;
  		track->textures[i].roundup_h = true;
  		if (track->separate_cube)
--- 3462,3467 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r100_track.h linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r100_track.h
*** 2.6.35/drivers/gpu/drm/radeon/r100_track.h	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r100_track.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 46,52 ****
  	unsigned		height_11;
  	bool			use_pitch;
  	bool			enabled;
- 	bool                    lookup_disable;
  	bool			roundup_w;
  	bool			roundup_h;
  	unsigned                compress_format;
--- 46,51 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r200.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r200.c
*** 2.6.35/drivers/gpu/drm/radeon/r200.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r200.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 447,454 ****
  			track->textures[i].width = 1 << ((idx_value >> RADEON_TXFORMAT_WIDTH_SHIFT) & RADEON_TXFORMAT_WIDTH_MASK);
  			track->textures[i].height = 1 << ((idx_value >> RADEON_TXFORMAT_HEIGHT_SHIFT) & RADEON_TXFORMAT_HEIGHT_MASK);
  		}
- 		if (idx_value & R200_TXFORMAT_LOOKUP_DISABLE)
- 			track->textures[i].lookup_disable = true;
  		switch ((idx_value & RADEON_TXFORMAT_FORMAT_MASK)) {
  		case R200_TXFORMAT_I8:
  		case R200_TXFORMAT_RGB332:
--- 447,452 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r600_blit_kms.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600_blit_kms.c
*** 2.6.35/drivers/gpu/drm/radeon/r600_blit_kms.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600_blit_kms.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 623,630 ****
  			int src_x = src_gpu_addr & 255;
  			int dst_x = dst_gpu_addr & 255;
  			int h = 1;
! 			src_gpu_addr = src_gpu_addr & ~255ULL;
! 			dst_gpu_addr = dst_gpu_addr & ~255ULL;
  
  			if (!src_x && !dst_x) {
  				h = (cur_size / max_bytes);
--- 623,630 ----
  			int src_x = src_gpu_addr & 255;
  			int dst_x = dst_gpu_addr & 255;
  			int h = 1;
! 			src_gpu_addr = src_gpu_addr & ~255;
! 			dst_gpu_addr = dst_gpu_addr & ~255;
  
  			if (!src_x && !dst_x) {
  				h = (cur_size / max_bytes);
***************
*** 717,724 ****
  			int src_x = (src_gpu_addr & 255);
  			int dst_x = (dst_gpu_addr & 255);
  			int h = 1;
! 			src_gpu_addr = src_gpu_addr & ~255ULL;
! 			dst_gpu_addr = dst_gpu_addr & ~255ULL;
  
  			if (!src_x && !dst_x) {
  				h = (cur_size / max_bytes);
--- 717,724 ----
  			int src_x = (src_gpu_addr & 255);
  			int dst_x = (dst_gpu_addr & 255);
  			int h = 1;
! 			src_gpu_addr = src_gpu_addr & ~255;
! 			dst_gpu_addr = dst_gpu_addr & ~255;
  
  			if (!src_x && !dst_x) {
  				h = (cur_size / max_bytes);
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r600.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600.c
*** 2.6.35/drivers/gpu/drm/radeon/r600.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 869,883 ****
  	u32 tmp;
  
  	/* flush hdp cache so updates hit vram */
! 	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&
! 	    !(rdev->flags & RADEON_IS_AGP)) {
  		void __iomem *ptr = (void *)rdev->gart.table.vram.ptr;
  		u32 tmp;
  
  		/* r7xx hw bug.  write to HDP_DEBUG1 followed by fb read
  		 * rather than write to HDP_REG_COHERENCY_FLUSH_CNTL
- 		 * This seems to cause problems on some AGP cards. Just use the old
- 		 * method for them.
  		 */
  		WREG32(HDP_DEBUG1, 0);
  		tmp = readl((void __iomem *)ptr);
--- 869,880 ----
  	u32 tmp;
  
  	/* flush hdp cache so updates hit vram */
! 	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740)) {
  		void __iomem *ptr = (void *)rdev->gart.table.vram.ptr;
  		u32 tmp;
  
  		/* r7xx hw bug.  write to HDP_DEBUG1 followed by fb read
  		 * rather than write to HDP_REG_COHERENCY_FLUSH_CNTL
  		 */
  		WREG32(HDP_DEBUG1, 0);
  		tmp = readl((void __iomem *)ptr);
***************
*** 1189,1198 ****
  				mc->vram_end, mc->real_vram_size >> 20);
  	} else {
  		u64 base = 0;
! 		if (rdev->flags & RADEON_IS_IGP) {
! 			base = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;
! 			base <<= 24;
! 		}
  		radeon_vram_location(rdev, &rdev->mc, base);
  		rdev->mc.gtt_base_align = 0;
  		radeon_gtt_location(rdev, mc);
--- 1186,1193 ----
  				mc->vram_end, mc->real_vram_size >> 20);
  	} else {
  		u64 base = 0;
! 		if (rdev->flags & RADEON_IS_IGP)
! 			base = (RREG32(MC_VM_FB_LOCATION) & 0xFFFF) << 24;
  		radeon_vram_location(rdev, &rdev->mc, base);
  		rdev->mc.gtt_base_align = 0;
  		radeon_gtt_location(rdev, mc);
***************
*** 3525,3536 ****
  void r600_ioctl_wait_idle(struct radeon_device *rdev, struct radeon_bo *bo)
  {
  	/* r7xx hw bug.  write to HDP_DEBUG1 followed by fb read
! 	 * rather than write to HDP_REG_COHERENCY_FLUSH_CNTL.
! 	 * This seems to cause problems on some AGP cards. Just use the old
! 	 * method for them.
  	 */
  	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&
! 	    rdev->vram_scratch.ptr && !(rdev->flags & RADEON_IS_AGP)) {
  		void __iomem *ptr = (void *)rdev->vram_scratch.ptr;
  		u32 tmp;
  
--- 3520,3529 ----
  void r600_ioctl_wait_idle(struct radeon_device *rdev, struct radeon_bo *bo)
  {
  	/* r7xx hw bug.  write to HDP_DEBUG1 followed by fb read
! 	 * rather than write to HDP_REG_COHERENCY_FLUSH_CNTL
  	 */
  	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&
! 	    rdev->vram_scratch.ptr) {
  		void __iomem *ptr = (void *)rdev->vram_scratch.ptr;
  		u32 tmp;
  
diff -cBr 2.6.35/drivers/gpu/drm/radeon/r600_reg.h linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600_reg.h
*** 2.6.35/drivers/gpu/drm/radeon/r600_reg.h	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/r600_reg.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 86,92 ****
  #define R600_HDP_NONSURFACE_BASE                                0x2c04
  
  #define R600_BUS_CNTL                                           0x5420
- #       define R600_BIOS_ROM_DIS                                (1 << 1)
  #define R600_CONFIG_CNTL                                        0x5424
  #define R600_CONFIG_MEMSIZE                                     0x5428
  #define R600_CONFIG_F0_BASE                                     0x542C
--- 86,91 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_atombios.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_atombios.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_atombios.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_atombios.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 84,97 ****
  		for (i = 0; i < num_indices; i++) {
  			gpio = &i2c_info->asGPIO_Info[i];
  
- 			/* some DCE3 boards have bad data for this entry */
- 			if (ASIC_IS_DCE3(rdev)) {
- 				if ((i == 4) &&
- 				    (gpio->usClkMaskRegisterIndex == 0x1fda) &&
- 				    (gpio->sucI2cId.ucAccess == 0x94))
- 					gpio->sucI2cId.ucAccess = 0x14;
- 			}
- 
  			if (gpio->sucI2cId.ucAccess == id) {
  				i2c.mask_clk_reg = le16_to_cpu(gpio->usClkMaskRegisterIndex) * 4;
  				i2c.mask_data_reg = le16_to_cpu(gpio->usDataMaskRegisterIndex) * 4;
--- 84,89 ----
***************
*** 289,301 ****
  			*line_mux = 0x90;
  	}
  
- 	/* mac rv630, rv730, others */
- 	if ((supported_device == ATOM_DEVICE_TV1_SUPPORT) &&
- 	    (*connector_type == DRM_MODE_CONNECTOR_DVII)) {
- 		*connector_type = DRM_MODE_CONNECTOR_9PinDIN;
- 		*line_mux = CONNECTOR_7PIN_DIN_ENUM_ID1;
- 	}
- 
  	/* ASUS HD 3600 XT board lists the DVI port as HDMI */
  	if ((dev->pdev->device == 0x9598) &&
  	    (dev->pdev->subsystem_vendor == 0x1043) &&
--- 281,286 ----
***************
*** 2125,2131 ****
  	bios_2_scratch &= ~ATOM_S2_VRI_BRIGHT_ENABLE;
  
  	/* tell the bios not to handle mode switching */
! 	bios_6_scratch |= ATOM_S6_ACC_BLOCK_DISPLAY_SWITCH;
  
  	if (rdev->family >= CHIP_R600) {
  		WREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);
--- 2110,2116 ----
  	bios_2_scratch &= ~ATOM_S2_VRI_BRIGHT_ENABLE;
  
  	/* tell the bios not to handle mode switching */
! 	bios_6_scratch |= (ATOM_S6_ACC_BLOCK_DISPLAY_SWITCH | ATOM_S6_ACC_MODE);
  
  	if (rdev->family >= CHIP_R600) {
  		WREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);
***************
*** 2176,2188 ****
  	else
  		bios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);
  
! 	if (lock) {
  		bios_6_scratch |= ATOM_S6_CRITICAL_STATE;
! 		bios_6_scratch &= ~ATOM_S6_ACC_MODE;
! 	} else {
  		bios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;
- 		bios_6_scratch |= ATOM_S6_ACC_MODE;
- 	}
  
  	if (rdev->family >= CHIP_R600)
  		WREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);
--- 2161,2170 ----
  	else
  		bios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);
  
! 	if (lock)
  		bios_6_scratch |= ATOM_S6_CRITICAL_STATE;
! 	else
  		bios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;
  
  	if (rdev->family >= CHIP_R600)
  		WREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_bios.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_bios.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_bios.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_bios.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 143,149 ****
  	bool r;
  
  	viph_control = RREG32(RADEON_VIPH_CONTROL);
! 	bus_cntl = RREG32(R600_BUS_CNTL);
  	d1vga_control = RREG32(AVIVO_D1VGA_CONTROL);
  	d2vga_control = RREG32(AVIVO_D2VGA_CONTROL);
  	vga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);
--- 143,149 ----
  	bool r;
  
  	viph_control = RREG32(RADEON_VIPH_CONTROL);
! 	bus_cntl = RREG32(RADEON_BUS_CNTL);
  	d1vga_control = RREG32(AVIVO_D1VGA_CONTROL);
  	d2vga_control = RREG32(AVIVO_D2VGA_CONTROL);
  	vga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);
***************
*** 152,158 ****
  	/* disable VIP */
  	WREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));
  	/* enable the rom */
! 	WREG32(R600_BUS_CNTL, (bus_cntl & ~R600_BIOS_ROM_DIS));
  	/* Disable VGA mode */
  	WREG32(AVIVO_D1VGA_CONTROL,
  	       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
--- 152,158 ----
  	/* disable VIP */
  	WREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));
  	/* enable the rom */
! 	WREG32(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));
  	/* Disable VGA mode */
  	WREG32(AVIVO_D1VGA_CONTROL,
  	       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
***************
*** 191,197 ****
  			cg_spll_status = RREG32(R600_CG_SPLL_STATUS);
  	}
  	WREG32(RADEON_VIPH_CONTROL, viph_control);
! 	WREG32(R600_BUS_CNTL, bus_cntl);
  	WREG32(AVIVO_D1VGA_CONTROL, d1vga_control);
  	WREG32(AVIVO_D2VGA_CONTROL, d2vga_control);
  	WREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
--- 191,197 ----
  			cg_spll_status = RREG32(R600_CG_SPLL_STATUS);
  	}
  	WREG32(RADEON_VIPH_CONTROL, viph_control);
! 	WREG32(RADEON_BUS_CNTL, bus_cntl);
  	WREG32(AVIVO_D1VGA_CONTROL, d1vga_control);
  	WREG32(AVIVO_D2VGA_CONTROL, d2vga_control);
  	WREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
***************
*** 216,222 ****
  	bool r;
  
  	viph_control = RREG32(RADEON_VIPH_CONTROL);
! 	bus_cntl = RREG32(R600_BUS_CNTL);
  	d1vga_control = RREG32(AVIVO_D1VGA_CONTROL);
  	d2vga_control = RREG32(AVIVO_D2VGA_CONTROL);
  	vga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);
--- 216,222 ----
  	bool r;
  
  	viph_control = RREG32(RADEON_VIPH_CONTROL);
! 	bus_cntl = RREG32(RADEON_BUS_CNTL);
  	d1vga_control = RREG32(AVIVO_D1VGA_CONTROL);
  	d2vga_control = RREG32(AVIVO_D2VGA_CONTROL);
  	vga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);
***************
*** 231,237 ****
  	/* disable VIP */
  	WREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));
  	/* enable the rom */
! 	WREG32(R600_BUS_CNTL, (bus_cntl & ~R600_BIOS_ROM_DIS));
  	/* Disable VGA mode */
  	WREG32(AVIVO_D1VGA_CONTROL,
  	       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
--- 231,237 ----
  	/* disable VIP */
  	WREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));
  	/* enable the rom */
! 	WREG32(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));
  	/* Disable VGA mode */
  	WREG32(AVIVO_D1VGA_CONTROL,
  	       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
***************
*** 262,268 ****
  
  	/* restore regs */
  	WREG32(RADEON_VIPH_CONTROL, viph_control);
! 	WREG32(R600_BUS_CNTL, bus_cntl);
  	WREG32(AVIVO_D1VGA_CONTROL, d1vga_control);
  	WREG32(AVIVO_D2VGA_CONTROL, d2vga_control);
  	WREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
--- 262,268 ----
  
  	/* restore regs */
  	WREG32(RADEON_VIPH_CONTROL, viph_control);
! 	WREG32(RADEON_BUS_CNTL, bus_cntl);
  	WREG32(AVIVO_D1VGA_CONTROL, d1vga_control);
  	WREG32(AVIVO_D2VGA_CONTROL, d2vga_control);
  	WREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_connectors.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_connectors.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_connectors.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_connectors.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1083,1090 ****
  					      rdev->mode_info.load_detect_property,
  					      1);
  		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
- 		connector->interlace_allowed = true;
- 		connector->doublescan_allowed = true;
  		break;
  	case DRM_MODE_CONNECTOR_DVIA:
  		drm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);
--- 1083,1088 ----
***************
*** 1098,1105 ****
  		drm_connector_attach_property(&radeon_connector->base,
  					      rdev->mode_info.load_detect_property,
  					      1);
- 		connector->interlace_allowed = true;
- 		connector->doublescan_allowed = true;
  		break;
  	case DRM_MODE_CONNECTOR_DVII:
  	case DRM_MODE_CONNECTOR_DVID:
--- 1096,1101 ----
***************
*** 1126,1136 ****
  						      rdev->mode_info.load_detect_property,
  						      1);
  		}
- 		connector->interlace_allowed = true;
- 		if (connector_type == DRM_MODE_CONNECTOR_DVII)
- 			connector->doublescan_allowed = true;
- 		else
- 			connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_HDMIA:
  	case DRM_MODE_CONNECTOR_HDMIB:
--- 1122,1127 ----
***************
*** 1151,1161 ****
  					      rdev->mode_info.coherent_mode_property,
  					      1);
  		subpixel_order = SubPixelHorizontalRGB;
- 		connector->interlace_allowed = true;
- 		if (connector_type == DRM_MODE_CONNECTOR_HDMIB)
- 			connector->doublescan_allowed = true;
- 		else
- 			connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_DisplayPort:
  	case DRM_MODE_CONNECTOR_eDP:
--- 1142,1147 ----
***************
*** 1186,1194 ****
  		drm_connector_attach_property(&radeon_connector->base,
  					      rdev->mode_info.coherent_mode_property,
  					      1);
- 		connector->interlace_allowed = true;
- 		/* in theory with a DP to VGA converter... */
- 		connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_SVIDEO:
  	case DRM_MODE_CONNECTOR_Composite:
--- 1172,1177 ----
***************
*** 1204,1211 ****
  						      rdev->mode_info.tv_std_property,
  						      radeon_atombios_get_tv_info(rdev));
  		}
- 		connector->interlace_allowed = false;
- 		connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_LVDS:
  		radeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);
--- 1187,1192 ----
***************
*** 1225,1232 ****
  					      dev->mode_config.scaling_mode_property,
  					      DRM_MODE_SCALE_FULLSCREEN);
  		subpixel_order = SubPixelHorizontalRGB;
- 		connector->interlace_allowed = false;
- 		connector->doublescan_allowed = false;
  		break;
  	}
  
--- 1206,1211 ----
***************
*** 1298,1305 ****
  					      rdev->mode_info.load_detect_property,
  					      1);
  		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
- 		connector->interlace_allowed = true;
- 		connector->doublescan_allowed = true;
  		break;
  	case DRM_MODE_CONNECTOR_DVIA:
  		drm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);
--- 1277,1282 ----
***************
*** 1313,1320 ****
  		drm_connector_attach_property(&radeon_connector->base,
  					      rdev->mode_info.load_detect_property,
  					      1);
- 		connector->interlace_allowed = true;
- 		connector->doublescan_allowed = true;
  		break;
  	case DRM_MODE_CONNECTOR_DVII:
  	case DRM_MODE_CONNECTOR_DVID:
--- 1290,1295 ----
***************
*** 1332,1342 ****
  						      1);
  		}
  		subpixel_order = SubPixelHorizontalRGB;
- 		connector->interlace_allowed = true;
- 		if (connector_type == DRM_MODE_CONNECTOR_DVII)
- 			connector->doublescan_allowed = true;
- 		else
- 			connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_SVIDEO:
  	case DRM_MODE_CONNECTOR_Composite:
--- 1307,1312 ----
***************
*** 1359,1366 ****
  						      rdev->mode_info.tv_std_property,
  						      radeon_combios_get_tv_info(rdev));
  		}
- 		connector->interlace_allowed = false;
- 		connector->doublescan_allowed = false;
  		break;
  	case DRM_MODE_CONNECTOR_LVDS:
  		drm_connector_init(dev, &radeon_connector->base, &radeon_lvds_connector_funcs, connector_type);
--- 1329,1334 ----
***************
*** 1374,1381 ****
  					      dev->mode_config.scaling_mode_property,
  					      DRM_MODE_SCALE_FULLSCREEN);
  		subpixel_order = SubPixelHorizontalRGB;
- 		connector->interlace_allowed = false;
- 		connector->doublescan_allowed = false;
  		break;
  	}
  
--- 1342,1347 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_device.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_device.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_device.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_device.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 799,804 ****
--- 799,809 ----
  	radeon_pm_resume(rdev);
  	radeon_restore_bios_scratch_regs(rdev);
  
+ 	/* turn on display hw */
+ 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+ 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
+ 	}
+ 
  	radeon_fbdev_set_suspend(rdev, 0);
  	release_console_sem();
  
***************
*** 806,815 ****
  	radeon_hpd_init(rdev);
  	/* blat the mode back in */
  	drm_helper_resume_force_mode(dev);
- 	/* turn on display hw */
- 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
- 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
- 	}
  	return 0;
  }
  
--- 811,816 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_display.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_display.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_display.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_display.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 619,628 ****
  	*frac_fb_div_p = best_frac_feedback_div;
  	*ref_div_p = best_ref_div;
  	*post_div_p = best_post_div;
- 	DRM_DEBUG_KMS("%d %d, pll dividers - fb: %d.%d ref: %d, post %d\n",
- 		      freq, best_freq / 1000, best_feedback_div, best_frac_feedback_div,
- 		      best_ref_div, best_post_div);
- 
  }
  
  static bool
--- 619,624 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_encoders.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_encoders.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_encoders.c	2011-05-07 19:57:18.356750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_encoders.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 626,648 ****
  	struct drm_connector *connector;
  	struct radeon_connector *radeon_connector;
  	struct radeon_connector_atom_dig *dig_connector;
- 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
  
  	connector = radeon_get_connector_for_encoder(encoder);
! 	if (!connector) {
! 		switch (radeon_encoder->encoder_id) {
! 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
! 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
! 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
! 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
! 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
! 			return ATOM_ENCODER_MODE_DVI;
! 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
! 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
! 		default:
! 			return ATOM_ENCODER_MODE_CRT;
! 		}
! 	}
  	radeon_connector = to_radeon_connector(connector);
  
  	switch (connector->connector_type) {
--- 626,636 ----
  	struct drm_connector *connector;
  	struct radeon_connector *radeon_connector;
  	struct radeon_connector_atom_dig *dig_connector;
  
  	connector = radeon_get_connector_for_encoder(encoder);
! 	if (!connector)
! 		return 0;
! 
  	radeon_connector = to_radeon_connector(connector);
  
  	switch (connector->connector_type) {
***************
*** 1557,1579 ****
  	struct radeon_device *rdev = dev->dev_private;
  	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
  	struct radeon_encoder_atom_dig *dig;
- 
- 	/* check for pre-DCE3 cards with shared encoders;
- 	 * can't really use the links individually, so don't disable
- 	 * the encoder if it's in use by another connector
- 	 */
- 	if (!ASIC_IS_DCE3(rdev)) {
- 		struct drm_encoder *other_encoder;
- 		struct radeon_encoder *other_radeon_encoder;
- 
- 		list_for_each_entry(other_encoder, &dev->mode_config.encoder_list, head) {
- 			other_radeon_encoder = to_radeon_encoder(other_encoder);
- 			if ((radeon_encoder->encoder_id == other_radeon_encoder->encoder_id) &&
- 			    drm_helper_encoder_in_use(other_encoder))
- 				goto disable_done;
- 		}
- 	}
- 
  	radeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);
  
  	switch (radeon_encoder->encoder_id) {
--- 1545,1550 ----
***************
*** 1613,1619 ****
  		break;
  	}
  
- disable_done:
  	if (radeon_encoder_is_digital(encoder)) {
  		if (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI)
  			r600_hdmi_disable(encoder);
--- 1584,1589 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_i2c.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_i2c.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_i2c.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_i2c.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 942,948 ****
  	i2c->rec = *rec;
  	i2c->adapter.owner = THIS_MODULE;
  	i2c->dev = dev;
- 	sprintf(i2c->adapter.name, "Radeon aux bus %s", name);
  	i2c_set_adapdata(&i2c->adapter, i2c);
  	i2c->adapter.algo_data = &i2c->algo.dp;
  	i2c->algo.dp.aux_ch = radeon_dp_i2c_aux_ch;
--- 942,947 ----
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_object.c linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_object.c
*** 2.6.35/drivers/gpu/drm/radeon/radeon_object.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_object.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 102,109 ****
  		type = ttm_bo_type_device;
  	}
  	*bo_ptr = NULL;
- 
- retry:
  	bo = kzalloc(sizeof(struct radeon_bo), GFP_KERNEL);
  	if (bo == NULL)
  		return -ENOMEM;
--- 102,107 ----
***************
*** 111,116 ****
--- 109,116 ----
  	bo->gobj = gobj;
  	bo->surface_reg = -1;
  	INIT_LIST_HEAD(&bo->list);
+ 
+ retry:
  	radeon_ttm_placement_from_domain(bo, domain);
  	/* Kernel allocation are uninterruptible */
  	mutex_lock(&rdev->vram_mutex);
diff -cBr 2.6.35/drivers/gpu/drm/radeon/radeon_reg.h linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_reg.h
*** 2.6.35/drivers/gpu/drm/radeon/radeon_reg.h	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/gpu/drm/radeon/radeon_reg.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 2836,2842 ****
  #       define R200_TXFORMAT_ST_ROUTE_STQ5	(5 << 24)
  #       define R200_TXFORMAT_ST_ROUTE_MASK	(7 << 24)
  #       define R200_TXFORMAT_ST_ROUTE_SHIFT	24
- #       define R200_TXFORMAT_LOOKUP_DISABLE	(1 << 27)
  #       define R200_TXFORMAT_ALPHA_MASK_ENABLE	(1 << 28)
  #       define R200_TXFORMAT_CHROMA_KEY_ENABLE	(1 << 29)
  #       define R200_TXFORMAT_CUBIC_MAP_ENABLE		(1 << 30)
--- 2836,2841 ----
Only in 2.6.35/drivers/gpu: pvr
diff -cBr 2.6.35/drivers/hid/hid-egalax.c linux-2.6.35.y-512ac85/drivers/hid/hid-egalax.c
*** 2.6.35/drivers/hid/hid-egalax.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hid/hid-egalax.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 31,37 ****
  	bool first;		/* is this the first finger in the frame? */
  	bool valid;		/* valid finger data, or just placeholder? */
  	bool activity;		/* at least one active finger previously? */
! 	__u16 lastx, lasty, lastz;	/* latest valid (x, y, z) in the frame */
  };
  
  static int egalax_input_mapping(struct hid_device *hdev, struct hid_input *hi,
--- 31,37 ----
  	bool first;		/* is this the first finger in the frame? */
  	bool valid;		/* valid finger data, or just placeholder? */
  	bool activity;		/* at least one active finger previously? */
! 	__u16 lastx, lasty;	/* latest valid (x, y) in the frame */
  };
  
  static int egalax_input_mapping(struct hid_device *hdev, struct hid_input *hi,
***************
*** 79,88 ****
  		case HID_DG_TIPPRESSURE:
  			hid_map_usage(hi, usage, bit, max,
  					EV_ABS, ABS_MT_PRESSURE);
- 			/* touchscreen emulation */
- 			input_set_abs_params(hi->input, ABS_PRESSURE,
- 						field->logical_minimum,
- 						field->logical_maximum, 0, 0);
  			return 1;
  		}
  		return 0;
--- 79,84 ----
***************
*** 113,120 ****
  	if (td->valid) {
  		/* emit multitouch events */
  		input_event(input, EV_ABS, ABS_MT_TRACKING_ID, td->id);
! 		input_event(input, EV_ABS, ABS_MT_POSITION_X, td->x >> 3);
! 		input_event(input, EV_ABS, ABS_MT_POSITION_Y, td->y >> 3);
  		input_event(input, EV_ABS, ABS_MT_PRESSURE, td->z);
  
  		input_mt_sync(input);
--- 109,116 ----
  	if (td->valid) {
  		/* emit multitouch events */
  		input_event(input, EV_ABS, ABS_MT_TRACKING_ID, td->id);
! 		input_event(input, EV_ABS, ABS_MT_POSITION_X, td->x);
! 		input_event(input, EV_ABS, ABS_MT_POSITION_Y, td->y);
  		input_event(input, EV_ABS, ABS_MT_PRESSURE, td->z);
  
  		input_mt_sync(input);
***************
*** 125,131 ****
  		 */
  		td->lastx = td->x;
  		td->lasty = td->y;
- 		td->lastz = td->z;
  	}
  
  	/*
--- 121,126 ----
***************
*** 134,142 ****
  	 * the oldest on the panel, the one we want for single touch
  	 */
  	if (!td->first && td->activity) {
! 		input_event(input, EV_ABS, ABS_X, td->lastx >> 3);
! 		input_event(input, EV_ABS, ABS_Y, td->lasty >> 3);
!  		input_event(input, EV_ABS, ABS_PRESSURE, td->lastz);
  	}
  
  	if (!td->valid) {
--- 129,136 ----
  	 * the oldest on the panel, the one we want for single touch
  	 */
  	if (!td->first && td->activity) {
! 		input_event(input, EV_ABS, ABS_X, td->lastx);
! 		input_event(input, EV_ABS, ABS_Y, td->lasty);
  	}
  
  	if (!td->valid) {
diff -cBr 2.6.35/drivers/hid/usbhid/hid-quirks.c linux-2.6.35.y-512ac85/drivers/hid/usbhid/hid-quirks.c
*** 2.6.35/drivers/hid/usbhid/hid-quirks.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hid/usbhid/hid-quirks.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 33,38 ****
--- 33,39 ----
  	{ USB_VENDOR_ID_AASHIMA, USB_DEVICE_ID_AASHIMA_PREDATOR, HID_QUIRK_BADPAD },
  	{ USB_VENDOR_ID_ALPS, USB_DEVICE_ID_IBM_GAMEPAD, HID_QUIRK_BADPAD },
  	{ USB_VENDOR_ID_CHIC, USB_DEVICE_ID_CHIC_GAMEPAD, HID_QUIRK_BADPAD },
+ 	{ USB_VENDOR_ID_DWAV, USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH, HID_QUIRK_MULTI_INPUT },
  	{ USB_VENDOR_ID_MOJO, USB_DEVICE_ID_RETRO_ADAPTER, HID_QUIRK_MULTI_INPUT },
  	{ USB_VENDOR_ID_HAPP, USB_DEVICE_ID_UGCI_DRIVING, HID_QUIRK_BADPAD | HID_QUIRK_MULTI_INPUT },
  	{ USB_VENDOR_ID_HAPP, USB_DEVICE_ID_UGCI_FLYING, HID_QUIRK_BADPAD | HID_QUIRK_MULTI_INPUT },
diff -cBr 2.6.35/drivers/hwmon/adm1026.c linux-2.6.35.y-512ac85/drivers/hwmon/adm1026.c
*** 2.6.35/drivers/hwmon/adm1026.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/adm1026.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 916,942 ****
  	int nr = sensor_attr->index;
  	struct i2c_client *client = to_i2c_client(dev);
  	struct adm1026_data *data = i2c_get_clientdata(client);
! 	int val, orig_div, new_div;
  
  	val = simple_strtol(buf, NULL, 10);
  	new_div = DIV_TO_REG(val);
! 
  	mutex_lock(&data->update_lock);
  	orig_div = data->fan_div[nr];
  	data->fan_div[nr] = DIV_FROM_REG(new_div);
  
  	if (nr < 4) { /* 0 <= nr < 4 */
  		adm1026_write_value(client, ADM1026_REG_FAN_DIV_0_3,
! 				    (DIV_TO_REG(data->fan_div[0]) << 0) |
! 				    (DIV_TO_REG(data->fan_div[1]) << 2) |
! 				    (DIV_TO_REG(data->fan_div[2]) << 4) |
! 				    (DIV_TO_REG(data->fan_div[3]) << 6));
  	} else { /* 3 < nr < 8 */
  		adm1026_write_value(client, ADM1026_REG_FAN_DIV_4_7,
! 				    (DIV_TO_REG(data->fan_div[4]) << 0) |
! 				    (DIV_TO_REG(data->fan_div[5]) << 2) |
! 				    (DIV_TO_REG(data->fan_div[6]) << 4) |
! 				    (DIV_TO_REG(data->fan_div[7]) << 6));
  	}
  
  	if (data->fan_div[nr] != orig_div) {
--- 916,942 ----
  	int nr = sensor_attr->index;
  	struct i2c_client *client = to_i2c_client(dev);
  	struct adm1026_data *data = i2c_get_clientdata(client);
! 	int val, orig_div, new_div, shift;
  
  	val = simple_strtol(buf, NULL, 10);
  	new_div = DIV_TO_REG(val);
! 	if (new_div == 0) {
! 		return -EINVAL;
! 	}
  	mutex_lock(&data->update_lock);
  	orig_div = data->fan_div[nr];
  	data->fan_div[nr] = DIV_FROM_REG(new_div);
  
  	if (nr < 4) { /* 0 <= nr < 4 */
+ 		shift = 2 * nr;
  		adm1026_write_value(client, ADM1026_REG_FAN_DIV_0_3,
! 			((DIV_TO_REG(orig_div) & (~(0x03 << shift))) |
! 			(new_div << shift)));
  	} else { /* 3 < nr < 8 */
+ 		shift = 2 * (nr - 4);
  		adm1026_write_value(client, ADM1026_REG_FAN_DIV_4_7,
! 			((DIV_TO_REG(orig_div) & (~(0x03 << (2 * shift)))) |
! 			(new_div << shift)));
  	}
  
  	if (data->fan_div[nr] != orig_div) {
diff -cBr 2.6.35/drivers/hwmon/f71882fg.c linux-2.6.35.y-512ac85/drivers/hwmon/f71882fg.c
*** 2.6.35/drivers/hwmon/f71882fg.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/f71882fg.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2100,2105 ****
--- 2100,2106 ----
  	int nr_fans = (data->type == f71882fg) ? 4 : 3;
  	u8 start_reg = f71882fg_read8(data, F71882FG_REG_START);
  
+ 	platform_set_drvdata(pdev, NULL);
  	if (data->hwmon_dev)
  		hwmon_device_unregister(data->hwmon_dev);
  
***************
*** 2166,2172 ****
  		}
  	}
  
- 	platform_set_drvdata(pdev, NULL);
  	kfree(data);
  
  	return 0;
--- 2167,2172 ----
diff -cBr 2.6.35/drivers/hwmon/lm85.c linux-2.6.35.y-512ac85/drivers/hwmon/lm85.c
*** 2.6.35/drivers/hwmon/lm85.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/lm85.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1259,1265 ****
  	switch (data->type) {
  	case adm1027:
  	case adt7463:
- 	case adt7468:
  	case emc6d100:
  	case emc6d102:
  		data->freq_map = adm1027_freq_map;
--- 1259,1264 ----
diff -cBr 2.6.35/drivers/hwmon/sht15.c linux-2.6.35.y-512ac85/drivers/hwmon/sht15.c
*** 2.6.35/drivers/hwmon/sht15.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/sht15.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 333,343 ****
  
  	const int c1 = -4;
  	const int c2 = 40500; /* x 10 ^ -6 */
! 	const int c3 = -28; /* x 10 ^ -7 */
  
  	RHlinear = c1*1000
  		+ c2 * data->val_humid/1000
! 		+ (data->val_humid * data->val_humid * c3) / 10000;
  	return (temp - 25000) * (10000 + 80 * data->val_humid)
  		/ 1000000 + RHlinear;
  }
--- 333,343 ----
  
  	const int c1 = -4;
  	const int c2 = 40500; /* x 10 ^ -6 */
! 	const int c3 = -2800; /* x10 ^ -9 */
  
  	RHlinear = c1*1000
  		+ c2 * data->val_humid/1000
! 		+ (data->val_humid * data->val_humid * c3)/1000000;
  	return (temp - 25000) * (10000 + 80 * data->val_humid)
  		/ 1000000 + RHlinear;
  }
diff -cBr 2.6.35/drivers/hwmon/via686a.c linux-2.6.35.y-512ac85/drivers/hwmon/via686a.c
*** 2.6.35/drivers/hwmon/via686a.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/via686a.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 687,699 ****
  	return 0;
  }
  
- static void via686a_update_fan_div(struct via686a_data *data)
- {
- 	int reg = via686a_read_value(data, VIA686A_REG_FANDIV);
- 	data->fan_div[0] = (reg >> 4) & 0x03;
- 	data->fan_div[1] = reg >> 6;
- }
- 
  static void __devinit via686a_init_device(struct via686a_data *data)
  {
  	u8 reg;
--- 687,692 ----
***************
*** 707,715 ****
  	via686a_write_value(data, VIA686A_REG_TEMP_MODE,
  			    (reg & ~VIA686A_TEMP_MODE_MASK)
  			    | VIA686A_TEMP_MODE_CONTINUOUS);
- 
- 	/* Pre-read fan clock divisor values */
- 	via686a_update_fan_div(data);
  }
  
  static struct via686a_data *via686a_update_device(struct device *dev)
--- 700,705 ----
***************
*** 761,767 ****
  		    (via686a_read_value(data, VIA686A_REG_TEMP_LOW23) &
  		     0xc0) >> 6;
  
! 		via686a_update_fan_div(data);
  		data->alarms =
  		    via686a_read_value(data,
  				       VIA686A_REG_ALARM1) |
--- 751,759 ----
  		    (via686a_read_value(data, VIA686A_REG_TEMP_LOW23) &
  		     0xc0) >> 6;
  
! 		i = via686a_read_value(data, VIA686A_REG_FANDIV);
! 		data->fan_div[0] = (i >> 4) & 0x03;
! 		data->fan_div[1] = i >> 6;
  		data->alarms =
  		    via686a_read_value(data,
  				       VIA686A_REG_ALARM1) |
diff -cBr 2.6.35/drivers/hwmon/w83627ehf.c linux-2.6.35.y-512ac85/drivers/hwmon/w83627ehf.c
*** 2.6.35/drivers/hwmon/w83627ehf.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/hwmon/w83627ehf.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 277,287 ****
  	struct device *hwmon_dev;
  	struct mutex lock;
  
- 	const u8 *REG_FAN_START_OUTPUT;
- 	const u8 *REG_FAN_STOP_OUTPUT;
- 	const u8 *REG_FAN_MAX_OUTPUT;
- 	const u8 *REG_FAN_STEP_OUTPUT;
- 
  	struct mutex update_lock;
  	char valid;		/* !=0 if following fields are valid */
  	unsigned long last_updated;	/* In jiffies */
--- 277,282 ----
***************
*** 529,538 ****
  			}
  		}
  
! 		for (i = 0; i < data->pwm_num; i++) {
! 			if (!(data->has_fan & (1 << i)))
! 				continue;
! 
  			/* pwmcfg, tolerance mapped for i=0, i=1 to same reg */
  			if (i != 1) {
  				pwmcfg = w83627ehf_read_value(data,
--- 524,530 ----
  			}
  		}
  
! 		for (i = 0; i < 4; i++) {
  			/* pwmcfg, tolerance mapped for i=0, i=1 to same reg */
  			if (i != 1) {
  				pwmcfg = w83627ehf_read_value(data,
***************
*** 554,570 ****
  						W83627EHF_REG_FAN_STOP_OUTPUT[i]);
  			data->fan_stop_time[i] = w83627ehf_read_value(data,
  						W83627EHF_REG_FAN_STOP_TIME[i]);
- 
- 			if (data->REG_FAN_MAX_OUTPUT[i] != 0xff)
- 				data->fan_max_output[i] =
- 				  w83627ehf_read_value(data,
- 					       data->REG_FAN_MAX_OUTPUT[i]);
- 
- 			if (data->REG_FAN_STEP_OUTPUT[i] != 0xff)
- 				data->fan_step_output[i] =
- 				  w83627ehf_read_value(data,
- 					       data->REG_FAN_STEP_OUTPUT[i]);
- 
  			data->target_temp[i] =
  				w83627ehf_read_value(data,
  					W83627EHF_REG_TARGET[i]) &
--- 546,551 ----
***************
*** 1145,1151 ****
  	u32 val = SENSORS_LIMIT(simple_strtoul(buf, NULL, 10), 1, 255); \
  	mutex_lock(&data->update_lock); \
  	data->reg[nr] = val; \
! 	w83627ehf_write_value(data, data->REG_##REG[nr], val); \
  	mutex_unlock(&data->update_lock); \
  	return count; \
  }
--- 1126,1132 ----
  	u32 val = SENSORS_LIMIT(simple_strtoul(buf, NULL, 10), 1, 255); \
  	mutex_lock(&data->update_lock); \
  	data->reg[nr] = val; \
! 	w83627ehf_write_value(data, W83627EHF_REG_##REG[nr], val); \
  	mutex_unlock(&data->update_lock); \
  	return count; \
  }
***************
*** 1225,1250 ****
  		    store_fan_stop_output, 1),
  	SENSOR_ATTR(pwm3_stop_output, S_IWUSR | S_IRUGO, show_fan_stop_output,
  		    store_fan_stop_output, 2),
- };
  
! 
! /*
!  * pwm1 and pwm3 don't support max and step settings on all chips.
!  * Need to check support while generating/removing attribute files.
!  */
! static struct sensor_device_attribute sda_sf3_max_step_arrays[] = {
! 	SENSOR_ATTR(pwm1_max_output, S_IWUSR | S_IRUGO, show_fan_max_output,
! 		    store_fan_max_output, 0),
! 	SENSOR_ATTR(pwm1_step_output, S_IWUSR | S_IRUGO, show_fan_step_output,
! 		    store_fan_step_output, 0),
  	SENSOR_ATTR(pwm2_max_output, S_IWUSR | S_IRUGO, show_fan_max_output,
  		    store_fan_max_output, 1),
  	SENSOR_ATTR(pwm2_step_output, S_IWUSR | S_IRUGO, show_fan_step_output,
  		    store_fan_step_output, 1),
- 	SENSOR_ATTR(pwm3_max_output, S_IWUSR | S_IRUGO, show_fan_max_output,
- 		    store_fan_max_output, 2),
- 	SENSOR_ATTR(pwm3_step_output, S_IWUSR | S_IRUGO, show_fan_step_output,
- 		    store_fan_step_output, 2),
  };
  
  static ssize_t
--- 1206,1217 ----
  		    store_fan_stop_output, 1),
  	SENSOR_ATTR(pwm3_stop_output, S_IWUSR | S_IRUGO, show_fan_stop_output,
  		    store_fan_stop_output, 2),
  
! 	/* pwm1 and pwm3 don't support max and step settings */
  	SENSOR_ATTR(pwm2_max_output, S_IWUSR | S_IRUGO, show_fan_max_output,
  		    store_fan_max_output, 1),
  	SENSOR_ATTR(pwm2_step_output, S_IWUSR | S_IRUGO, show_fan_step_output,
  		    store_fan_step_output, 1),
  };
  
  static ssize_t
***************
*** 1268,1279 ****
  
  	for (i = 0; i < ARRAY_SIZE(sda_sf3_arrays); i++)
  		device_remove_file(dev, &sda_sf3_arrays[i].dev_attr);
- 	for (i = 0; i < ARRAY_SIZE(sda_sf3_max_step_arrays); i++) {
- 		struct sensor_device_attribute *attr =
- 		  &sda_sf3_max_step_arrays[i];
- 		if (data->REG_FAN_STEP_OUTPUT[attr->index] != 0xff)
- 			device_remove_file(dev, &attr->dev_attr);
- 	}
  	for (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan4); i++)
  		device_remove_file(dev, &sda_sf3_arrays_fan4[i].dev_attr);
  	for (i = 0; i < data->in_num; i++) {
--- 1235,1240 ----
***************
*** 1391,1401 ****
  		data->in6_skip = !data->temp3_disable;
  	}
  
- 	data->REG_FAN_START_OUTPUT = W83627EHF_REG_FAN_START_OUTPUT;
- 	data->REG_FAN_STOP_OUTPUT = W83627EHF_REG_FAN_STOP_OUTPUT;
- 	data->REG_FAN_MAX_OUTPUT = W83627EHF_REG_FAN_MAX_OUTPUT;
- 	data->REG_FAN_STEP_OUTPUT = W83627EHF_REG_FAN_STEP_OUTPUT;
- 
  	/* Initialize the chip */
  	w83627ehf_init_device(data);
  
--- 1352,1357 ----
***************
*** 1484,1498 ****
  			&sda_sf3_arrays[i].dev_attr)))
  			goto exit_remove;
  
- 	for (i = 0; i < ARRAY_SIZE(sda_sf3_max_step_arrays); i++) {
- 		struct sensor_device_attribute *attr =
- 		  &sda_sf3_max_step_arrays[i];
- 		if (data->REG_FAN_STEP_OUTPUT[attr->index] != 0xff) {
- 			err = device_create_file(dev, &attr->dev_attr);
- 			if (err)
- 				goto exit_remove;
- 		}
- 	}
  	/* if fan4 is enabled create the sf3 files for it */
  	if ((data->has_fan & (1 << 3)) && data->pwm_num >= 4)
  		for (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan4); i++) {
--- 1440,1445 ----
diff -cBr 2.6.35/drivers/i2c/busses/i2c-pca-platform.c linux-2.6.35.y-512ac85/drivers/i2c/busses/i2c-pca-platform.c
*** 2.6.35/drivers/i2c/busses/i2c-pca-platform.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/i2c/busses/i2c-pca-platform.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 224,230 ****
  
  	if (irq) {
  		ret = request_irq(irq, i2c_pca_pf_handler,
! 			IRQF_TRIGGER_FALLING, pdev->name, i2c);
  		if (ret)
  			goto e_reqirq;
  	}
--- 224,230 ----
  
  	if (irq) {
  		ret = request_irq(irq, i2c_pca_pf_handler,
! 			IRQF_TRIGGER_FALLING, i2c->adap.name, i2c);
  		if (ret)
  			goto e_reqirq;
  	}
diff -cBr 2.6.35/drivers/i2c/i2c-core.c linux-2.6.35.y-512ac85/drivers/i2c/i2c-core.c
*** 2.6.35/drivers/i2c/i2c-core.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/i2c/i2c-core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 923,936 ****
  static int __unregister_client(struct device *dev, void *dummy)
  {
  	struct i2c_client *client = i2c_verify_client(dev);
- 	if (client && strcmp(client->name, "dummy"))
- 		i2c_unregister_device(client);
- 	return 0;
- }
- 
- static int __unregister_dummy(struct device *dev, void *dummy)
- {
- 	struct i2c_client *client = i2c_verify_client(dev);
  	if (client)
  		i2c_unregister_device(client);
  	return 0;
--- 923,928 ----
***************
*** 985,996 ****
  	i2c_unlock_adapter(adap);
  
  	/* Detach any active clients. This can't fail, thus we do not
! 	 * check the returned value. This is a two-pass process, because
! 	 * we can't remove the dummy devices during the first pass: they
! 	 * could have been instantiated by real devices wishing to clean
! 	 * them up properly, so we give them a chance to do that first. */
  	res = device_for_each_child(&adap->dev, NULL, __unregister_client);
- 	res = device_for_each_child(&adap->dev, NULL, __unregister_dummy);
  
  #ifdef CONFIG_I2C_COMPAT
  	class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,
--- 977,984 ----
  	i2c_unlock_adapter(adap);
  
  	/* Detach any active clients. This can't fail, thus we do not
! 	   checking the returned value. */
  	res = device_for_each_child(&adap->dev, NULL, __unregister_client);
  
  #ifdef CONFIG_I2C_COMPAT
  	class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,
diff -cBr 2.6.35/drivers/infiniband/core/cma.c linux-2.6.35.y-512ac85/drivers/infiniband/core/cma.c
*** 2.6.35/drivers/infiniband/core/cma.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/infiniband/core/cma.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1136,1146 ****
  	cm_id->context = conn_id;
  	cm_id->cm_handler = cma_ib_handler;
  
- 	/*
- 	 * Protect against the user destroying conn_id from another thread
- 	 * until we're done accessing it.
- 	 */
- 	atomic_inc(&conn_id->refcount);
  	ret = conn_id->id.event_handler(&conn_id->id, &event);
  	if (!ret) {
  		/*
--- 1136,1141 ----
***************
*** 1153,1162 ****
  			ib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);
  		mutex_unlock(&lock);
  		mutex_unlock(&conn_id->handler_mutex);
- 		cma_deref_id(conn_id);
  		goto out;
  	}
- 	cma_deref_id(conn_id);
  
  	/* Destroy the CM ID by returning a non-zero value. */
  	conn_id->cm_id.ib = NULL;
--- 1148,1155 ----
***************
*** 1358,1382 ****
  	event.param.conn.private_data_len = iw_event->private_data_len;
  	event.param.conn.initiator_depth = attr.max_qp_init_rd_atom;
  	event.param.conn.responder_resources = attr.max_qp_rd_atom;
- 
- 	/*
- 	 * Protect against the user destroying conn_id from another thread
- 	 * until we're done accessing it.
- 	 */
- 	atomic_inc(&conn_id->refcount);
  	ret = conn_id->id.event_handler(&conn_id->id, &event);
  	if (ret) {
  		/* User wants to destroy the CM ID */
  		conn_id->cm_id.iw = NULL;
  		cma_exch(conn_id, CMA_DESTROYING);
  		mutex_unlock(&conn_id->handler_mutex);
- 		cma_deref_id(conn_id);
  		rdma_destroy_id(&conn_id->id);
  		goto out;
  	}
  
  	mutex_unlock(&conn_id->handler_mutex);
- 	cma_deref_id(conn_id);
  
  out:
  	if (dev)
--- 1351,1367 ----
diff -cBr 2.6.35/drivers/infiniband/core/cm.c linux-2.6.35.y-512ac85/drivers/infiniband/core/cm.c
*** 2.6.35/drivers/infiniband/core/cm.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/infiniband/core/cm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2987,2993 ****
  		goto out; /* No match. */
  	}
  	atomic_inc(&cur_cm_id_priv->refcount);
- 	atomic_inc(&cm_id_priv->refcount);
  	spin_unlock_irq(&cm.lock);
  
  	cm_id_priv->id.cm_handler = cur_cm_id_priv->id.cm_handler;
--- 2987,2992 ----
diff -cBr 2.6.35/drivers/infiniband/core/uverbs_cmd.c linux-2.6.35.y-512ac85/drivers/infiniband/core/uverbs_cmd.c
*** 2.6.35/drivers/infiniband/core/uverbs_cmd.c	2011-05-07 19:57:18.366750002 -0400
--- linux-2.6.35.y-512ac85/drivers/infiniband/core/uverbs_cmd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 891,971 ****
  	return ret ? ret : in_len;
  }
  
- static int copy_wc_to_user(void __user *dest, struct ib_wc *wc)
- {
- 	struct ib_uverbs_wc tmp;
- 
- 	tmp.wr_id		= wc->wr_id;
- 	tmp.status		= wc->status;
- 	tmp.opcode		= wc->opcode;
- 	tmp.vendor_err		= wc->vendor_err;
- 	tmp.byte_len		= wc->byte_len;
- 	tmp.ex.imm_data		= (__u32 __force) wc->ex.imm_data;
- 	tmp.qp_num		= wc->qp->qp_num;
- 	tmp.src_qp		= wc->src_qp;
- 	tmp.wc_flags		= wc->wc_flags;
- 	tmp.pkey_index		= wc->pkey_index;
- 	tmp.slid		= wc->slid;
- 	tmp.sl			= wc->sl;
- 	tmp.dlid_path_bits	= wc->dlid_path_bits;
- 	tmp.port_num		= wc->port_num;
- 	tmp.reserved		= 0;
- 
- 	if (copy_to_user(dest, &tmp, sizeof tmp))
- 		return -EFAULT;
- 
- 	return 0;
- }
- 
  ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,
  			  const char __user *buf, int in_len,
  			  int out_len)
  {
  	struct ib_uverbs_poll_cq       cmd;
! 	struct ib_uverbs_poll_cq_resp  resp;
! 	u8 __user                     *header_ptr;
! 	u8 __user                     *data_ptr;
  	struct ib_cq                  *cq;
! 	struct ib_wc                   wc;
! 	int                            ret;
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
  	cq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);
! 	if (!cq)
! 		return -EINVAL;
  
! 	/* we copy a struct ib_uverbs_poll_cq_resp to user space */
! 	header_ptr = (void __user *)(unsigned long) cmd.response;
! 	data_ptr = header_ptr + sizeof resp;
! 
! 	memset(&resp, 0, sizeof resp);
! 	while (resp.count < cmd.ne) {
! 		ret = ib_poll_cq(cq, 1, &wc);
! 		if (ret < 0)
! 			goto out_put;
! 		if (!ret)
! 			break;
! 
! 		ret = copy_wc_to_user(data_ptr, &wc);
! 		if (ret)
! 			goto out_put;
  
! 		data_ptr += sizeof(struct ib_uverbs_wc);
! 		++resp.count;
  	}
  
! 	if (copy_to_user(header_ptr, &resp, sizeof resp)) {
  		ret = -EFAULT;
- 		goto out_put;
- 	}
  
! 	ret = in_len;
  
! out_put:
! 	put_cq_read(cq);
! 	return ret;
  }
  
  ssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,
--- 891,958 ----
  	return ret ? ret : in_len;
  }
  
  ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,
  			  const char __user *buf, int in_len,
  			  int out_len)
  {
  	struct ib_uverbs_poll_cq       cmd;
! 	struct ib_uverbs_poll_cq_resp *resp;
  	struct ib_cq                  *cq;
! 	struct ib_wc                  *wc;
! 	int                            ret = 0;
! 	int                            i;
! 	int                            rsize;
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
+ 	wc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);
+ 	if (!wc)
+ 		return -ENOMEM;
+ 
+ 	rsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);
+ 	resp = kmalloc(rsize, GFP_KERNEL);
+ 	if (!resp) {
+ 		ret = -ENOMEM;
+ 		goto out_wc;
+ 	}
+ 
  	cq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);
! 	if (!cq) {
! 		ret = -EINVAL;
! 		goto out;
! 	}
  
! 	resp->count = ib_poll_cq(cq, cmd.ne, wc);
! 
! 	put_cq_read(cq);
  
! 	for (i = 0; i < resp->count; i++) {
! 		resp->wc[i].wr_id 	   = wc[i].wr_id;
! 		resp->wc[i].status 	   = wc[i].status;
! 		resp->wc[i].opcode 	   = wc[i].opcode;
! 		resp->wc[i].vendor_err 	   = wc[i].vendor_err;
! 		resp->wc[i].byte_len 	   = wc[i].byte_len;
! 		resp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;
! 		resp->wc[i].qp_num 	   = wc[i].qp->qp_num;
! 		resp->wc[i].src_qp 	   = wc[i].src_qp;
! 		resp->wc[i].wc_flags 	   = wc[i].wc_flags;
! 		resp->wc[i].pkey_index 	   = wc[i].pkey_index;
! 		resp->wc[i].slid 	   = wc[i].slid;
! 		resp->wc[i].sl 		   = wc[i].sl;
! 		resp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;
! 		resp->wc[i].port_num 	   = wc[i].port_num;
  	}
  
! 	if (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))
  		ret = -EFAULT;
  
! out:
! 	kfree(resp);
  
! out_wc:
! 	kfree(wc);
! 	return ret ? ret : in_len;
  }
  
  ssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,
Only in 2.6.35/drivers/input/keyboard: cypress-touchkey.c
Only in 2.6.35/drivers/input/keyboard: cypress-touchkey-firmware.c
Only in 2.6.35/drivers/input/keyboard: cypress-touchkey-firmware.h
Only in 2.6.35/drivers/input: keyreset.c
Only in 2.6.35/drivers/input/misc: bma023.c
Only in 2.6.35/drivers/input/misc: gp2a.c
Only in 2.6.35/drivers/input/misc: gpio_axis.c
Only in 2.6.35/drivers/input/misc: gpio_event.c
Only in 2.6.35/drivers/input/misc: gpio_input.c
Only in 2.6.35/drivers/input/misc: gpio_matrix.c
Only in 2.6.35/drivers/input/misc: gpio_output.c
Only in 2.6.35/drivers/input/misc: k3g.c
Only in 2.6.35/drivers/input/misc: keychord.c
Only in 2.6.35/drivers/input/misc: orientation.c
Only in 2.6.35/drivers/input/misc: yas529.c
Only in 2.6.35/drivers/input/misc: yas529_const.h
Only in 2.6.35/drivers/input/misc: yas529.h
diff -cBr 2.6.35/drivers/input/mouse/bcm5974.c linux-2.6.35.y-512ac85/drivers/input/mouse/bcm5974.c
*** 2.6.35/drivers/input/mouse/bcm5974.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/mouse/bcm5974.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 55,68 ****
  #define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI	0x0236
  #define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO	0x0237
  #define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS	0x0238
- /* MacbookAir3,2 (unibody), aka wellspring5 */
- #define USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI	0x023f
- #define USB_DEVICE_ID_APPLE_WELLSPRING4_ISO	0x0240
- #define USB_DEVICE_ID_APPLE_WELLSPRING4_JIS	0x0241
- /* MacbookAir3,1 (unibody), aka wellspring4 */
- #define USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI	0x0242
- #define USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO	0x0243
- #define USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS	0x0244
  
  #define BCM5974_DEVICE(prod) {					\
  	.match_flags = (USB_DEVICE_ID_MATCH_DEVICE |		\
--- 55,60 ----
***************
*** 88,101 ****
  	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI),
  	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING3_ISO),
  	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING3_JIS),
- 	/* MacbookAir3,2 */
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI),
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4_ISO),
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4_JIS),
- 	/* MacbookAir3,1 */
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI),
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO),
- 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS),
  	/* Terminating entry */
  	{}
  };
--- 80,85 ----
***************
*** 250,279 ****
  		{ DIM_X, DIM_X / SN_COORD, -4460, 5166 },
  		{ DIM_Y, DIM_Y / SN_COORD, -75, 6700 }
  	},
- 	{
- 		USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI,
- 		USB_DEVICE_ID_APPLE_WELLSPRING4_ISO,
- 		USB_DEVICE_ID_APPLE_WELLSPRING4_JIS,
- 		HAS_INTEGRATED_BUTTON,
- 		0x84, sizeof(struct bt_data),
- 		0x81, TYPE2, FINGER_TYPE2, FINGER_TYPE2 + SIZEOF_ALL_FINGERS,
- 		{ DIM_PRESSURE, DIM_PRESSURE / SN_PRESSURE, 0, 300 },
- 		{ DIM_WIDTH, DIM_WIDTH / SN_WIDTH, 0, 2048 },
- 		{ DIM_X, DIM_X / SN_COORD, -4620, 5140 },
- 		{ DIM_Y, DIM_Y / SN_COORD, -150, 6600 }
- 	},
- 	{
- 		USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI,
- 		USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO,
- 		USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS,
- 		HAS_INTEGRATED_BUTTON,
- 		0x84, sizeof(struct bt_data),
- 		0x81, TYPE2, FINGER_TYPE2, FINGER_TYPE2 + SIZEOF_ALL_FINGERS,
- 		{ DIM_PRESSURE, DIM_PRESSURE / SN_PRESSURE, 0, 300 },
- 		{ DIM_WIDTH, DIM_WIDTH / SN_WIDTH, 0, 2048 },
- 		{ DIM_X, DIM_X / SN_COORD, -4616, 5112 },
- 		{ DIM_Y, DIM_Y / SN_COORD, -142, 5234 }
- 	},
  	{}
  };
  
--- 234,239 ----
diff -cBr 2.6.35/drivers/input/mouse/synaptics.c linux-2.6.35.y-512ac85/drivers/input/mouse/synaptics.c
*** 2.6.35/drivers/input/mouse/synaptics.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/mouse/synaptics.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 712,719 ****
  		},
  
  	},
- #endif
  	{ }
  };
  
  void __init synaptics_module_init(void)
--- 712,719 ----
  		},
  
  	},
  	{ }
+ #endif
  };
  
  void __init synaptics_module_init(void)
diff -cBr 2.6.35/drivers/input/mouse/synaptics.h linux-2.6.35.y-512ac85/drivers/input/mouse/synaptics.h
*** 2.6.35/drivers/input/mouse/synaptics.h	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/mouse/synaptics.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 51,58 ****
  #define SYN_EXT_CAP_REQUESTS(c)		(((c) & 0x700000) >> 20)
  #define SYN_CAP_MULTI_BUTTON_NO(ec)	(((ec) & 0x00f000) >> 12)
  #define SYN_CAP_PRODUCT_ID(ec)		(((ec) & 0xff0000) >> 16)
! #define SYN_CAP_CLICKPAD(ex0c)		((ex0c) & 0x100000) /* 1-button ClickPad */
! #define SYN_CAP_CLICKPAD2BTN(ex0c)	((ex0c) & 0x000100) /* 2-button ClickPad */
  #define SYN_CAP_MAX_DIMENSIONS(ex0c)	((ex0c) & 0x020000)
  
  /* synaptics modes query bits */
--- 51,57 ----
  #define SYN_EXT_CAP_REQUESTS(c)		(((c) & 0x700000) >> 20)
  #define SYN_CAP_MULTI_BUTTON_NO(ec)	(((ec) & 0x00f000) >> 12)
  #define SYN_CAP_PRODUCT_ID(ec)		(((ec) & 0xff0000) >> 16)
! #define SYN_CAP_CLICKPAD(ex0c)		((ex0c) & 0x100100)
  #define SYN_CAP_MAX_DIMENSIONS(ex0c)	((ex0c) & 0x020000)
  
  /* synaptics modes query bits */
diff -cBr 2.6.35/drivers/input/serio/i8042.c linux-2.6.35.y-512ac85/drivers/input/serio/i8042.c
*** 2.6.35/drivers/input/serio/i8042.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/serio/i8042.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 65,74 ****
  module_param_named(panicblink, i8042_blink_frequency, uint, 0600);
  MODULE_PARM_DESC(panicblink, "Frequency with which keyboard LEDs should blink when kernel panics");
  
- static bool i8042_notimeout;
- module_param_named(notimeout, i8042_notimeout, bool, 0);
- MODULE_PARM_DESC(notimeout, "Ignore timeouts signalled by i8042");
- 
  #ifdef CONFIG_X86
  static bool i8042_dritek;
  module_param_named(dritek, i8042_dritek, bool, 0);
--- 65,70 ----
***************
*** 511,517 ****
  	} else {
  
  		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
! 		      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);
  
  		port_no = (str & I8042_STR_AUXDATA) ?
  				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
--- 507,513 ----
  	} else {
  
  		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
! 		      ((str & I8042_STR_TIMEOUT) ? SERIO_TIMEOUT : 0);
  
  		port_no = (str & I8042_STR_AUXDATA) ?
  				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
diff -cBr 2.6.35/drivers/input/serio/i8042-x86ia64io.h linux-2.6.35.y-512ac85/drivers/input/serio/i8042-x86ia64io.h
*** 2.6.35/drivers/input/serio/i8042-x86ia64io.h	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/serio/i8042-x86ia64io.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 333,345 ****
  		},
  	},
  	{
- 		/* Sony Vaio VPCZ122GX */
- 		.matches = {
- 			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
- 			DMI_MATCH(DMI_PRODUCT_NAME, "VPCZ122GX"),
- 		},
- 	},
- 	{
  		/* Sony Vaio FS-115b */
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
--- 333,338 ----
***************
*** 420,432 ****
  			DMI_MATCH(DMI_PRODUCT_VERSION, "0100"),
  		},
  	},
- 	{
- 		/* Dell Vostro V13 */
- 		.matches = {
- 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
- 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro V13"),
- 		},
- 	},
  	{ }
  };
  
--- 413,418 ----
***************
*** 548,564 ****
  };
  #endif
  
- static const struct dmi_system_id __initconst i8042_dmi_notimeout_table[] = {
- 	{
- 		/* Dell Vostro V13 */
- 		.matches = {
- 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
- 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro V13"),
- 		},
- 	},
- 	{ }
- };
- 
  /*
   * Some Wistron based laptops need us to explicitly enable the 'Dritek
   * keyboard extension' to make their extra keys start generating scancodes.
--- 534,539 ----
***************
*** 911,919 ****
  	if (dmi_check_system(i8042_dmi_nomux_table))
  		i8042_nomux = true;
  
- 	if (dmi_check_system(i8042_dmi_notimeout_table))
- 		i8042_notimeout = true;
- 
  	if (dmi_check_system(i8042_dmi_dritek_table))
  		i8042_dritek = true;
  #endif /* CONFIG_X86 */
--- 886,891 ----
Only in 2.6.35/drivers/input/touchscreen: mxt224.c
Only in 2.6.35/drivers/input/touchscreen: synaptics_i2c_rmi.c
diff -cBr 2.6.35/drivers/input/xen-kbdfront.c linux-2.6.35.y-512ac85/drivers/input/xen-kbdfront.c
*** 2.6.35/drivers/input/xen-kbdfront.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/input/xen-kbdfront.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 109,115 ****
  static int __devinit xenkbd_probe(struct xenbus_device *dev,
  				  const struct xenbus_device_id *id)
  {
! 	int ret, i, abs;
  	struct xenkbd_info *info;
  	struct input_dev *kbd, *ptr;
  
--- 109,115 ----
  static int __devinit xenkbd_probe(struct xenbus_device *dev,
  				  const struct xenbus_device_id *id)
  {
! 	int ret, i;
  	struct xenkbd_info *info;
  	struct input_dev *kbd, *ptr;
  
***************
*** 127,137 ****
  	if (!info->page)
  		goto error_nomem;
  
- 	if (xenbus_scanf(XBT_NIL, dev->otherend, "feature-abs-pointer", "%d", &abs) < 0)
- 		abs = 0;
- 	if (abs)
- 		xenbus_printf(XBT_NIL, dev->nodename, "request-abs-pointer", "1");
- 
  	/* keyboard */
  	kbd = input_allocate_device();
  	if (!kbd)
--- 127,132 ----
***************
*** 141,152 ****
  	kbd->id.bustype = BUS_PCI;
  	kbd->id.vendor = 0x5853;
  	kbd->id.product = 0xffff;
! 
! 	__set_bit(EV_KEY, kbd->evbit);
  	for (i = KEY_ESC; i < KEY_UNKNOWN; i++)
! 		__set_bit(i, kbd->keybit);
  	for (i = KEY_OK; i < KEY_MAX; i++)
! 		__set_bit(i, kbd->keybit);
  
  	ret = input_register_device(kbd);
  	if (ret) {
--- 136,146 ----
  	kbd->id.bustype = BUS_PCI;
  	kbd->id.vendor = 0x5853;
  	kbd->id.product = 0xffff;
! 	kbd->evbit[0] = BIT(EV_KEY);
  	for (i = KEY_ESC; i < KEY_UNKNOWN; i++)
! 		set_bit(i, kbd->keybit);
  	for (i = KEY_OK; i < KEY_MAX; i++)
! 		set_bit(i, kbd->keybit);
  
  	ret = input_register_device(kbd);
  	if (ret) {
***************
*** 165,184 ****
  	ptr->id.bustype = BUS_PCI;
  	ptr->id.vendor = 0x5853;
  	ptr->id.product = 0xfffe;
! 
! 	if (abs) {
! 		__set_bit(EV_ABS, ptr->evbit);
! 		input_set_abs_params(ptr, ABS_X, 0, XENFB_WIDTH, 0, 0);
! 		input_set_abs_params(ptr, ABS_Y, 0, XENFB_HEIGHT, 0, 0);
! 	} else {
! 		input_set_capability(ptr, EV_REL, REL_X);
! 		input_set_capability(ptr, EV_REL, REL_Y);
! 	}
! 	input_set_capability(ptr, EV_REL, REL_WHEEL);
! 
! 	__set_bit(EV_KEY, ptr->evbit);
  	for (i = BTN_LEFT; i <= BTN_TASK; i++)
! 		__set_bit(i, ptr->keybit);
  
  	ret = input_register_device(ptr);
  	if (ret) {
--- 159,170 ----
  	ptr->id.bustype = BUS_PCI;
  	ptr->id.vendor = 0x5853;
  	ptr->id.product = 0xfffe;
! 	ptr->evbit[0] = BIT(EV_KEY) | BIT(EV_REL) | BIT(EV_ABS);
  	for (i = BTN_LEFT; i <= BTN_TASK; i++)
! 		set_bit(i, ptr->keybit);
! 	ptr->relbit[0] = BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL);
! 	input_set_abs_params(ptr, ABS_X, 0, XENFB_WIDTH, 0, 0);
! 	input_set_abs_params(ptr, ABS_Y, 0, XENFB_HEIGHT, 0, 0);
  
  	ret = input_register_device(ptr);
  	if (ret) {
***************
*** 285,291 ****
  				   enum xenbus_state backend_state)
  {
  	struct xenkbd_info *info = dev_get_drvdata(&dev->dev);
! 	int val;
  
  	switch (backend_state) {
  	case XenbusStateInitialising:
--- 271,277 ----
  				   enum xenbus_state backend_state)
  {
  	struct xenkbd_info *info = dev_get_drvdata(&dev->dev);
! 	int ret, val;
  
  	switch (backend_state) {
  	case XenbusStateInitialising:
***************
*** 296,301 ****
--- 282,298 ----
  
  	case XenbusStateInitWait:
  InitWait:
+ 		ret = xenbus_scanf(XBT_NIL, info->xbdev->otherend,
+ 				   "feature-abs-pointer", "%d", &val);
+ 		if (ret < 0)
+ 			val = 0;
+ 		if (val) {
+ 			ret = xenbus_printf(XBT_NIL, info->xbdev->nodename,
+ 					    "request-abs-pointer", "1");
+ 			if (ret)
+ 				printk(KERN_WARNING
+ 				       "xenkbd: can't request abs-pointer");
+ 		}
  		xenbus_switch_state(dev, XenbusStateConnected);
  		break;
  
diff -cBr 2.6.35/drivers/isdn/gigaset/bas-gigaset.c linux-2.6.35.y-512ac85/drivers/isdn/gigaset/bas-gigaset.c
*** 2.6.35/drivers/isdn/gigaset/bas-gigaset.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/isdn/gigaset/bas-gigaset.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 438,464 ****
  		return;
  	}
  
! 	if (ucs->retry_cmd_in++ >= BAS_RETRY) {
  		dev_err(cs->dev,
  			"control read: timeout, giving up after %d tries\n",
  			ucs->retry_cmd_in);
- 		kfree(ucs->rcvbuf);
- 		ucs->rcvbuf = NULL;
- 		ucs->rcvbuf_size = 0;
- 		error_reset(cs);
- 		return;
- 	}
- 
- 	gig_dbg(DEBUG_USBREQ, "%s: timeout, retry %d",
- 		__func__, ucs->retry_cmd_in);
- 	rc = atread_submit(cs, BAS_TIMEOUT);
- 	if (rc < 0) {
- 		kfree(ucs->rcvbuf);
- 		ucs->rcvbuf = NULL;
- 		ucs->rcvbuf_size = 0;
- 		if (rc != -ENODEV)
- 			error_reset(cs);
  	}
  }
  
  /* read_ctrl_callback
--- 438,460 ----
  		return;
  	}
  
! 	if (ucs->retry_cmd_in++ < BAS_RETRY) {
! 		dev_notice(cs->dev, "control read: timeout, retry %d\n",
! 			   ucs->retry_cmd_in);
! 		rc = atread_submit(cs, BAS_TIMEOUT);
! 		if (rc >= 0 || rc == -ENODEV)
! 			/* resubmitted or disconnected */
! 			/* - bypass regular exit block */
! 			return;
! 	} else {
  		dev_err(cs->dev,
  			"control read: timeout, giving up after %d tries\n",
  			ucs->retry_cmd_in);
  	}
+ 	kfree(ucs->rcvbuf);
+ 	ucs->rcvbuf = NULL;
+ 	ucs->rcvbuf_size = 0;
+ 	error_reset(cs);
  }
  
  /* read_ctrl_callback
***************
*** 474,484 ****
--- 470,487 ----
  	struct cardstate *cs = inbuf->cs;
  	struct bas_cardstate *ucs = cs->hw.bas;
  	int status = urb->status;
+ 	int have_data = 0;
  	unsigned numbytes;
  	int rc;
  
  	update_basstate(ucs, 0, BS_ATRDPEND);
  	wake_up(&ucs->waitqueue);
+ 
+ 	if (!ucs->rcvbuf_size) {
+ 		dev_warn(cs->dev, "%s: no receive in progress\n", __func__);
+ 		return;
+ 	}
+ 
  	del_timer(&ucs->timer_cmd_in);
  
  	switch (status) {
***************
*** 492,501 ****
  				numbytes = ucs->rcvbuf_size;
  		}
  
! 		/* copy received bytes to inbuf, notify event layer */
! 		if (gigaset_fill_inbuf(inbuf, ucs->rcvbuf, numbytes)) {
! 			gig_dbg(DEBUG_INTR, "%s-->BH", __func__);
! 			gigaset_schedule_event(cs);
  		}
  		break;
  
--- 495,513 ----
  				numbytes = ucs->rcvbuf_size;
  		}
  
! 		/* copy received bytes to inbuf */
! 		have_data = gigaset_fill_inbuf(inbuf, ucs->rcvbuf, numbytes);
! 
! 		if (unlikely(numbytes < ucs->rcvbuf_size)) {
! 			/* incomplete - resubmit for remaining bytes */
! 			ucs->rcvbuf_size -= numbytes;
! 			ucs->retry_cmd_in = 0;
! 			rc = atread_submit(cs, BAS_TIMEOUT);
! 			if (rc >= 0 || rc == -ENODEV)
! 				/* resubmitted or disconnected */
! 				/* - bypass regular exit block */
! 				return;
! 			error_reset(cs);
  		}
  		break;
  
***************
*** 504,535 ****
  	case -EINPROGRESS:		/* pending */
  	case -ENODEV:			/* device removed */
  	case -ESHUTDOWN:		/* device shut down */
! 		/* no further action necessary */
  		gig_dbg(DEBUG_USBREQ, "%s: %s",
  			__func__, get_usb_statmsg(status));
  		break;
  
! 	default:			/* other errors: retry */
  		if (ucs->retry_cmd_in++ < BAS_RETRY) {
! 			gig_dbg(DEBUG_USBREQ, "%s: %s, retry %d", __func__,
! 				get_usb_statmsg(status), ucs->retry_cmd_in);
  			rc = atread_submit(cs, BAS_TIMEOUT);
! 			if (rc >= 0)
! 				/* successfully resubmitted, skip freeing */
  				return;
! 			if (rc == -ENODEV)
! 				/* disconnect, no further action necessary */
! 				break;
  		}
- 		dev_err(cs->dev, "control read: %s, giving up after %d tries\n",
- 			get_usb_statmsg(status), ucs->retry_cmd_in);
  		error_reset(cs);
  	}
  
- 	/* read finished, free buffer */
  	kfree(ucs->rcvbuf);
  	ucs->rcvbuf = NULL;
  	ucs->rcvbuf_size = 0;
  }
  
  /* atread_submit
--- 516,552 ----
  	case -EINPROGRESS:		/* pending */
  	case -ENODEV:			/* device removed */
  	case -ESHUTDOWN:		/* device shut down */
! 		/* no action necessary */
  		gig_dbg(DEBUG_USBREQ, "%s: %s",
  			__func__, get_usb_statmsg(status));
  		break;
  
! 	default:			/* severe trouble */
! 		dev_warn(cs->dev, "control read: %s\n",
! 			 get_usb_statmsg(status));
  		if (ucs->retry_cmd_in++ < BAS_RETRY) {
! 			dev_notice(cs->dev, "control read: retry %d\n",
! 				   ucs->retry_cmd_in);
  			rc = atread_submit(cs, BAS_TIMEOUT);
! 			if (rc >= 0 || rc == -ENODEV)
! 				/* resubmitted or disconnected */
! 				/* - bypass regular exit block */
  				return;
! 		} else {
! 			dev_err(cs->dev,
! 				"control read: giving up after %d tries\n",
! 				ucs->retry_cmd_in);
  		}
  		error_reset(cs);
  	}
  
  	kfree(ucs->rcvbuf);
  	ucs->rcvbuf = NULL;
  	ucs->rcvbuf_size = 0;
+ 	if (have_data) {
+ 		gig_dbg(DEBUG_INTR, "%s-->BH", __func__);
+ 		gigaset_schedule_event(cs);
+ 	}
  }
  
  /* atread_submit
***************
*** 1599,1611 ****
  
  	ret = starturbs(bcs);
  	if (ret < 0) {
- 		spin_unlock_irqrestore(&cs->lock, flags);
  		dev_err(cs->dev,
  			"could not start isochronous I/O for channel B%d: %s\n",
  			bcs->channel + 1,
  			ret == -EFAULT ? "null URB" : get_usb_rcmsg(ret));
  		if (ret != -ENODEV)
  			error_hangup(bcs);
  		return ret;
  	}
  
--- 1616,1628 ----
  
  	ret = starturbs(bcs);
  	if (ret < 0) {
  		dev_err(cs->dev,
  			"could not start isochronous I/O for channel B%d: %s\n",
  			bcs->channel + 1,
  			ret == -EFAULT ? "null URB" : get_usb_rcmsg(ret));
  		if (ret != -ENODEV)
  			error_hangup(bcs);
+ 		spin_unlock_irqrestore(&cs->lock, flags);
  		return ret;
  	}
  
***************
*** 1615,1625 ****
  		dev_err(cs->dev, "could not open channel B%d\n",
  			bcs->channel + 1);
  		stopurbs(bcs->hw.bas);
  	}
  
  	spin_unlock_irqrestore(&cs->lock, flags);
- 	if (ret < 0 && ret != -ENODEV)
- 		error_hangup(bcs);
  	return ret;
  }
  
--- 1632,1642 ----
  		dev_err(cs->dev, "could not open channel B%d\n",
  			bcs->channel + 1);
  		stopurbs(bcs->hw.bas);
+ 		if (ret != -ENODEV)
+ 			error_hangup(bcs);
  	}
  
  	spin_unlock_irqrestore(&cs->lock, flags);
  	return ret;
  }
  
diff -cBr 2.6.35/drivers/isdn/gigaset/isocdata.c linux-2.6.35.y-512ac85/drivers/isdn/gigaset/isocdata.c
*** 2.6.35/drivers/isdn/gigaset/isocdata.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/isdn/gigaset/isocdata.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 842,855 ****
  
  	if (unlikely(bcs->ignore)) {
  		bcs->ignore--;
  		return;
  	}
  	skb = bcs->rx_skb;
! 	if (skb == NULL) {
  		skb = gigaset_new_rx_skb(bcs);
! 		if (skb == NULL)
! 			return;
! 	}
  	dobytes = bcs->rx_bufsize - skb->len;
  	while (count > 0) {
  		dst = skb_put(skb, count < dobytes ? count : dobytes);
--- 842,854 ----
  
  	if (unlikely(bcs->ignore)) {
  		bcs->ignore--;
+ 		hdlc_flush(bcs);
  		return;
  	}
  	skb = bcs->rx_skb;
! 	if (skb == NULL)
  		skb = gigaset_new_rx_skb(bcs);
! 	bcs->hw.bas->goodbytes += skb->len;
  	dobytes = bcs->rx_bufsize - skb->len;
  	while (count > 0) {
  		dst = skb_put(skb, count < dobytes ? count : dobytes);
***************
*** 861,867 ****
  		if (dobytes == 0) {
  			dump_bytes(DEBUG_STREAM_DUMP,
  				   "rcv data", skb->data, skb->len);
- 			bcs->hw.bas->goodbytes += skb->len;
  			gigaset_skb_rcvd(bcs, skb);
  			skb = gigaset_new_rx_skb(bcs);
  			if (skb == NULL)
--- 860,865 ----
diff -cBr 2.6.35/drivers/isdn/hisax/config.c linux-2.6.35.y-512ac85/drivers/isdn/hisax/config.c
*** 2.6.35/drivers/isdn/hisax/config.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/isdn/hisax/config.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 801,816 ****
  	ll_unload(csta);
  }
  
- static irqreturn_t card_irq(int intno, void *dev_id)
- {
- 	struct IsdnCardState *cs = dev_id;
- 	irqreturn_t ret = cs->irq_func(intno, cs);
- 
- 	if (ret == IRQ_HANDLED)
- 		cs->irq_cnt++;
- 	return ret;
- }
- 
  static int init_card(struct IsdnCardState *cs)
  {
  	int 	irq_cnt, cnt = 3, ret;
--- 801,806 ----
***************
*** 819,828 ****
  		ret = cs->cardmsg(cs, CARD_INIT, NULL);
  		return(ret);
  	}
! 	irq_cnt = cs->irq_cnt = 0;
  	printk(KERN_INFO "%s: IRQ %d count %d\n", CardType[cs->typ],
  	       cs->irq, irq_cnt);
! 	if (request_irq(cs->irq, card_irq, cs->irq_flags, "HiSax", cs)) {
  		printk(KERN_WARNING "HiSax: couldn't get interrupt %d\n",
  		       cs->irq);
  		return 1;
--- 809,818 ----
  		ret = cs->cardmsg(cs, CARD_INIT, NULL);
  		return(ret);
  	}
! 	irq_cnt = kstat_irqs(cs->irq);
  	printk(KERN_INFO "%s: IRQ %d count %d\n", CardType[cs->typ],
  	       cs->irq, irq_cnt);
! 	if (request_irq(cs->irq, cs->irq_func, cs->irq_flags, "HiSax", cs)) {
  		printk(KERN_WARNING "HiSax: couldn't get interrupt %d\n",
  		       cs->irq);
  		return 1;
***************
*** 832,839 ****
  		/* Timeout 10ms */
  		msleep(10);
  		printk(KERN_INFO "%s: IRQ %d count %d\n",
! 		       CardType[cs->typ], cs->irq, cs->irq_cnt);
! 		if (cs->irq_cnt == irq_cnt) {
  			printk(KERN_WARNING
  			       "%s: IRQ(%d) getting no interrupts during init %d\n",
  			       CardType[cs->typ], cs->irq, 4 - cnt);
--- 822,829 ----
  		/* Timeout 10ms */
  		msleep(10);
  		printk(KERN_INFO "%s: IRQ %d count %d\n",
! 		       CardType[cs->typ], cs->irq, kstat_irqs(cs->irq));
! 		if (kstat_irqs(cs->irq) == irq_cnt) {
  			printk(KERN_WARNING
  			       "%s: IRQ(%d) getting no interrupts during init %d\n",
  			       CardType[cs->typ], cs->irq, 4 - cnt);
diff -cBr 2.6.35/drivers/isdn/hisax/hisax.h linux-2.6.35.y-512ac85/drivers/isdn/hisax/hisax.h
*** 2.6.35/drivers/isdn/hisax/hisax.h	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/isdn/hisax/hisax.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 959,965 ****
  	u_long		event;
  	struct work_struct tqueue;
  	struct timer_list dbusytimer;
- 	unsigned int	irq_cnt;
  #ifdef ERROR_STATISTIC
  	int		err_crc;
  	int		err_tx;
--- 959,964 ----
diff -cBr 2.6.35/drivers/leds/leds-ss4200.c linux-2.6.35.y-512ac85/drivers/leds/leds-ss4200.c
*** 2.6.35/drivers/leds/leds-ss4200.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/leds/leds-ss4200.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 102,108 ****
  			DMI_MATCH(DMI_PRODUCT_VERSION, "1.00.00")
  		}
  	},
- 	{}
  };
  
  /*
--- 102,107 ----
Only in 2.6.35/drivers/leds: ledtrig-sleep.c
diff -cBr 2.6.35/drivers/md/dm.c linux-2.6.35.y-512ac85/drivers/md/dm.c
*** 2.6.35/drivers/md/dm.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/dm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2040,2053 ****
  	wake_up(&md->eventq);
  }
  
- /*
-  * Protected by md->suspend_lock obtained by dm_swap_table().
-  */
  static void __set_size(struct mapped_device *md, sector_t size)
  {
  	set_capacity(md->disk, size);
  
  	i_size_write(md->bdev->bd_inode, (loff_t)size << SECTOR_SHIFT);
  }
  
  /*
--- 2040,2052 ----
  	wake_up(&md->eventq);
  }
  
  static void __set_size(struct mapped_device *md, sector_t size)
  {
  	set_capacity(md->disk, size);
  
+ 	mutex_lock(&md->bdev->bd_inode->i_mutex);
  	i_size_write(md->bdev->bd_inode, (loff_t)size << SECTOR_SHIFT);
+ 	mutex_unlock(&md->bdev->bd_inode->i_mutex);
  }
  
  /*
diff -cBr 2.6.35/drivers/md/dm-mpath.c linux-2.6.35.y-512ac85/drivers/md/dm-mpath.c
*** 2.6.35/drivers/md/dm-mpath.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/dm-mpath.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 33,38 ****
--- 33,39 ----
  	unsigned fail_count;		/* Cumulative failure count */
  
  	struct dm_path path;
+ 	struct work_struct deactivate_path;
  	struct work_struct activate_path;
  };
  
***************
*** 115,120 ****
--- 116,122 ----
  static void process_queued_ios(struct work_struct *work);
  static void trigger_event(struct work_struct *work);
  static void activate_path(struct work_struct *work);
+ static void deactivate_path(struct work_struct *work);
  
  
  /*-----------------------------------------------
***************
*** 127,132 ****
--- 129,135 ----
  
  	if (pgpath) {
  		pgpath->is_active = 1;
+ 		INIT_WORK(&pgpath->deactivate_path, deactivate_path);
  		INIT_WORK(&pgpath->activate_path, activate_path);
  	}
  
***************
*** 138,143 ****
--- 141,154 ----
  	kfree(pgpath);
  }
  
+ static void deactivate_path(struct work_struct *work)
+ {
+ 	struct pgpath *pgpath =
+ 		container_of(work, struct pgpath, deactivate_path);
+ 
+ 	blk_abort_queue(pgpath->path.dev->bdev->bd_disk->queue);
+ }
+ 
  static struct priority_group *alloc_priority_group(void)
  {
  	struct priority_group *pg;
***************
*** 982,987 ****
--- 993,999 ----
  		      pgpath->path.dev->name, m->nr_valid_paths);
  
  	schedule_work(&m->trigger_event);
+ 	queue_work(kmultipathd, &pgpath->deactivate_path);
  
  out:
  	spin_unlock_irqrestore(&m->lock, flags);
diff -cBr 2.6.35/drivers/md/dm-table.c linux-2.6.35.y-512ac85/drivers/md/dm-table.c
*** 2.6.35/drivers/md/dm-table.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/dm-table.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1081,1086 ****
--- 1081,1091 ----
  	 */
  	q->limits = *limits;
  
+ 	if (limits->no_cluster)
+ 		queue_flag_clear_unlocked(QUEUE_FLAG_CLUSTER, q);
+ 	else
+ 		queue_flag_set_unlocked(QUEUE_FLAG_CLUSTER, q);
+ 
  	dm_table_set_integrity(t);
  
  	/*
diff -cBr 2.6.35/drivers/md/md.c linux-2.6.35.y-512ac85/drivers/md/md.c
*** 2.6.35/drivers/md/md.c	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/md.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 441,449 ****
  {
  	mddev_t *mddev, *new = NULL;
  
- 	if (unit && MAJOR(unit) != MD_MAJOR)
- 		unit &= ~((1<<MdpMinorShift)-1);
- 
   retry:
  	spin_lock(&all_mddevs_lock);
  
--- 441,446 ----
***************
*** 1281,1287 ****
  	md_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,
  		       rdev->sb_page);
  	md_super_wait(rdev->mddev);
! 	return num_sectors;
  }
  
  
--- 1278,1284 ----
  	md_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,
  		       rdev->sb_page);
  	md_super_wait(rdev->mddev);
! 	return num_sectors / 2; /* kB for sysfs */
  }
  
  
***************
*** 1647,1653 ****
  	md_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,
  		       rdev->sb_page);
  	md_super_wait(rdev->mddev);
! 	return num_sectors;
  }
  
  static struct super_type super_types[] = {
--- 1644,1650 ----
  	md_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,
  		       rdev->sb_page);
  	md_super_wait(rdev->mddev);
! 	return num_sectors / 2; /* kB for sysfs */
  }
  
  static struct super_type super_types[] = {
***************
*** 4251,4256 ****
--- 4248,4256 ----
  		goto abort;
  	mddev->queue->queuedata = mddev;
  
+ 	/* Can be unlocked because the queue is new: no concurrency */
+ 	queue_flag_set_unlocked(QUEUE_FLAG_CLUSTER, mddev->queue);
+ 
  	blk_queue_make_request(mddev->queue, md_make_request);
  
  	disk = alloc_disk(1 << shift);
***************
*** 4550,4556 ****
  
  	set_capacity(mddev->gendisk, mddev->array_sectors);
  	revalidate_disk(mddev->gendisk);
- 	mddev->changed = 1;
  	kobject_uevent(&disk_to_dev(mddev->gendisk)->kobj, KOBJ_CHANGE);
  out:
  	return err;
--- 4550,4555 ----
***************
*** 4639,4645 ****
  	mddev->sync_speed_min = mddev->sync_speed_max = 0;
  	mddev->recovery = 0;
  	mddev->in_sync = 0;
- 	mddev->changed = 0;
  	mddev->degraded = 0;
  	mddev->barriers_work = 0;
  	mddev->safemode = 0;
--- 4638,4643 ----
***************
*** 4746,4752 ****
  
  		set_capacity(disk, 0);
  		revalidate = 1;
- 		mddev->changed = 1;
  
  		if (mddev->ro)
  			mddev->ro = 0;
--- 4744,4749 ----
***************
*** 5112,5132 ****
  				PTR_ERR(rdev));
  			return PTR_ERR(rdev);
  		}
! 		/* set saved_raid_disk if appropriate */
  		if (!mddev->persistent) {
  			if (info->state & (1<<MD_DISK_SYNC)  &&
! 			    info->raid_disk < mddev->raid_disks) {
  				rdev->raid_disk = info->raid_disk;
! 				set_bit(In_sync, &rdev->flags);
! 			} else
  				rdev->raid_disk = -1;
  		} else
  			super_types[mddev->major_version].
  				validate_super(mddev, rdev);
! 		if (test_bit(In_sync, &rdev->flags))
! 			rdev->saved_raid_disk = rdev->raid_disk;
! 		else
! 			rdev->saved_raid_disk = -1;
  
  		clear_bit(In_sync, &rdev->flags); /* just to be sure */
  		if (info->state & (1<<MD_DISK_WRITEMOSTLY))
--- 5109,5125 ----
  				PTR_ERR(rdev));
  			return PTR_ERR(rdev);
  		}
! 		/* set save_raid_disk if appropriate */
  		if (!mddev->persistent) {
  			if (info->state & (1<<MD_DISK_SYNC)  &&
! 			    info->raid_disk < mddev->raid_disks)
  				rdev->raid_disk = info->raid_disk;
! 			else
  				rdev->raid_disk = -1;
  		} else
  			super_types[mddev->major_version].
  				validate_super(mddev, rdev);
! 		rdev->saved_raid_disk = rdev->raid_disk;
  
  		clear_bit(In_sync, &rdev->flags); /* just to be sure */
  		if (info->state & (1<<MD_DISK_WRITEMOSTLY))
***************
*** 5933,5939 ****
  	atomic_inc(&mddev->openers);
  	mutex_unlock(&mddev->open_mutex);
  
! 	check_disk_change(bdev);
   out:
  	return err;
  }
--- 5926,5932 ----
  	atomic_inc(&mddev->openers);
  	mutex_unlock(&mddev->open_mutex);
  
! 	check_disk_size_change(mddev->gendisk, bdev);
   out:
  	return err;
  }
***************
*** 5948,5968 ****
  
  	return 0;
  }
- 
- static int md_media_changed(struct gendisk *disk)
- {
- 	mddev_t *mddev = disk->private_data;
- 
- 	return mddev->changed;
- }
- 
- static int md_revalidate(struct gendisk *disk)
- {
- 	mddev_t *mddev = disk->private_data;
- 
- 	mddev->changed = 0;
- 	return 0;
- }
  static const struct block_device_operations md_fops =
  {
  	.owner		= THIS_MODULE,
--- 5941,5946 ----
***************
*** 5973,5980 ****
  	.compat_ioctl	= md_compat_ioctl,
  #endif
  	.getgeo		= md_getgeo,
- 	.media_changed  = md_media_changed,
- 	.revalidate_disk= md_revalidate,
  };
  
  static int md_thread(void * arg)
--- 5951,5956 ----
***************
*** 6010,6017 ****
  			 || kthread_should_stop(),
  			 thread->timeout);
  
! 		if (test_and_clear_bit(THREAD_WAKEUP, &thread->flags))
! 			thread->run(thread->mddev);
  	}
  
  	return 0;
--- 5986,5994 ----
  			 || kthread_should_stop(),
  			 thread->timeout);
  
! 		clear_bit(THREAD_WAKEUP, &thread->flags);
! 
! 		thread->run(thread->mddev);
  	}
  
  	return 0;
diff -cBr 2.6.35/drivers/md/md.h linux-2.6.35.y-512ac85/drivers/md/md.h
*** 2.6.35/drivers/md/md.h	2011-05-07 19:57:18.376750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/md.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 250,257 ****
  	atomic_t			active;		/* general refcount */
  	atomic_t			openers;	/* number of active opens */
  
- 	int				changed;	/* True if we might need to
- 							 * reread partition info */
  	int				degraded;	/* whether md should consider
  							 * adding a spare
  							 */
--- 250,255 ----
diff -cBr 2.6.35/drivers/md/raid10.c linux-2.6.35.y-512ac85/drivers/md/raid10.c
*** 2.6.35/drivers/md/raid10.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/raid10.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2393,2405 ****
  	return 0;
  
  out_free_conf:
- 	md_unregister_thread(mddev->thread);
  	if (conf->r10bio_pool)
  		mempool_destroy(conf->r10bio_pool);
  	safe_put_page(conf->tmppage);
  	kfree(conf->mirrors);
  	kfree(conf);
  	mddev->private = NULL;
  out:
  	return -EIO;
  }
--- 2393,2405 ----
  	return 0;
  
  out_free_conf:
  	if (conf->r10bio_pool)
  		mempool_destroy(conf->r10bio_pool);
  	safe_put_page(conf->tmppage);
  	kfree(conf->mirrors);
  	kfree(conf);
  	mddev->private = NULL;
+ 	md_unregister_thread(mddev->thread);
  out:
  	return -EIO;
  }
diff -cBr 2.6.35/drivers/md/raid1.c linux-2.6.35.y-512ac85/drivers/md/raid1.c
*** 2.6.35/drivers/md/raid1.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/md/raid1.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1208,1214 ****
  		 * is not possible.
  		 */
  		if (!test_bit(Faulty, &rdev->flags) &&
- 		    !mddev->recovery_disabled &&
  		    mddev->degraded < conf->raid_disks) {
  			err = -EBUSY;
  			goto abort;
--- 1208,1213 ----
diff -cBr 2.6.35/drivers/media/dvb/ttpci/av7110_ca.c linux-2.6.35.y-512ac85/drivers/media/dvb/ttpci/av7110_ca.c
*** 2.6.35/drivers/media/dvb/ttpci/av7110_ca.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/dvb/ttpci/av7110_ca.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 277,283 ****
  	{
  		ca_slot_info_t *info=(ca_slot_info_t *)parg;
  
! 		if (info->num < 0 || info->num > 1)
  			return -EINVAL;
  		av7110->ci_slot[info->num].num = info->num;
  		av7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?
--- 277,283 ----
  	{
  		ca_slot_info_t *info=(ca_slot_info_t *)parg;
  
! 		if (info->num > 1)
  			return -EINVAL;
  		av7110->ci_slot[info->num].num = info->num;
  		av7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?
diff -cBr 2.6.35/drivers/media/radio/radio-aimslab.c linux-2.6.35.y-512ac85/drivers/media/radio/radio-aimslab.c
*** 2.6.35/drivers/media/radio/radio-aimslab.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/radio/radio-aimslab.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 31,37 ****
  #include <linux/module.h>	/* Modules 			*/
  #include <linux/init.h>		/* Initdata			*/
  #include <linux/ioport.h>	/* request_region		*/
! #include <linux/delay.h>	/* msleep			*/
  #include <linux/videodev2.h>	/* kernel radio structs		*/
  #include <linux/version.h>	/* for KERNEL_VERSION MACRO	*/
  #include <linux/io.h>		/* outb, outb_p			*/
--- 31,37 ----
  #include <linux/module.h>	/* Modules 			*/
  #include <linux/init.h>		/* Initdata			*/
  #include <linux/ioport.h>	/* request_region		*/
! #include <linux/delay.h>	/* udelay			*/
  #include <linux/videodev2.h>	/* kernel radio structs		*/
  #include <linux/version.h>	/* for KERNEL_VERSION MACRO	*/
  #include <linux/io.h>		/* outb, outb_p			*/
***************
*** 71,87 ****
  
  /* local things */
  
  static void rt_decvol(struct rtrack *rt)
  {
  	outb(0x58, rt->io);		/* volume down + sigstr + on	*/
! 	msleep(100);
  	outb(0xd8, rt->io);		/* volume steady + sigstr + on	*/
  }
  
  static void rt_incvol(struct rtrack *rt)
  {
  	outb(0x98, rt->io);		/* volume up + sigstr + on	*/
! 	msleep(100);
  	outb(0xd8, rt->io);		/* volume steady + sigstr + on	*/
  }
  
--- 71,97 ----
  
  /* local things */
  
+ static void sleep_delay(long n)
+ {
+ 	/* Sleep nicely for 'n' uS */
+ 	int d = n / msecs_to_jiffies(1000);
+ 	if (!d)
+ 		udelay(n);
+ 	else
+ 		msleep(jiffies_to_msecs(d));
+ }
+ 
  static void rt_decvol(struct rtrack *rt)
  {
  	outb(0x58, rt->io);		/* volume down + sigstr + on	*/
! 	sleep_delay(100000);
  	outb(0xd8, rt->io);		/* volume steady + sigstr + on	*/
  }
  
  static void rt_incvol(struct rtrack *rt)
  {
  	outb(0x98, rt->io);		/* volume up + sigstr + on	*/
! 	sleep_delay(100000);
  	outb(0xd8, rt->io);		/* volume steady + sigstr + on	*/
  }
  
***************
*** 110,116 ****
  
  	if (vol == 0) {			/* volume = 0 means mute the card */
  		outb(0x48, rt->io);	/* volume down but still "on"	*/
! 		msleep(2000);	/* make sure it's totally down	*/
  		outb(0xd0, rt->io);	/* volume steady, off		*/
  		rt->curvol = 0;		/* track the volume state!	*/
  		mutex_unlock(&rt->lock);
--- 120,126 ----
  
  	if (vol == 0) {			/* volume = 0 means mute the card */
  		outb(0x48, rt->io);	/* volume down but still "on"	*/
! 		sleep_delay(2000000);	/* make sure it's totally down	*/
  		outb(0xd0, rt->io);	/* volume steady, off		*/
  		rt->curvol = 0;		/* track the volume state!	*/
  		mutex_unlock(&rt->lock);
***************
*** 145,151 ****
  		outb_p(128+64+16+8+  1, rt->io);  /* on + wr-enable + data low */
  		outb_p(128+64+16+8+2+1, rt->io);  /* clock */
  	}
! 	msleep(1);
  }
  
  static void send_1_byte(struct rtrack *rt)
--- 155,161 ----
  		outb_p(128+64+16+8+  1, rt->io);  /* on + wr-enable + data low */
  		outb_p(128+64+16+8+2+1, rt->io);  /* clock */
  	}
! 	sleep_delay(1000);
  }
  
  static void send_1_byte(struct rtrack *rt)
***************
*** 159,165 ****
  		outb_p(128+64+16+8+4+2+1, rt->io); /* clock */
  	}
  
! 	msleep(1);
  }
  
  static int rt_setfreq(struct rtrack *rt, unsigned long freq)
--- 169,175 ----
  		outb_p(128+64+16+8+4+2+1, rt->io); /* clock */
  	}
  
! 	sleep_delay(1000);
  }
  
  static int rt_setfreq(struct rtrack *rt, unsigned long freq)
***************
*** 417,423 ****
  
  	/* this ensures that the volume is all the way down  */
  	outb(0x48, rt->io);		/* volume down but still "on"	*/
! 	msleep(2000);	/* make sure it's totally down	*/
  	outb(0xc0, rt->io);		/* steady volume, mute card	*/
  
  	return 0;
--- 427,433 ----
  
  	/* this ensures that the volume is all the way down  */
  	outb(0x48, rt->io);		/* volume down but still "on"	*/
! 	sleep_delay(2000000);	/* make sure it's totally down	*/
  	outb(0xc0, rt->io);		/* steady volume, mute card	*/
  
  	return 0;
Only in 2.6.35/drivers/media/radio: si4709
Only in 2.6.35/drivers/media/video: ce147.c
diff -cBr 2.6.35/drivers/media/video/cx23885/cx23885-core.c linux-2.6.35.y-512ac85/drivers/media/video/cx23885/cx23885-core.c
*** 2.6.35/drivers/media/video/cx23885/cx23885-core.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/cx23885/cx23885-core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 737,743 ****
  	case 0x0e:
  		/* CX23887-15Z */
  		dev->hwrevision = 0xc0;
- 		break;
  	case 0x0f:
  		/* CX23887-14Z */
  		dev->hwrevision = 0xb1;
--- 737,742 ----
diff -cBr 2.6.35/drivers/media/video/em28xx/em28xx-cards.c linux-2.6.35.y-512ac85/drivers/media/video/em28xx/em28xx-cards.c
*** 2.6.35/drivers/media/video/em28xx/em28xx-cards.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/em28xx/em28xx-cards.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1605,1615 ****
  		.input           = { {
  			.type     = EM28XX_VMUX_COMPOSITE1,
  			.vmux     = SAA7115_COMPOSITE0,
! 			.amux     = EM28XX_AMUX_LINE_IN,
  		}, {
  			.type     = EM28XX_VMUX_SVIDEO,
  			.vmux     = SAA7115_SVIDEO3,
! 			.amux     = EM28XX_AMUX_LINE_IN,
  		} },
  	},
  	[EM2860_BOARD_TERRATEC_AV350] = {
--- 1605,1615 ----
  		.input           = { {
  			.type     = EM28XX_VMUX_COMPOSITE1,
  			.vmux     = SAA7115_COMPOSITE0,
! 			.amux     = EM28XX_AMUX_VIDEO2,
  		}, {
  			.type     = EM28XX_VMUX_SVIDEO,
  			.vmux     = SAA7115_SVIDEO3,
! 			.amux     = EM28XX_AMUX_VIDEO2,
  		} },
  	},
  	[EM2860_BOARD_TERRATEC_AV350] = {
diff -cBr 2.6.35/drivers/media/video/gspca/sonixj.c linux-2.6.35.y-512ac85/drivers/media/video/gspca/sonixj.c
*** 2.6.35/drivers/media/video/gspca/sonixj.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/gspca/sonixj.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 57,63 ****
  	u8 jpegqual;			/* webcam quality */
  
  	u8 reg18;
- 	u8 flags;
  
  	s8 ag_cnt;
  #define AG_CNT_START 13
--- 57,62 ----
***************
*** 89,97 ****
  	u8 jpeg_hdr[JPEG_HDR_SZ];
  };
  
- /* device flags */
- #define PDN_INV	1		/* inverse pin S_PWR_DN / sn_xxx tables */
- 
  /* V4L2 controls supported by the driver */
  static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val);
  static int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val);
--- 88,93 ----
***************
*** 1778,1785 ****
  	struct cam *cam;
  
  	sd->bridge = id->driver_info >> 16;
! 	sd->sensor = id->driver_info >> 8;
! 	sd->flags = id->driver_info;
  
  	cam = &gspca_dev->cam;
  	if (sd->sensor == SENSOR_ADCM1700) {
--- 1774,1780 ----
  	struct cam *cam;
  
  	sd->bridge = id->driver_info >> 16;
! 	sd->sensor = id->driver_info;
  
  	cam = &gspca_dev->cam;
  	if (sd->sensor == SENSOR_ADCM1700) {
***************
*** 2493,2499 ****
  		reg1 = 0x44;
  		reg17 = 0xa2;
  		break;
! 	case SENSOR_SP80708:
  		init = sp80708_sensor_param1;
  		if (mode) {
  /*??			reg1 = 0x04;	 * 320 clk 48Mhz */
--- 2488,2495 ----
  		reg1 = 0x44;
  		reg17 = 0xa2;
  		break;
! 	default:
! /*	case SENSOR_SP80708: */
  		init = sp80708_sensor_param1;
  		if (mode) {
  /*??			reg1 = 0x04;	 * 320 clk 48Mhz */
***************
*** 3003,3020 ****
  /* -- module initialisation -- */
  #define BS(bridge, sensor) \
  	.driver_info = (BRIDGE_ ## bridge << 16) \
! 			| (SENSOR_ ## sensor << 8)
! #define BSF(bridge, sensor, flags) \
! 	.driver_info = (BRIDGE_ ## bridge << 16) \
! 			| (SENSOR_ ## sensor << 8) \
! 			| (flags)
  static const __devinitdata struct usb_device_id device_table[] = {
  #if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
  	{USB_DEVICE(0x0458, 0x7025), BS(SN9C120, MI0360)},
  	{USB_DEVICE(0x0458, 0x702e), BS(SN9C120, OV7660)},
  #endif
! 	{USB_DEVICE(0x045e, 0x00f5), BSF(SN9C105, OV7660, PDN_INV)},
! 	{USB_DEVICE(0x045e, 0x00f7), BSF(SN9C105, OV7660, PDN_INV)},
  	{USB_DEVICE(0x0471, 0x0327), BS(SN9C105, MI0360)},
  	{USB_DEVICE(0x0471, 0x0328), BS(SN9C105, MI0360)},
  	{USB_DEVICE(0x0471, 0x0330), BS(SN9C105, MI0360)},
--- 2999,3012 ----
  /* -- module initialisation -- */
  #define BS(bridge, sensor) \
  	.driver_info = (BRIDGE_ ## bridge << 16) \
! 			| SENSOR_ ## sensor
  static const __devinitdata struct usb_device_id device_table[] = {
  #if !defined CONFIG_USB_SN9C102 && !defined CONFIG_USB_SN9C102_MODULE
  	{USB_DEVICE(0x0458, 0x7025), BS(SN9C120, MI0360)},
  	{USB_DEVICE(0x0458, 0x702e), BS(SN9C120, OV7660)},
  #endif
! 	{USB_DEVICE(0x045e, 0x00f5), BS(SN9C105, OV7660)},
! 	{USB_DEVICE(0x045e, 0x00f7), BS(SN9C105, OV7660)},
  	{USB_DEVICE(0x0471, 0x0327), BS(SN9C105, MI0360)},
  	{USB_DEVICE(0x0471, 0x0328), BS(SN9C105, MI0360)},
  	{USB_DEVICE(0x0471, 0x0330), BS(SN9C105, MI0360)},
diff -cBr 2.6.35/drivers/media/video/hdpvr/hdpvr-video.c linux-2.6.35.y-512ac85/drivers/media/video/hdpvr/hdpvr-video.c
*** 2.6.35/drivers/media/video/hdpvr/hdpvr-video.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/hdpvr/hdpvr-video.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 157,163 ****
  				  mem, dev->bulk_in_size,
  				  hdpvr_read_bulk_callback, buf);
  
- 		buf->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  		buf->status = BUFSTAT_AVAILABLE;
  		list_add_tail(&buf->buff_list, &dev->free_buff_list);
  	}
--- 157,162 ----
Only in 2.6.35/drivers/media/video: s5k4ecgx.c
Only in 2.6.35/drivers/media/video: s5k4ecgx_regs_1_0.h
Only in 2.6.35/drivers/media/video: s5k4ecgx_regs_1_1.h
Only in 2.6.35/drivers/media/video: s5ka3dfx.c
Only in 2.6.35/drivers/media/video: s5ka3dfx.h
diff -cBr 2.6.35/drivers/media/video/saa7134/saa7134-cards.c linux-2.6.35.y-512ac85/drivers/media/video/saa7134/saa7134-cards.c
*** 2.6.35/drivers/media/video/saa7134/saa7134-cards.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/saa7134/saa7134-cards.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 6631,6648 ****
  		.subdevice    = 0x6655,
  		.driver_data  = SAA7134_BOARD_LEADTEK_WINFAST_DTV1000S,
  	}, {
- 		.vendor       = PCI_VENDOR_ID_PHILIPS,
- 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
- 		.subvendor    = 0x5ace, /* Beholder Intl. Ltd. */
- 		.subdevice    = 0x7190,
- 		.driver_data  = SAA7134_BOARD_BEHOLD_H7,
- 	}, {
- 		.vendor       = PCI_VENDOR_ID_PHILIPS,
- 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
- 		.subvendor    = 0x5ace, /* Beholder Intl. Ltd. */
- 		.subdevice    = 0x7090,
- 		.driver_data  = SAA7134_BOARD_BEHOLD_A7,
- 	}, {
  		/* --- boards without eeprom + subsystem ID --- */
  		.vendor       = PCI_VENDOR_ID_PHILIPS,
  		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
--- 6631,6636 ----
***************
*** 6680,6685 ****
--- 6668,6685 ----
  		.subvendor    = PCI_ANY_ID,
  		.subdevice    = PCI_ANY_ID,
  		.driver_data  = SAA7134_BOARD_UNKNOWN,
+ 	}, {
+ 		.vendor       = PCI_VENDOR_ID_PHILIPS,
+ 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
+ 		.subvendor    = 0x5ace, /* Beholder Intl. Ltd. */
+ 		.subdevice    = 0x7190,
+ 		.driver_data  = SAA7134_BOARD_BEHOLD_H7,
+ 	}, {
+ 		.vendor       = PCI_VENDOR_ID_PHILIPS,
+ 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
+ 		.subvendor    = 0x5ace, /* Beholder Intl. Ltd. */
+ 		.subdevice    = 0x7090,
+ 		.driver_data  = SAA7134_BOARD_BEHOLD_A7,
  	},{
  		/* --- end of list --- */
  	}
Only in 2.6.35/drivers/media/video: samsung
diff -cBr 2.6.35/drivers/media/video/sn9c102/sn9c102_core.c linux-2.6.35.y-512ac85/drivers/media/video/sn9c102/sn9c102_core.c
*** 2.6.35/drivers/media/video/sn9c102/sn9c102_core.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/sn9c102/sn9c102_core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1430,1438 ****
  		   sn9c102_show_i2c_reg, sn9c102_store_i2c_reg);
  static DEVICE_ATTR(i2c_val, S_IRUGO | S_IWUSR,
  		   sn9c102_show_i2c_val, sn9c102_store_i2c_val);
! static DEVICE_ATTR(green, S_IWUSR, NULL, sn9c102_store_green);
! static DEVICE_ATTR(blue, S_IWUSR, NULL, sn9c102_store_blue);
! static DEVICE_ATTR(red, S_IWUSR, NULL, sn9c102_store_red);
  static DEVICE_ATTR(frame_header, S_IRUGO, sn9c102_show_frame_header, NULL);
  
  
--- 1430,1438 ----
  		   sn9c102_show_i2c_reg, sn9c102_store_i2c_reg);
  static DEVICE_ATTR(i2c_val, S_IRUGO | S_IWUSR,
  		   sn9c102_show_i2c_val, sn9c102_store_i2c_val);
! static DEVICE_ATTR(green, S_IWUGO, NULL, sn9c102_store_green);
! static DEVICE_ATTR(blue, S_IWUGO, NULL, sn9c102_store_blue);
! static DEVICE_ATTR(red, S_IWUGO, NULL, sn9c102_store_red);
  static DEVICE_ATTR(frame_header, S_IRUGO, sn9c102_show_frame_header, NULL);
  
  
diff -cBr 2.6.35/drivers/media/video/uvc/uvc_driver.c linux-2.6.35.y-512ac85/drivers/media/video/uvc/uvc_driver.c
*** 2.6.35/drivers/media/video/uvc/uvc_driver.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/uvc/uvc_driver.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1261,1274 ****
  
  		break;
  
- 	case UVC_OTT_VENDOR_SPECIFIC:
- 	case UVC_OTT_DISPLAY:
- 	case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
- 		if (uvc_trace_param & UVC_TRACE_PROBE)
- 			printk(" OT %d", entity->id);
- 
- 		break;
- 
  	case UVC_TT_STREAMING:
  		if (UVC_ENTITY_IS_ITERM(entity)) {
  			if (uvc_trace_param & UVC_TRACE_PROBE)
--- 1261,1266 ----
diff -cBr 2.6.35/drivers/media/video/uvc/uvc_video.c linux-2.6.35.y-512ac85/drivers/media/video/uvc/uvc_video.c
*** 2.6.35/drivers/media/video/uvc/uvc_video.c	2011-05-07 19:57:18.386750002 -0400
--- linux-2.6.35.y-512ac85/drivers/media/video/uvc/uvc_video.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 65,84 ****
  static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
  	struct uvc_streaming_control *ctrl)
  {
! 	struct uvc_format *format = NULL;
  	struct uvc_frame *frame = NULL;
  	unsigned int i;
  
! 	for (i = 0; i < stream->nformats; ++i) {
! 		if (stream->format[i].index == ctrl->bFormatIndex) {
! 			format = &stream->format[i];
! 			break;
! 		}
! 	}
! 
! 	if (format == NULL)
  		return;
  
  	for (i = 0; i < format->nframes; ++i) {
  		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
  			frame = &format->frame[i];
--- 65,80 ----
  static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
  	struct uvc_streaming_control *ctrl)
  {
! 	struct uvc_format *format;
  	struct uvc_frame *frame = NULL;
  	unsigned int i;
  
! 	if (ctrl->bFormatIndex <= 0 ||
! 	    ctrl->bFormatIndex > stream->nformats)
  		return;
  
+ 	format = &stream->format[ctrl->bFormatIndex - 1];
+ 
  	for (i = 0; i < format->nframes; ++i) {
  		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
  			frame = &format->frame[i];
diff -cBr 2.6.35/drivers/message/fusion/mptctl.c linux-2.6.35.y-512ac85/drivers/message/fusion/mptctl.c
*** 2.6.35/drivers/message/fusion/mptctl.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/message/fusion/mptctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 588,600 ****
  }
  
  static int
- mptctl_release(struct inode *inode, struct file *filep)
- {
- 	fasync_helper(-1, filep, 0, &async_queue);
- 	return 0;
- }
- 
- static int
  mptctl_fasync(int fd, struct file *filep, int mode)
  {
  	MPT_ADAPTER	*ioc;
--- 588,593 ----
***************
*** 2803,2809 ****
  	.llseek =	no_llseek,
  	.fasync = 	mptctl_fasync,
  	.unlocked_ioctl = mptctl_ioctl,
- 	.release =	mptctl_release,
  #ifdef CONFIG_COMPAT
  	.compat_ioctl = compat_mpctl_ioctl,
  #endif
--- 2796,2801 ----
diff -cBr 2.6.35/drivers/message/fusion/mptscsih.c linux-2.6.35.y-512ac85/drivers/message/fusion/mptscsih.c
*** 2.6.35/drivers/message/fusion/mptscsih.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/message/fusion/mptscsih.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1848,1856 ****
  	}
  
   out:
! 	printk(MYIOC_s_INFO_FMT "task abort: %s (rv=%04x) (sc=%p) (sn=%ld)\n",
! 	    ioc->name, ((retval == SUCCESS) ? "SUCCESS" : "FAILED"), retval,
! 	    SCpnt, SCpnt->serial_number);
  
  	return retval;
  }
--- 1848,1855 ----
  	}
  
   out:
! 	printk(MYIOC_s_INFO_FMT "task abort: %s (sc=%p)\n",
! 	    ioc->name, ((retval == SUCCESS) ? "SUCCESS" : "FAILED"), SCpnt);
  
  	return retval;
  }
***************
*** 1887,1893 ****
  
  	vdevice = SCpnt->device->hostdata;
  	if (!vdevice || !vdevice->vtarget) {
! 		retval = 0;
  		goto out;
  	}
  
--- 1886,1892 ----
  
  	vdevice = SCpnt->device->hostdata;
  	if (!vdevice || !vdevice->vtarget) {
! 		retval = SUCCESS;
  		goto out;
  	}
  
diff -cBr 2.6.35/drivers/mfd/ab3100-core.c linux-2.6.35.y-512ac85/drivers/mfd/ab3100-core.c
*** 2.6.35/drivers/mfd/ab3100-core.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mfd/ab3100-core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 611,617 ****
  	ab3100_get_priv.ab3100 = ab3100;
  	ab3100_get_priv.mode = false;
  	ab3100_get_reg_file = debugfs_create_file("get_reg",
! 				S_IWUSR, ab3100_dir, &ab3100_get_priv,
  				&ab3100_get_set_reg_fops);
  	if (!ab3100_get_reg_file) {
  		err = -ENOMEM;
--- 611,617 ----
  	ab3100_get_priv.ab3100 = ab3100;
  	ab3100_get_priv.mode = false;
  	ab3100_get_reg_file = debugfs_create_file("get_reg",
! 				S_IWUGO, ab3100_dir, &ab3100_get_priv,
  				&ab3100_get_set_reg_fops);
  	if (!ab3100_get_reg_file) {
  		err = -ENOMEM;
***************
*** 621,627 ****
  	ab3100_set_priv.ab3100 = ab3100;
  	ab3100_set_priv.mode = true;
  	ab3100_set_reg_file = debugfs_create_file("set_reg",
! 				S_IWUSR, ab3100_dir, &ab3100_set_priv,
  				&ab3100_get_set_reg_fops);
  	if (!ab3100_set_reg_file) {
  		err = -ENOMEM;
--- 621,627 ----
  	ab3100_set_priv.ab3100 = ab3100;
  	ab3100_set_priv.mode = true;
  	ab3100_set_reg_file = debugfs_create_file("set_reg",
! 				S_IWUGO, ab3100_dir, &ab3100_set_priv,
  				&ab3100_get_set_reg_fops);
  	if (!ab3100_set_reg_file) {
  		err = -ENOMEM;
Only in 2.6.35/drivers/mfd: max8998.c
diff -cBr 2.6.35/drivers/mfd/ucb1x00-ts.c linux-2.6.35.y-512ac85/drivers/mfd/ucb1x00-ts.c
*** 2.6.35/drivers/mfd/ucb1x00-ts.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mfd/ucb1x00-ts.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 385,402 ****
  	idev->close      = ucb1x00_ts_close;
  
  	__set_bit(EV_ABS, idev->evbit);
  
  	input_set_drvdata(idev, ts);
  
- 	ucb1x00_adc_enable(ts->ucb);
- 	ts->x_res = ucb1x00_ts_read_xres(ts);
- 	ts->y_res = ucb1x00_ts_read_yres(ts);
- 	ucb1x00_adc_disable(ts->ucb);
- 
- 	input_set_abs_params(idev, ABS_X, 0, ts->x_res, 0, 0);
- 	input_set_abs_params(idev, ABS_Y, 0, ts->y_res, 0, 0);
- 	input_set_abs_params(idev, ABS_PRESSURE, 0, 0, 0, 0);
- 
  	err = input_register_device(idev);
  	if (err)
  		goto fail;
--- 385,396 ----
  	idev->close      = ucb1x00_ts_close;
  
  	__set_bit(EV_ABS, idev->evbit);
+ 	__set_bit(ABS_X, idev->absbit);
+ 	__set_bit(ABS_Y, idev->absbit);
+ 	__set_bit(ABS_PRESSURE, idev->absbit);
  
  	input_set_drvdata(idev, ts);
  
  	err = input_register_device(idev);
  	if (err)
  		goto fail;
diff -cBr 2.6.35/drivers/mfd/wm831x-core.c linux-2.6.35.y-512ac85/drivers/mfd/wm831x-core.c
*** 2.6.35/drivers/mfd/wm831x-core.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mfd/wm831x-core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1463,1473 ****
  		dev_err(wm831x->dev, "Failed to read parent ID: %d\n", ret);
  		goto err;
  	}
! 	switch (ret) {
! 	case 0x6204:
! 	case 0x6246:
! 		break;
! 	default:
  		dev_err(wm831x->dev, "Device is not a WM831x: ID %x\n", ret);
  		ret = -EINVAL;
  		goto err;
--- 1463,1469 ----
  		dev_err(wm831x->dev, "Failed to read parent ID: %d\n", ret);
  		goto err;
  	}
! 	if (ret != 0x6204) {
  		dev_err(wm831x->dev, "Device is not a WM831x: ID %x\n", ret);
  		ret = -EINVAL;
  		goto err;
***************
*** 1608,1614 ****
  	case WM8320:
  		ret = mfd_add_devices(wm831x->dev, -1,
  				      wm8320_devs, ARRAY_SIZE(wm8320_devs),
! 				      NULL, wm831x->irq_base);
  		break;
  
  	default:
--- 1604,1610 ----
  	case WM8320:
  		ret = mfd_add_devices(wm831x->dev, -1,
  				      wm8320_devs, ARRAY_SIZE(wm8320_devs),
! 				      NULL, 0);
  		break;
  
  	default:
diff -cBr 2.6.35/drivers/misc/ad525x_dpot-spi.c linux-2.6.35.y-512ac85/drivers/misc/ad525x_dpot-spi.c
*** 2.6.35/drivers/misc/ad525x_dpot-spi.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/misc/ad525x_dpot-spi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 53,65 ****
  static int write16(void *client, u8 reg, u8 val)
  {
  	u8 data[2] = {reg, val};
! 	return spi_write(client, data, 2);
  }
  
  static int write24(void *client, u8 reg, u16 val)
  {
  	u8 data[3] = {reg, val >> 8, val};
! 	return spi_write(client, data, 3);
  }
  
  static int read8(void *client)
--- 53,65 ----
  static int write16(void *client, u8 reg, u8 val)
  {
  	u8 data[2] = {reg, val};
! 	return spi_write(client, data, 1);
  }
  
  static int write24(void *client, u8 reg, u16 val)
  {
  	u8 data[3] = {reg, val >> 8, val};
! 	return spi_write(client, data, 1);
  }
  
  static int read8(void *client)
Only in 2.6.35/drivers/misc: ak8973.c
Only in 2.6.35/drivers/misc: ak8973-reg.h
Only in 2.6.35/drivers/misc: akm8975.c
Only in 2.6.35/drivers/misc: apanic.c
diff -cBr 2.6.35/drivers/misc/ep93xx_pwm.c linux-2.6.35.y-512ac85/drivers/misc/ep93xx_pwm.c
*** 2.6.35/drivers/misc/ep93xx_pwm.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/misc/ep93xx_pwm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 249,259 ****
  
  static DEVICE_ATTR(min_freq, S_IRUGO, ep93xx_pwm_get_min_freq, NULL);
  static DEVICE_ATTR(max_freq, S_IRUGO, ep93xx_pwm_get_max_freq, NULL);
! static DEVICE_ATTR(freq, S_IWUSR | S_IRUGO,
  		   ep93xx_pwm_get_freq, ep93xx_pwm_set_freq);
! static DEVICE_ATTR(duty_percent, S_IWUSR | S_IRUGO,
  		   ep93xx_pwm_get_duty_percent, ep93xx_pwm_set_duty_percent);
! static DEVICE_ATTR(invert, S_IWUSR | S_IRUGO,
  		   ep93xx_pwm_get_invert, ep93xx_pwm_set_invert);
  
  static struct attribute *ep93xx_pwm_attrs[] = {
--- 249,259 ----
  
  static DEVICE_ATTR(min_freq, S_IRUGO, ep93xx_pwm_get_min_freq, NULL);
  static DEVICE_ATTR(max_freq, S_IRUGO, ep93xx_pwm_get_max_freq, NULL);
! static DEVICE_ATTR(freq, S_IWUGO | S_IRUGO,
  		   ep93xx_pwm_get_freq, ep93xx_pwm_set_freq);
! static DEVICE_ATTR(duty_percent, S_IWUGO | S_IRUGO,
  		   ep93xx_pwm_get_duty_percent, ep93xx_pwm_set_duty_percent);
! static DEVICE_ATTR(invert, S_IWUGO | S_IRUGO,
  		   ep93xx_pwm_get_invert, ep93xx_pwm_set_invert);
  
  static struct attribute *ep93xx_pwm_attrs[] = {
Only in 2.6.35/drivers/misc: fsa9480.c
Only in 2.6.35/drivers/misc: kernel_debugger.c
Only in 2.6.35/drivers/misc: kr3dm.c
Only in 2.6.35/drivers/misc: kr3dm_reg.h
Only in 2.6.35/drivers/misc: orientation.c
Only in 2.6.35/drivers/misc: pmem.c
Only in 2.6.35/drivers/misc: pn544.c
Only in 2.6.35/drivers/misc: samsung_modemctl
Only in 2.6.35/drivers/misc: sec_jack.c
diff -cBr 2.6.35/drivers/misc/sgi-xp/xpc_partition.c linux-2.6.35.y-512ac85/drivers/misc/sgi-xp/xpc_partition.c
*** 2.6.35/drivers/misc/sgi-xp/xpc_partition.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/misc/sgi-xp/xpc_partition.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 439,461 ****
  	 * nodes that can comprise an access protection grouping. The access
  	 * protection is in regards to memory, IOI and IPI.
  	 */
  	region_size = xp_region_size;
  
! 	if (is_uv())
! 		max_regions = 256;
! 	else {
! 		max_regions = 64;
! 
! 		switch (region_size) {
! 		case 128:
! 			max_regions *= 2;
! 		case 64:
! 			max_regions *= 2;
! 		case 32:
! 			max_regions *= 2;
! 			region_size = 16;
! 			DBUG_ON(!is_shub2());
! 		}
  	}
  
  	for (region = 0; region < max_regions; region++) {
--- 439,456 ----
  	 * nodes that can comprise an access protection grouping. The access
  	 * protection is in regards to memory, IOI and IPI.
  	 */
+ 	max_regions = 64;
  	region_size = xp_region_size;
  
! 	switch (region_size) {
! 	case 128:
! 		max_regions *= 2;
! 	case 64:
! 		max_regions *= 2;
! 	case 32:
! 		max_regions *= 2;
! 		region_size = 16;
! 		DBUG_ON(!is_shub2());
  	}
  
  	for (region = 0; region < max_regions; region++) {
Only in 2.6.35/drivers/misc: uid_stat.c
Only in 2.6.35/drivers/misc: wl127x-rfkill.c
diff -cBr 2.6.35/drivers/mmc/core/core.c linux-2.6.35.y-512ac85/drivers/mmc/core/core.c
*** 2.6.35/drivers/mmc/core/core.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mmc/core/core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1160,1166 ****
  
  	if (host->caps & MMC_CAP_DISABLE)
  		cancel_delayed_work(&host->disable);
! 	cancel_delayed_work_sync(&host->detect);
  	mmc_flush_scheduled_work();
  
  	/* clear pm flags now and let card drivers set them as needed */
--- 1160,1166 ----
  
  	if (host->caps & MMC_CAP_DISABLE)
  		cancel_delayed_work(&host->disable);
! 	cancel_delayed_work(&host->detect);
  	mmc_flush_scheduled_work();
  
  	/* clear pm flags now and let card drivers set them as needed */
***************
*** 1366,1372 ****
  
  	case PM_POST_SUSPEND:
  	case PM_POST_HIBERNATION:
- 	case PM_POST_RESTORE:
  
  		spin_lock_irqsave(&host->lock, flags);
  		host->rescan_disable = 0;
--- 1366,1371 ----
diff -cBr 2.6.35/drivers/mmc/core/sdio.c linux-2.6.35.y-512ac85/drivers/mmc/core/sdio.c
*** 2.6.35/drivers/mmc/core/sdio.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mmc/core/sdio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 309,322 ****
  		if (err)
  			goto remove;
  
- 		/*
- 		 * Update oldcard with the new RCA received from the SDIO
- 		 * device -- we're doing this so that it's updated in the
- 		 * "card" struct when oldcard overwrites that later.
- 		 */
- 		if (oldcard)
- 			oldcard->rca = card->rca;
- 
  		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
  	}
  
--- 309,314 ----
diff -cBr 2.6.35/drivers/mmc/host/at91_mci.c linux-2.6.35.y-512ac85/drivers/mmc/host/at91_mci.c
*** 2.6.35/drivers/mmc/host/at91_mci.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mmc/host/at91_mci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 68,74 ****
  #include <linux/gfp.h>
  
  #include <linux/mmc/host.h>
- #include <linux/mmc/sdio.h>
  
  #include <asm/io.h>
  #include <asm/irq.h>
--- 68,73 ----
***************
*** 493,506 ****
  		else if (data->flags & MMC_DATA_WRITE)
  			cmdr |= AT91_MCI_TRCMD_START;
  
! 		if (cmd->opcode == SD_IO_RW_EXTENDED) {
! 			cmdr |= AT91_MCI_TRTYP_SDIO_BLOCK;
! 		} else {
! 			if (data->flags & MMC_DATA_STREAM)
! 				cmdr |= AT91_MCI_TRTYP_STREAM;
! 			if (data->blocks > 1)
! 				cmdr |= AT91_MCI_TRTYP_MULTIPLE;
! 		}
  	}
  	else {
  		block_length = 0;
--- 492,501 ----
  		else if (data->flags & MMC_DATA_WRITE)
  			cmdr |= AT91_MCI_TRCMD_START;
  
! 		if (data->flags & MMC_DATA_STREAM)
! 			cmdr |= AT91_MCI_TRTYP_STREAM;
! 		if (data->blocks > 1)
! 			cmdr |= AT91_MCI_TRTYP_MULTIPLE;
  	}
  	else {
  		block_length = 0;
diff -cBr 2.6.35/drivers/mmc/host/atmel-mci.c linux-2.6.35.y-512ac85/drivers/mmc/host/atmel-mci.c
*** 2.6.35/drivers/mmc/host/atmel-mci.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mmc/host/atmel-mci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 26,32 ****
  #include <linux/stat.h>
  
  #include <linux/mmc/host.h>
- #include <linux/mmc/sdio.h>
  
  #include <mach/atmel-mci.h>
  #include <linux/atmel-mci.h>
--- 26,31 ----
***************
*** 533,549 ****
  	data = cmd->data;
  	if (data) {
  		cmdr |= MCI_CMDR_START_XFER;
! 
! 		if (cmd->opcode == SD_IO_RW_EXTENDED) {
! 			cmdr |= MCI_CMDR_SDIO_BLOCK;
! 		} else {
! 			if (data->flags & MMC_DATA_STREAM)
! 				cmdr |= MCI_CMDR_STREAM;
! 			else if (data->blocks > 1)
! 				cmdr |= MCI_CMDR_MULTI_BLOCK;
! 			else
! 				cmdr |= MCI_CMDR_BLOCK;
! 		}
  
  		if (data->flags & MMC_DATA_READ)
  			cmdr |= MCI_CMDR_TRDIR_READ;
--- 532,543 ----
  	data = cmd->data;
  	if (data) {
  		cmdr |= MCI_CMDR_START_XFER;
! 		if (data->flags & MMC_DATA_STREAM)
! 			cmdr |= MCI_CMDR_STREAM;
! 		else if (data->blocks > 1)
! 			cmdr |= MCI_CMDR_MULTI_BLOCK;
! 		else
! 			cmdr |= MCI_CMDR_BLOCK;
  
  		if (data->flags & MMC_DATA_READ)
  			cmdr |= MCI_CMDR_TRDIR_READ;
diff -cBr 2.6.35/drivers/mtd/nand/omap2.c linux-2.6.35.y-512ac85/drivers/mtd/nand/omap2.c
*** 2.6.35/drivers/mtd/nand/omap2.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mtd/nand/omap2.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1077,1082 ****
  module_init(omap_nand_init);
  module_exit(omap_nand_exit);
  
! MODULE_ALIAS("platform:" DRIVER_NAME);
  MODULE_LICENSE("GPL");
  MODULE_DESCRIPTION("Glue layer for NAND flash on TI OMAP boards");
--- 1077,1082 ----
  module_init(omap_nand_init);
  module_exit(omap_nand_exit);
  
! MODULE_ALIAS(DRIVER_NAME);
  MODULE_LICENSE("GPL");
  MODULE_DESCRIPTION("Glue layer for NAND flash on TI OMAP boards");
diff -cBr 2.6.35/drivers/mtd/onenand/generic.c linux-2.6.35.y-512ac85/drivers/mtd/onenand/generic.c
*** 2.6.35/drivers/mtd/onenand/generic.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mtd/onenand/generic.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 131,137 ****
  	.remove		= __devexit_p(generic_onenand_remove),
  };
  
! MODULE_ALIAS("platform:" DRIVER_NAME);
  
  static int __init generic_onenand_init(void)
  {
--- 131,137 ----
  	.remove		= __devexit_p(generic_onenand_remove),
  };
  
! MODULE_ALIAS(DRIVER_NAME);
  
  static int __init generic_onenand_init(void)
  {
diff -cBr 2.6.35/drivers/mtd/onenand/omap2.c linux-2.6.35.y-512ac85/drivers/mtd/onenand/omap2.c
*** 2.6.35/drivers/mtd/onenand/omap2.c	2011-05-07 19:57:18.396750002 -0400
--- linux-2.6.35.y-512ac85/drivers/mtd/onenand/omap2.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 815,821 ****
  module_init(omap2_onenand_init);
  module_exit(omap2_onenand_exit);
  
! MODULE_ALIAS("platform:" DRIVER_NAME);
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jarkko Lavinen <jarkko.lavinen@nokia.com>");
  MODULE_DESCRIPTION("Glue layer for OneNAND flash on OMAP2 / OMAP3");
--- 815,821 ----
  module_init(omap2_onenand_init);
  module_exit(omap2_onenand_exit);
  
! MODULE_ALIAS(DRIVER_NAME);
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jarkko Lavinen <jarkko.lavinen@nokia.com>");
  MODULE_DESCRIPTION("Glue layer for OneNAND flash on OMAP2 / OMAP3");
Only in 2.6.35/drivers/mtd/onenand: samsung_captivate.h
Only in 2.6.35/drivers/mtd/onenand: samsung_fascinate.h
Only in 2.6.35/drivers/mtd/onenand: samsung_galaxys.h
Only in 2.6.35/drivers/mtd/onenand: samsung.h
Only in 2.6.35/drivers/mtd/onenand: samsung_vibrant.h
diff -cBr 2.6.35/drivers/net/8139cp.c linux-2.6.35.y-512ac85/drivers/net/8139cp.c
*** 2.6.35/drivers/net/8139cp.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/8139cp.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 490,500 ****
  {
  	unsigned int protocol = (status >> 16) & 0x3;
  
! 	if (((protocol == RxProtoTCP) && !(status & TCPFail)) ||
! 	    ((protocol == RxProtoUDP) && !(status & UDPFail)))
  		return 1;
! 	else
! 		return 0;
  }
  
  static int cp_rx_poll(struct napi_struct *napi, int budget)
--- 490,502 ----
  {
  	unsigned int protocol = (status >> 16) & 0x3;
  
! 	if (likely((protocol == RxProtoTCP) && (!(status & TCPFail))))
  		return 1;
! 	else if ((protocol == RxProtoUDP) && (!(status & UDPFail)))
! 		return 1;
! 	else if ((protocol == RxProtoIP) && (!(status & IPFail)))
! 		return 1;
! 	return 0;
  }
  
  static int cp_rx_poll(struct napi_struct *napi, int budget)
diff -cBr 2.6.35/drivers/net/benet/be_cmds.c linux-2.6.35.y-512ac85/drivers/net/benet/be_cmds.c
*** 2.6.35/drivers/net/benet/be_cmds.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/benet/be_cmds.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1176,1182 ****
  
  		i = 0;
  		netdev_for_each_mc_addr(ha, netdev)
! 			memcpy(req->mac[i++].byte, ha->addr, ETH_ALEN);
  	} else {
  		req->promiscuous = 1;
  	}
--- 1176,1182 ----
  
  		i = 0;
  		netdev_for_each_mc_addr(ha, netdev)
! 			memcpy(req->mac[i].byte, ha->addr, ETH_ALEN);
  	} else {
  		req->promiscuous = 1;
  	}
diff -cBr 2.6.35/drivers/net/bonding/bonding.h linux-2.6.35.y-512ac85/drivers/net/bonding/bonding.h
*** 2.6.35/drivers/net/bonding/bonding.h	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/bonding/bonding.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 235,245 ****
  
  	bond_for_each_slave(bond, slave, i) {
  		if (slave->dev == slave_dev) {
! 			return slave;
  		}
  	}
  
! 	return 0;
  }
  
  static inline struct bonding *bond_get_bond_by_slave(struct slave *slave)
--- 235,245 ----
  
  	bond_for_each_slave(bond, slave, i) {
  		if (slave->dev == slave_dev) {
! 			break;
  		}
  	}
  
! 	return slave;
  }
  
  static inline struct bonding *bond_get_bond_by_slave(struct slave *slave)
diff -cBr 2.6.35/drivers/net/bonding/bond_ipv6.c linux-2.6.35.y-512ac85/drivers/net/bonding/bond_ipv6.c
*** 2.6.35/drivers/net/bonding/bond_ipv6.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/bonding/bond_ipv6.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 70,82 ****
  	};
  	struct sk_buff *skb;
  
- 	/* The Ethernet header is built in ndisc_send_skb(), not
- 	 * ndisc_build_skb(), so we cannot insert a VLAN tag.  Only an
- 	 * out-of-line tag inserted by the hardware will work.
- 	 */
- 	if (vlan_id && !(slave_dev->features & NETIF_F_HW_VLAN_TX))
- 		return;
- 
  	icmp6h.icmp6_router = router;
  	icmp6h.icmp6_solicited = 0;
  	icmp6h.icmp6_override = 1;
--- 70,75 ----
***************
*** 95,101 ****
  	}
  
  	if (vlan_id) {
! 		skb = __vlan_hwaccel_put_tag(skb, vlan_id);
  		if (!skb) {
  			pr_err("failed to insert VLAN tag\n");
  			return;
--- 88,94 ----
  	}
  
  	if (vlan_id) {
! 		skb = vlan_put_tag(skb, vlan_id);
  		if (!skb) {
  			pr_err("failed to insert VLAN tag\n");
  			return;
diff -cBr 2.6.35/drivers/net/e1000/e1000_main.c linux-2.6.35.y-512ac85/drivers/net/e1000/e1000_main.c
*** 2.6.35/drivers/net/e1000/e1000_main.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/e1000/e1000_main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 31,37 ****
  
  char e1000_driver_name[] = "e1000";
  static char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
! #define DRV_VERSION "7.3.21-k8-NAPI"
  const char e1000_driver_version[] = DRV_VERSION;
  static const char e1000_copyright[] = "Copyright (c) 1999-2006 Intel Corporation.";
  
--- 31,37 ----
  
  char e1000_driver_name[] = "e1000";
  static char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
! #define DRV_VERSION "7.3.21-k6-NAPI"
  const char e1000_driver_version[] = DRV_VERSION;
  static const char e1000_copyright[] = "Copyright (c) 1999-2006 Intel Corporation.";
  
***************
*** 483,488 ****
--- 483,491 ----
  	struct net_device *netdev = adapter->netdev;
  	u32 rctl, tctl;
  
+ 	/* signal that we're down so the interrupt handler does not
+ 	 * reschedule our watchdog timer */
+ 	set_bit(__E1000_DOWN, &adapter->flags);
  
  	/* disable receives in the hardware */
  	rctl = er32(RCTL);
***************
*** 503,515 ****
  
  	e1000_irq_disable(adapter);
  
- 	/*
- 	 * Setting DOWN must be after irq_disable to prevent
- 	 * a screaming interrupt.  Setting DOWN also prevents
- 	 * timers and tasks from rescheduling.
- 	 */
- 	set_bit(__E1000_DOWN, &adapter->flags);
- 
  	del_timer_sync(&adapter->tx_fifo_stall_timer);
  	del_timer_sync(&adapter->watchdog_timer);
  	del_timer_sync(&adapter->phy_info_timer);
--- 506,511 ----
diff -cBr 2.6.35/drivers/net/e1000e/netdev.c linux-2.6.35.y-512ac85/drivers/net/e1000e/netdev.c
*** 2.6.35/drivers/net/e1000e/netdev.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/e1000e/netdev.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 5678,5685 ****
  		/* APME bit in EEPROM is mapped to WUC.APME */
  		eeprom_data = er32(WUC);
  		eeprom_apme_mask = E1000_WUC_APME;
! 		if ((hw->mac.type > e1000_ich10lan) &&
! 		    (eeprom_data & E1000_WUC_PHY_WAKE))
  			adapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;
  	} else if (adapter->flags & FLAG_APME_IN_CTRL3) {
  		if (adapter->flags & FLAG_APME_CHECK_PORT_B &&
--- 5678,5684 ----
  		/* APME bit in EEPROM is mapped to WUC.APME */
  		eeprom_data = er32(WUC);
  		eeprom_apme_mask = E1000_WUC_APME;
! 		if (eeprom_data & E1000_WUC_PHY_WAKE)
  			adapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;
  	} else if (adapter->flags & FLAG_APME_IN_CTRL3) {
  		if (adapter->flags & FLAG_APME_CHECK_PORT_B &&
diff -cBr 2.6.35/drivers/net/ifb.c linux-2.6.35.y-512ac85/drivers/net/ifb.c
*** 2.6.35/drivers/net/ifb.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/ifb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 104,111 ****
  			rcu_read_unlock();
  			dev_kfree_skb(skb);
  			stats->tx_dropped++;
- 			if (skb_queue_len(&dp->tq) != 0)
- 				goto resched;
  			break;
  		}
  		rcu_read_unlock();
--- 104,109 ----
diff -cBr 2.6.35/drivers/net/igbvf/igbvf.h linux-2.6.35.y-512ac85/drivers/net/igbvf/igbvf.h
*** 2.6.35/drivers/net/igbvf/igbvf.h	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/igbvf/igbvf.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 126,131 ****
--- 126,132 ----
  			unsigned int page_offset;
  		};
  	};
+ 	struct page *page;
  };
  
  union igbvf_desc {
diff -cBr 2.6.35/drivers/net/ixgbe/ixgbe_main.c linux-2.6.35.y-512ac85/drivers/net/ixgbe/ixgbe_main.c
*** 2.6.35/drivers/net/ixgbe/ixgbe_main.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/ixgbe/ixgbe_main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2658,2667 ****
  	if (!adapter->num_vfs)
  		adapter->flags |= IXGBE_FLAG_RX_PS_ENABLED;
  
- 	/* Disable packet split due to 82599 erratum #45 */
- 	if (hw->mac.type == ixgbe_mac_82599EB)
- 		adapter->flags &= ~IXGBE_FLAG_RX_PS_ENABLED;
- 
  	/* Set the RX buffer length according to the mode */
  	if (adapter->flags & IXGBE_FLAG_RX_PS_ENABLED) {
  		rx_buf_len = IXGBE_RX_HDR_SIZE;
--- 2658,2663 ----
diff -cBr 2.6.35/drivers/net/jme.c linux-2.6.35.y-512ac85/drivers/net/jme.c
*** 2.6.35/drivers/net/jme.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/jme.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1575,1590 ****
  	}
  }
  
- static inline void
- jme_phy_on(struct jme_adapter *jme)
- {
- 	u32 bmcr;
- 
- 	bmcr = jme_mdio_read(jme->dev, jme->mii_if.phy_id, MII_BMCR);
- 	bmcr &= ~BMCR_PDOWN;
- 	jme_mdio_write(jme->dev, jme->mii_if.phy_id, MII_BMCR, bmcr);
- }
- 
  static int
  jme_open(struct net_device *netdev)
  {
--- 1575,1580 ----
***************
*** 1605,1616 ****
  
  	jme_start_irq(jme);
  
! 	if (test_bit(JME_FLAG_SSET, &jme->flags)) {
! 		jme_phy_on(jme);
  		jme_set_settings(netdev, &jme->old_ecmd);
! 	} else {
  		jme_reset_phy_processor(jme);
- 	}
  
  	jme_reset_link(jme);
  
--- 1595,1604 ----
  
  	jme_start_irq(jme);
  
! 	if (test_bit(JME_FLAG_SSET, &jme->flags))
  		jme_set_settings(netdev, &jme->old_ecmd);
! 	else
  		jme_reset_phy_processor(jme);
  
  	jme_reset_link(jme);
  
***************
*** 3018,3029 ****
  	jme_clear_pm(jme);
  	pci_restore_state(pdev);
  
! 	if (test_bit(JME_FLAG_SSET, &jme->flags)) {
! 		jme_phy_on(jme);
  		jme_set_settings(netdev, &jme->old_ecmd);
! 	} else {
  		jme_reset_phy_processor(jme);
- 	}
  
  	jme_start_irq(jme);
  	netif_device_attach(netdev);
--- 3006,3015 ----
  	jme_clear_pm(jme);
  	pci_restore_state(pdev);
  
! 	if (test_bit(JME_FLAG_SSET, &jme->flags))
  		jme_set_settings(netdev, &jme->old_ecmd);
! 	else
  		jme_reset_phy_processor(jme);
  
  	jme_start_irq(jme);
  	netif_device_attach(netdev);
diff -cBr 2.6.35/drivers/net/myri10ge/myri10ge.c linux-2.6.35.y-512ac85/drivers/net/myri10ge/myri10ge.c
*** 2.6.35/drivers/net/myri10ge/myri10ge.c	2011-05-07 19:57:18.406750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/myri10ge/myri10ge.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3600,3606 ****
  			dma_free_coherent(&pdev->dev, bytes,
  					  ss->fw_stats, ss->fw_stats_bus);
  			ss->fw_stats = NULL;
- 			netif_napi_del(&ss->napi);
  		}
  	}
  	kfree(mgp->ss);
--- 3600,3605 ----
diff -cBr 2.6.35/drivers/net/pcmcia/pcnet_cs.c linux-2.6.35.y-512ac85/drivers/net/pcmcia/pcnet_cs.c
*** 2.6.35/drivers/net/pcmcia/pcnet_cs.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/pcmcia/pcnet_cs.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1602,1608 ****
  	PCMCIA_DEVICE_PROD_ID12("COMPU-SHACK", "FASTline PCMCIA 10/100 Fast-Ethernet", 0xfa2e424d, 0x3953d9b9),
  	PCMCIA_DEVICE_PROD_ID12("CONTEC", "C-NET(PC)C-10L", 0x21cab552, 0xf6f90722),
  	PCMCIA_DEVICE_PROD_ID12("corega", "FEther PCC-TXF", 0x0a21501a, 0xa51564a2),
- 	PCMCIA_DEVICE_PROD_ID12("corega", "Ether CF-TD", 0x0a21501a, 0x6589340a),
  	PCMCIA_DEVICE_PROD_ID12("corega K.K.", "corega EtherII PCC-T", 0x5261440f, 0xfa9d85bd),
  	PCMCIA_DEVICE_PROD_ID12("corega K.K.", "corega EtherII PCC-TD", 0x5261440f, 0xc49bd73d),
  	PCMCIA_DEVICE_PROD_ID12("Corega K.K.", "corega EtherII PCC-TD", 0xd4fdcbd8, 0xc49bd73d),
--- 1602,1607 ----
Only in 2.6.35/drivers/net: pppolac.c
Only in 2.6.35/drivers/net: pppopns.c
diff -cBr 2.6.35/drivers/net/r8169.c linux-2.6.35.y-512ac85/drivers/net/r8169.c
*** 2.6.35/drivers/net/r8169.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/r8169.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 24,30 ****
  #include <linux/init.h>
  #include <linux/dma-mapping.h>
  #include <linux/pm_runtime.h>
- #include <linux/pci-aspm.h>
  
  #include <asm/system.h>
  #include <asm/io.h>
--- 24,29 ----
***************
*** 856,865 ****
  	else
  		tp->features &= ~RTL_FEATURE_WOL;
  	__rtl8169_set_wol(tp, wol->wolopts);
- 	spin_unlock_irq(&tp->lock);
- 
  	device_set_wakeup_enable(&tp->pci_dev->dev, wol->wolopts);
  
  	return 0;
  }
  
--- 855,864 ----
  	else
  		tp->features &= ~RTL_FEATURE_WOL;
  	__rtl8169_set_wol(tp, wol->wolopts);
  	device_set_wakeup_enable(&tp->pci_dev->dev, wol->wolopts);
  
+ 	spin_unlock_irq(&tp->lock);
+ 
  	return 0;
  }
  
***************
*** 3041,3051 ****
  	mii->reg_num_mask = 0x1f;
  	mii->supports_gmii = !!(cfg->features & RTL_FEATURE_GMII);
  
- 	/* disable ASPM completely as that cause random device stop working
- 	 * problems as well as full system hangs for some PCIe devices users */
- 	pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
- 				     PCIE_LINK_STATE_CLKPM);
- 
  	/* enable device (incl. PCI PM wakeup and hotplug setup) */
  	rc = pci_enable_device(pdev);
  	if (rc < 0) {
--- 3040,3045 ----
***************
*** 3750,3757 ****
  	RTL_W16(IntrMitigate, 0x5151);
  
  	/* Work around for RxFIFO overflow. */
! 	if (tp->mac_version == RTL_GIGA_MAC_VER_11 ||
! 	    tp->mac_version == RTL_GIGA_MAC_VER_22) {
  		tp->intr_event |= RxFIFOOver | PCSTimeout;
  		tp->intr_event &= ~RxOverflow;
  	}
--- 3744,3750 ----
  	RTL_W16(IntrMitigate, 0x5151);
  
  	/* Work around for RxFIFO overflow. */
! 	if (tp->mac_version == RTL_GIGA_MAC_VER_11) {
  		tp->intr_event |= RxFIFOOver | PCSTimeout;
  		tp->intr_event &= ~RxOverflow;
  	}
***************
*** 4465,4476 ****
  	return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
  }
  
! static inline void rtl8169_rx_csum(struct sk_buff *skb, u32 opts1)
  {
  	u32 status = opts1 & RxProtoMask;
  
  	if (((status == RxProtoTCP) && !(opts1 & TCPFail)) ||
! 	    ((status == RxProtoUDP) && !(opts1 & UDPFail)))
  		skb->ip_summed = CHECKSUM_UNNECESSARY;
  	else
  		skb->ip_summed = CHECKSUM_NONE;
--- 4458,4471 ----
  	return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
  }
  
! static inline void rtl8169_rx_csum(struct sk_buff *skb, struct RxDesc *desc)
  {
+ 	u32 opts1 = le32_to_cpu(desc->opts1);
  	u32 status = opts1 & RxProtoMask;
  
  	if (((status == RxProtoTCP) && !(opts1 & TCPFail)) ||
! 	    ((status == RxProtoUDP) && !(opts1 & UDPFail)) ||
! 	    ((status == RxProtoIP) && !(opts1 & IPFail)))
  		skb->ip_summed = CHECKSUM_UNNECESSARY;
  	else
  		skb->ip_summed = CHECKSUM_NONE;
***************
*** 4559,4564 ****
--- 4554,4561 ----
  				continue;
  			}
  
+ 			rtl8169_rx_csum(skb, desc);
+ 
  			if (rtl8169_try_rx_copy(&skb, tp, pkt_size, addr)) {
  				pci_dma_sync_single_for_device(pdev, addr,
  					pkt_size, PCI_DMA_FROMDEVICE);
***************
*** 4569,4575 ****
  				tp->Rx_skbuff[entry] = NULL;
  			}
  
- 			rtl8169_rx_csum(skb, status);
  			skb_put(skb, pkt_size);
  			skb->protocol = eth_type_trans(skb, dev);
  
--- 4566,4571 ----
***************
*** 4638,4645 ****
  
  		/* Work around for rx fifo overflow */
  		if (unlikely(status & RxFIFOOver) &&
! 		    (tp->mac_version == RTL_GIGA_MAC_VER_11 ||
! 		     tp->mac_version == RTL_GIGA_MAC_VER_22)) {
  			netif_stop_queue(dev);
  			rtl8169_tx_timeout(dev);
  			break;
--- 4634,4640 ----
  
  		/* Work around for rx fifo overflow */
  		if (unlikely(status & RxFIFOOver) &&
! 		(tp->mac_version == RTL_GIGA_MAC_VER_11)) {
  			netif_stop_queue(dev);
  			rtl8169_tx_timeout(dev);
  			break;
***************
*** 4900,4908 ****
  {
  	struct pci_dev *pdev = to_pci_dev(device);
  	struct net_device *dev = pci_get_drvdata(pdev);
- 	struct rtl8169_private *tp = netdev_priv(dev);
- 
- 	rtl8169_init_phy(dev, tp);
  
  	if (netif_running(dev))
  		__rtl8169_resume(dev);
--- 4895,4900 ----
***************
*** 4943,4950 ****
  	tp->saved_wolopts = 0;
  	spin_unlock_irq(&tp->lock);
  
- 	rtl8169_init_phy(dev, tp);
- 
  	__rtl8169_resume(dev);
  
  	return 0;
--- 4935,4940 ----
diff -cBr 2.6.35/drivers/net/tehuti.c linux-2.6.35.y-512ac85/drivers/net/tehuti.c
*** 2.6.35/drivers/net/tehuti.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/tehuti.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 324,330 ****
  	ENTER;
  	master = READ_REG(priv, regINIT_SEMAPHORE);
  	if (!READ_REG(priv, regINIT_STATUS) && master) {
! 		rc = request_firmware(&fw, "tehuti/bdx.bin", &priv->pdev->dev);
  		if (rc)
  			goto out;
  		bdx_tx_push_desc_safe(priv, (char *)fw->data, fw->size);
--- 324,330 ----
  	ENTER;
  	master = READ_REG(priv, regINIT_SEMAPHORE);
  	if (!READ_REG(priv, regINIT_STATUS) && master) {
! 		rc = request_firmware(&fw, "tehuti/firmware.bin", &priv->pdev->dev);
  		if (rc)
  			goto out;
  		bdx_tx_push_desc_safe(priv, (char *)fw->data, fw->size);
***************
*** 2516,2519 ****
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR(DRIVER_AUTHOR);
  MODULE_DESCRIPTION(BDX_DRV_DESC);
! MODULE_FIRMWARE("tehuti/bdx.bin");
--- 2516,2519 ----
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR(DRIVER_AUTHOR);
  MODULE_DESCRIPTION(BDX_DRV_DESC);
! MODULE_FIRMWARE("tehuti/firmware.bin");
diff -cBr 2.6.35/drivers/net/usb/cdc-phonet.c linux-2.6.35.y-512ac85/drivers/net/usb/cdc-phonet.c
*** 2.6.35/drivers/net/usb/cdc-phonet.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/usb/cdc-phonet.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 326,338 ****
  {
  	static const char ifname[] = "usbpn%d";
  	const struct usb_cdc_union_desc *union_header = NULL;
  	const struct usb_host_interface *data_desc;
  	struct usb_interface *data_intf;
  	struct usb_device *usbdev = interface_to_usbdev(intf);
  	struct net_device *dev;
  	struct usbpn_dev *pnd;
  	u8 *data;
- 	int phonet = 0;
  	int len, err;
  
  	data = intf->altsetting->extra;
--- 326,338 ----
  {
  	static const char ifname[] = "usbpn%d";
  	const struct usb_cdc_union_desc *union_header = NULL;
+ 	const struct usb_cdc_header_desc *phonet_header = NULL;
  	const struct usb_host_interface *data_desc;
  	struct usb_interface *data_intf;
  	struct usb_device *usbdev = interface_to_usbdev(intf);
  	struct net_device *dev;
  	struct usbpn_dev *pnd;
  	u8 *data;
  	int len, err;
  
  	data = intf->altsetting->extra;
***************
*** 353,359 ****
  					(struct usb_cdc_union_desc *)data;
  				break;
  			case 0xAB:
! 				phonet = 1;
  				break;
  			}
  		}
--- 353,362 ----
  					(struct usb_cdc_union_desc *)data;
  				break;
  			case 0xAB:
! 				if (phonet_header || dlen < 5)
! 					break;
! 				phonet_header =
! 					(struct usb_cdc_header_desc *)data;
  				break;
  			}
  		}
***************
*** 361,367 ****
  		len -= dlen;
  	}
  
! 	if (!union_header || !phonet)
  		return -EINVAL;
  
  	data_intf = usb_ifnum_to_if(usbdev, union_header->bSlaveInterface0);
--- 364,370 ----
  		len -= dlen;
  	}
  
! 	if (!union_header || !phonet_header)
  		return -EINVAL;
  
  	data_intf = usb_ifnum_to_if(usbdev, union_header->bSlaveInterface0);
diff -cBr 2.6.35/drivers/net/usb/usbnet.c linux-2.6.35.y-512ac85/drivers/net/usb/usbnet.c
*** 2.6.35/drivers/net/usb/usbnet.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/usb/usbnet.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 44,50 ****
  #include <linux/usb.h>
  #include <linux/usb/usbnet.h>
  #include <linux/slab.h>
- #include <linux/pm_runtime.h>
  
  #define DRIVER_VERSION		"22-Aug-2005"
  
--- 44,49 ----
***************
*** 1273,1288 ****
  	struct usb_device		*xdev;
  	int				status;
  	const char			*name;
- 	struct usb_driver 	*driver = to_usb_driver(udev->dev.driver);
- 
- 	/* usbnet already took usb runtime pm, so have to enable the feature
- 	 * for usb interface, otherwise usb_autopm_get_interface may return
- 	 * failure if USB_SUSPEND(RUNTIME_PM) is enabled.
- 	 */
- 	if (!driver->supports_autosuspend) {
- 		driver->supports_autosuspend = 1;
- 		pm_runtime_enable(&udev->dev);
- 	}
  
  	name = udev->dev.driver->name;
  	info = (struct driver_info *) prod->driver_info;
--- 1272,1277 ----
diff -cBr 2.6.35/drivers/net/wireless/ath/ath9k/ath9k.h linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/ath9k.h
*** 2.6.35/drivers/net/wireless/ath/ath9k/ath9k.h	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/ath9k.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 174,181 ****
  
  /* returns delimiter padding required given the packet length */
  #define ATH_AGGR_GET_NDELIM(_len)					\
!        (((_len) >= ATH_AGGR_MINPLEN) ? 0 :                             \
!         DIV_ROUND_UP(ATH_AGGR_MINPLEN - (_len), ATH_AGGR_DELIM_SZ))
  
  #define BAW_WITHIN(_start, _bawsz, _seqno) \
  	((((_seqno) - (_start)) & 4095) < (_bawsz))
--- 174,181 ----
  
  /* returns delimiter padding required given the packet length */
  #define ATH_AGGR_GET_NDELIM(_len)					\
! 	(((((_len) + ATH_AGGR_DELIM_SZ) < ATH_AGGR_MINPLEN) ?           \
! 	  (ATH_AGGR_MINPLEN - (_len) - ATH_AGGR_DELIM_SZ) : 0) >> 2)
  
  #define BAW_WITHIN(_start, _bawsz, _seqno) \
  	((((_seqno) - (_start)) & 4095) < (_bawsz))
diff -cBr 2.6.35/drivers/net/wireless/ath/ath9k/eeprom_def.c linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/eeprom_def.c
*** 2.6.35/drivers/net/wireless/ath/ath9k/eeprom_def.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/eeprom_def.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1064,1082 ****
  	case 1:
  		break;
  	case 2:
! 		if (scaledPower > REDUCE_SCALED_POWER_BY_TWO_CHAIN)
! 			scaledPower -= REDUCE_SCALED_POWER_BY_TWO_CHAIN;
! 		else
! 			scaledPower = 0;
  		break;
  	case 3:
! 		if (scaledPower > REDUCE_SCALED_POWER_BY_THREE_CHAIN)
! 			scaledPower -= REDUCE_SCALED_POWER_BY_THREE_CHAIN;
! 		else
! 			scaledPower = 0;
  		break;
  	}
  
  	if (IS_CHAN_2GHZ(chan)) {
  		numCtlModes = ARRAY_SIZE(ctlModesFor11g) -
  			SUB_NUM_CTL_MODES_AT_2G_40;
--- 1064,1078 ----
  	case 1:
  		break;
  	case 2:
! 		scaledPower -= REDUCE_SCALED_POWER_BY_TWO_CHAIN;
  		break;
  	case 3:
! 		scaledPower -= REDUCE_SCALED_POWER_BY_THREE_CHAIN;
  		break;
  	}
  
+ 	scaledPower = max((u16)0, scaledPower);
+ 
  	if (IS_CHAN_2GHZ(chan)) {
  		numCtlModes = ARRAY_SIZE(ctlModesFor11g) -
  			SUB_NUM_CTL_MODES_AT_2G_40;
diff -cBr 2.6.35/drivers/net/wireless/ath/ath9k/hw.c linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/hw.c
*** 2.6.35/drivers/net/wireless/ath/ath9k/hw.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/hw.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 519,526 ****
  	if (ah->hw_version.devid == AR5416_AR9100_DEVID)
  		ah->hw_version.macVersion = AR_SREV_VERSION_9100;
  
- 	ath9k_hw_read_revisions(ah);
- 
  	if (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {
  		ath_print(common, ATH_DBG_FATAL,
  			  "Couldn't reset chip\n");
--- 519,524 ----
***************
*** 1098,1103 ****
--- 1096,1103 ----
  		return false;
  	}
  
+ 	ath9k_hw_read_revisions(ah);
+ 
  	return ath9k_hw_set_reset(ah, ATH9K_RESET_WARM);
  }
  
diff -cBr 2.6.35/drivers/net/wireless/ath/ath9k/main.c linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/main.c
*** 2.6.35/drivers/net/wireless/ath/ath9k/main.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/ath/ath9k/main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1124,1131 ****
  		  "Starting driver with initial channel: %d MHz\n",
  		  curchan->center_freq);
  
- 	ath9k_ps_wakeup(sc);
- 
  	mutex_lock(&sc->mutex);
  
  	if (ath9k_wiphy_started(sc)) {
--- 1124,1129 ----
***************
*** 1240,1247 ****
  mutex_unlock:
  	mutex_unlock(&sc->mutex);
  
- 	ath9k_ps_restore(sc);
- 
  	return r;
  }
  
--- 1238,1243 ----
***************
*** 1505,1511 ****
  	struct ath_softc *sc = aphy->sc;
  	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  	struct ath_vif *avp = (void *)vif->drv_priv;
- 	bool bs_valid = false;
  	int i;
  
  	ath_print(common, ATH_DBG_CONFIG, "Detach Interface\n");
--- 1501,1506 ----
***************
*** 1534,1548 ****
  			       "slot\n", __func__);
  			sc->beacon.bslot[i] = NULL;
  			sc->beacon.bslot_aphy[i] = NULL;
! 		} else if (sc->beacon.bslot[i])
! 			bs_valid = true;
! 	}
! 	if (!bs_valid && (sc->sc_ah->imask & ATH9K_INT_SWBA)) {
! 		/* Disable SWBA interrupt */
! 		sc->sc_ah->imask &= ~ATH9K_INT_SWBA;
! 		ath9k_ps_wakeup(sc);
! 		ath9k_hw_set_interrupts(sc->sc_ah, sc->sc_ah->imask);
! 		ath9k_ps_restore(sc);
  	}
  
  	sc->nvifs--;
--- 1529,1535 ----
  			       "slot\n", __func__);
  			sc->beacon.bslot[i] = NULL;
  			sc->beacon.bslot_aphy[i] = NULL;
! 		}
  	}
  
  	sc->nvifs--;
diff -cBr 2.6.35/drivers/net/wireless/ath/regd_common.h linux-2.6.35.y-512ac85/drivers/net/wireless/ath/regd_common.h
*** 2.6.35/drivers/net/wireless/ath/regd_common.h	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/ath/regd_common.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 195,201 ****
  	{APL9_WORLD, CTL_ETSI, CTL_ETSI},
  
  	{APL3_FCCA, CTL_FCC, CTL_FCC},
- 	{APL7_FCCA, CTL_FCC, CTL_FCC},
  	{APL1_ETSIC, CTL_FCC, CTL_ETSI},
  	{APL2_ETSIC, CTL_FCC, CTL_ETSI},
  	{APL2_APLD, CTL_FCC, NO_CTL},
--- 195,200 ----
diff -cBr 2.6.35/drivers/net/wireless/b43/dma.c linux-2.6.35.y-512ac85/drivers/net/wireless/b43/dma.c
*** 2.6.35/drivers/net/wireless/b43/dma.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/b43/dma.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1538,1544 ****
  		dmaaddr = meta->dmaaddr;
  		goto drop_recycle_buffer;
  	}
! 	if (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {
  		/* The data did not fit into one descriptor buffer
  		 * and is split over multiple buffers.
  		 * This should never happen, as we try to allocate buffers
--- 1538,1544 ----
  		dmaaddr = meta->dmaaddr;
  		goto drop_recycle_buffer;
  	}
! 	if (unlikely(len > ring->rx_buffersize)) {
  		/* The data did not fit into one descriptor buffer
  		 * and is split over multiple buffers.
  		 * This should never happen, as we try to allocate buffers
diff -cBr 2.6.35/drivers/net/wireless/b43/dma.h linux-2.6.35.y-512ac85/drivers/net/wireless/b43/dma.h
*** 2.6.35/drivers/net/wireless/b43/dma.h	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/b43/dma.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 163,169 ****
  /* DMA engine tuning knobs */
  #define B43_TXRING_SLOTS		256
  #define B43_RXRING_SLOTS		64
! #define B43_DMA0_RX_BUFFERSIZE		(B43_DMA0_RX_FRAMEOFFSET + IEEE80211_MAX_FRAME_LEN)
  
  /* Pointer poison */
  #define B43_DMA_PTR_POISON		((void *)ERR_PTR(-ENOMEM))
--- 163,169 ----
  /* DMA engine tuning knobs */
  #define B43_TXRING_SLOTS		256
  #define B43_RXRING_SLOTS		64
! #define B43_DMA0_RX_BUFFERSIZE		IEEE80211_MAX_FRAME_LEN
  
  /* Pointer poison */
  #define B43_DMA_PTR_POISON		((void *)ERR_PTR(-ENOMEM))
diff -cBr 2.6.35/drivers/net/wireless/b43/sdio.c linux-2.6.35.y-512ac85/drivers/net/wireless/b43/sdio.c
*** 2.6.35/drivers/net/wireless/b43/sdio.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/b43/sdio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 163,169 ****
  err_free_ssb:
  	kfree(sdio);
  err_disable_func:
- 	sdio_claim_host(func);
  	sdio_disable_func(func);
  err_release_host:
  	sdio_release_host(func);
--- 163,168 ----
***************
*** 176,184 ****
  	struct b43_sdio *sdio = sdio_get_drvdata(func);
  
  	ssb_bus_unregister(&sdio->ssb);
- 	sdio_claim_host(func);
  	sdio_disable_func(func);
- 	sdio_release_host(func);
  	kfree(sdio);
  	sdio_set_drvdata(func, NULL);
  }
--- 175,181 ----
Only in 2.6.35/drivers/net/wireless: bcm4329
diff -cBr 2.6.35/drivers/net/wireless/hostap/hostap_cs.c linux-2.6.35.y-512ac85/drivers/net/wireless/hostap/hostap_cs.c
*** 2.6.35/drivers/net/wireless/hostap/hostap_cs.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/hostap/hostap_cs.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 626,634 ****
  	local->hw_priv = hw_priv;
  	hw_priv->link = link;
  
  	ret = pcmcia_request_irq(link, prism2_interrupt);
  	if (ret)
! 		goto failed;
  
  	/*
  	 * This actually configures the PCMCIA socket -- setting up
--- 626,640 ----
  	local->hw_priv = hw_priv;
  	hw_priv->link = link;
  
+ 	/*
+ 	 * Make sure the IRQ handler cannot proceed until at least
+ 	 * dev->base_addr is initialized.
+ 	 */
+ 	spin_lock_irqsave(&local->irq_init_lock, flags);
+ 
  	ret = pcmcia_request_irq(link, prism2_interrupt);
  	if (ret)
! 		goto failed_unlock;
  
  	/*
  	 * This actually configures the PCMCIA socket -- setting up
***************
*** 637,648 ****
  	 */
  	ret = pcmcia_request_configuration(link, &link->conf);
  	if (ret)
! 		goto failed;
  
- 	/* IRQ handler cannot proceed until at dev->base_addr is initialized */
- 	spin_lock_irqsave(&local->irq_init_lock, flags);
  	dev->irq = link->irq;
  	dev->base_addr = link->io.BasePort1;
  	spin_unlock_irqrestore(&local->irq_init_lock, flags);
  
  	/* Finally, report what we've done */
--- 643,653 ----
  	 */
  	ret = pcmcia_request_configuration(link, &link->conf);
  	if (ret)
! 		goto failed_unlock;
  
  	dev->irq = link->irq;
  	dev->base_addr = link->io.BasePort1;
+ 
  	spin_unlock_irqrestore(&local->irq_init_lock, flags);
  
  	/* Finally, report what we've done */
***************
*** 671,676 ****
--- 676,683 ----
  
  	return ret;
  
+  failed_unlock:
+ 	 spin_unlock_irqrestore(&local->irq_init_lock, flags);
   failed:
  	kfree(hw_priv);
  	prism2_release((u_long)link);
diff -cBr 2.6.35/drivers/net/wireless/iwlwifi/iwl-3945.c linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-3945.c
*** 2.6.35/drivers/net/wireless/iwlwifi/iwl-3945.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-3945.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2837,2842 ****
--- 2837,2843 ----
  	.config_ap = iwl3945_config_ap,
  	.manage_ibss_station = iwl3945_manage_ibss_station,
  	.recover_from_tx_stall = iwl_bg_monitor_recover,
+ 	.check_plcp_health = iwl3945_good_plcp_health,
  
  	.debugfs_ops = {
  		.rx_stats_read = iwl3945_ucode_rx_stats_read,
diff -cBr 2.6.35/drivers/net/wireless/iwlwifi/iwl-5000.c linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-5000.c
*** 2.6.35/drivers/net/wireless/iwlwifi/iwl-5000.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-5000.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 51,57 ****
  #include "iwl-agn-debugfs.h"
  
  /* Highest firmware API version supported */
! #define IWL5000_UCODE_API_MAX 5
  #define IWL5150_UCODE_API_MAX 2
  
  /* Lowest firmware API version supported */
--- 51,57 ----
  #include "iwl-agn-debugfs.h"
  
  /* Highest firmware API version supported */
! #define IWL5000_UCODE_API_MAX 2
  #define IWL5150_UCODE_API_MAX 2
  
  /* Lowest firmware API version supported */
diff -cBr 2.6.35/drivers/net/wireless/iwlwifi/iwl-agn.c linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-agn.c
*** 2.6.35/drivers/net/wireless/iwlwifi/iwl-agn.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-agn.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1205,1213 ****
  	/* only Re-enable if diabled by irq */
  	if (test_bit(STATUS_INT_ENABLED, &priv->status))
  		iwl_enable_interrupts(priv);
- 	/* Re-enable RF_KILL if it occurred */
- 	else if (handled & CSR_INT_BIT_RF_KILL)
- 		iwl_enable_rfkill_int(priv);
  
  #ifdef CONFIG_IWLWIFI_DEBUG
  	if (iwl_get_debug_level(priv) & (IWL_DL_ISR)) {
--- 1205,1210 ----
***************
*** 1423,1431 ****
  	/* only Re-enable if diabled by irq */
  	if (test_bit(STATUS_INT_ENABLED, &priv->status))
  		iwl_enable_interrupts(priv);
- 	/* Re-enable RF_KILL if it occurred */
- 	else if (handled & CSR_INT_BIT_RF_KILL)
- 		iwl_enable_rfkill_int(priv);
  }
  
  /* the threshold ratio of actual_ack_cnt to expected_ack_cnt in percent */
--- 1420,1425 ----
***************
*** 3118,3127 ****
  
  	flush_workqueue(priv->workqueue);
  
! 	/* User space software may expect getting rfkill changes
! 	 * even if interface is down */
  	iwl_write32(priv, CSR_INT, 0xFFFFFFFF);
! 	iwl_enable_rfkill_int(priv);
  
  	IWL_DEBUG_MAC80211(priv, "leave\n");
  }
--- 3112,3120 ----
  
  	flush_workqueue(priv->workqueue);
  
! 	/* enable interrupts again in order to receive rfkill changes */
  	iwl_write32(priv, CSR_INT, 0xFFFFFFFF);
! 	iwl_enable_interrupts(priv);
  
  	IWL_DEBUG_MAC80211(priv, "leave\n");
  }
***************
*** 3839,3852 ****
  	 * 8. Enable interrupts and read RFKILL state
  	 *********************************************/
  
! 	/* enable rfkill interrupt: hw bug w/a */
  	pci_read_config_word(priv->pci_dev, PCI_COMMAND, &pci_cmd);
  	if (pci_cmd & PCI_COMMAND_INTX_DISABLE) {
  		pci_cmd &= ~PCI_COMMAND_INTX_DISABLE;
  		pci_write_config_word(priv->pci_dev, PCI_COMMAND, pci_cmd);
  	}
  
! 	iwl_enable_rfkill_int(priv);
  
  	/* If platform's RF_KILL switch is NOT set to KILL */
  	if (iwl_read32(priv, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)
--- 3832,3845 ----
  	 * 8. Enable interrupts and read RFKILL state
  	 *********************************************/
  
! 	/* enable interrupts if needed: hw bug w/a */
  	pci_read_config_word(priv->pci_dev, PCI_COMMAND, &pci_cmd);
  	if (pci_cmd & PCI_COMMAND_INTX_DISABLE) {
  		pci_cmd &= ~PCI_COMMAND_INTX_DISABLE;
  		pci_write_config_word(priv->pci_dev, PCI_COMMAND, pci_cmd);
  	}
  
! 	iwl_enable_interrupts(priv);
  
  	/* If platform's RF_KILL switch is NOT set to KILL */
  	if (iwl_read32(priv, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)
diff -cBr 2.6.35/drivers/net/wireless/iwlwifi/iwl-agn-tx.c linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
*** 2.6.35/drivers/net/wireless/iwlwifi/iwl-agn-tx.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-agn-tx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1141,1154 ****
  	     q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
  
  		tx_info = &txq->txb[txq->q.read_ptr];
! 
! 		if (WARN_ON_ONCE(tx_info->skb[0] == NULL))
! 			continue;
  
  		hdr = (struct ieee80211_hdr *)tx_info->skb[0]->data;
! 		if (ieee80211_is_data_qos(hdr->frame_control))
  			nfreed++;
- 		iwlagn_tx_status(priv, tx_info->skb[0]);
  		tx_info->skb[0] = NULL;
  
  		if (priv->cfg->ops->lib->txq_inval_byte_cnt_tbl)
--- 1141,1151 ----
  	     q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
  
  		tx_info = &txq->txb[txq->q.read_ptr];
! 		iwlagn_tx_status(priv, tx_info->skb[0]);
  
  		hdr = (struct ieee80211_hdr *)tx_info->skb[0]->data;
! 		if (hdr && ieee80211_is_data_qos(hdr->frame_control))
  			nfreed++;
  		tx_info->skb[0] = NULL;
  
  		if (priv->cfg->ops->lib->txq_inval_byte_cnt_tbl)
diff -cBr 2.6.35/drivers/net/wireless/iwlwifi/iwl-helpers.h linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-helpers.h
*** 2.6.35/drivers/net/wireless/iwlwifi/iwl-helpers.h	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/iwlwifi/iwl-helpers.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 163,174 ****
  	IWL_DEBUG_ISR(priv, "Disabled interrupts\n");
  }
  
- static inline void iwl_enable_rfkill_int(struct iwl_priv *priv)
- {
- 	IWL_DEBUG_ISR(priv, "Enabling rfkill interrupt\n");
- 	iwl_write32(priv, CSR_INT_MASK, CSR_INT_BIT_RF_KILL);
- }
- 
  static inline void iwl_enable_interrupts(struct iwl_priv *priv)
  {
  	IWL_DEBUG_ISR(priv, "Enabling interrupts\n");
--- 163,168 ----
diff -cBr 2.6.35/drivers/net/wireless/orinoco/main.c linux-2.6.35.y-512ac85/drivers/net/wireless/orinoco/main.c
*** 2.6.35/drivers/net/wireless/orinoco/main.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/orinoco/main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1813,1824 ****
  	struct net_device *dev = priv->ndev;
  	int err = 0;
  
- 	/* If we've called commit, we are reconfiguring or bringing the
- 	 * interface up. Maintaining countermeasures across this would
- 	 * be confusing, so note that we've disabled them. The port will
- 	 * be enabled later in orinoco_commit or __orinoco_up. */
- 	priv->tkip_cm_active = 0;
- 
  	err = orinoco_hw_program_rids(priv);
  
  	/* FIXME: what about netif_tx_lock */
--- 1813,1818 ----
diff -cBr 2.6.35/drivers/net/wireless/orinoco/wext.c linux-2.6.35.y-512ac85/drivers/net/wireless/orinoco/wext.c
*** 2.6.35/drivers/net/wireless/orinoco/wext.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/orinoco/wext.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 904,913 ****
  		 */
  		if (param->value) {
  			priv->tkip_cm_active = 1;
! 			ret = hermes_disable_port(hw, 0);
  		} else {
  			priv->tkip_cm_active = 0;
! 			ret = hermes_enable_port(hw, 0);
  		}
  		break;
  
--- 904,913 ----
  		 */
  		if (param->value) {
  			priv->tkip_cm_active = 1;
! 			ret = hermes_enable_port(hw, 0);
  		} else {
  			priv->tkip_cm_active = 0;
! 			ret = hermes_disable_port(hw, 0);
  		}
  		break;
  
diff -cBr 2.6.35/drivers/net/wireless/p54/p54pci.c linux-2.6.35.y-512ac85/drivers/net/wireless/p54/p54pci.c
*** 2.6.35/drivers/net/wireless/p54/p54pci.c	2011-05-07 19:57:18.416750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/p54/p54pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 199,205 ****
  	while (i != idx) {
  		u16 len;
  		struct sk_buff *skb;
- 		dma_addr_t dma_addr;
  		desc = &ring[i];
  		len = le16_to_cpu(desc->len);
  		skb = rx_buf[i];
--- 199,204 ----
***************
*** 217,236 ****
  
  			len = priv->common.rx_mtu;
  		}
- 		dma_addr = le32_to_cpu(desc->host_addr);
- 		pci_dma_sync_single_for_cpu(priv->pdev, dma_addr,
- 			priv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);
  		skb_put(skb, len);
  
  		if (p54_rx(dev, skb)) {
! 			pci_unmap_single(priv->pdev, dma_addr,
! 				priv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);
  			rx_buf[i] = NULL;
! 			desc->host_addr = cpu_to_le32(0);
  		} else {
  			skb_trim(skb, 0);
- 			pci_dma_sync_single_for_device(priv->pdev, dma_addr,
- 				priv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);
  			desc->len = cpu_to_le16(priv->common.rx_mtu + 32);
  		}
  
--- 216,232 ----
  
  			len = priv->common.rx_mtu;
  		}
  		skb_put(skb, len);
  
  		if (p54_rx(dev, skb)) {
! 			pci_unmap_single(priv->pdev,
! 					 le32_to_cpu(desc->host_addr),
! 					 priv->common.rx_mtu + 32,
! 					 PCI_DMA_FROMDEVICE);
  			rx_buf[i] = NULL;
! 			desc->host_addr = 0;
  		} else {
  			skb_trim(skb, 0);
  			desc->len = cpu_to_le16(priv->common.rx_mtu + 32);
  		}
  
diff -cBr 2.6.35/drivers/net/wireless/p54/p54usb.c linux-2.6.35.y-512ac85/drivers/net/wireless/p54/p54usb.c
*** 2.6.35/drivers/net/wireless/p54/p54usb.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/p54/p54usb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 43,49 ****
  
  static struct usb_device_id p54u_table[] __devinitdata = {
  	/* Version 1 devices (pci chip + net2280) */
- 	{USB_DEVICE(0x0411, 0x0050)},	/* Buffalo WLI2-USB2-G54 */
  	{USB_DEVICE(0x045e, 0x00c2)},	/* Microsoft MN-710 */
  	{USB_DEVICE(0x0506, 0x0a11)},	/* 3COM 3CRWE254G72 */
  	{USB_DEVICE(0x06b9, 0x0120)},	/* Thomson SpeedTouch 120g */
--- 43,48 ----
***************
*** 56,75 ****
  	{USB_DEVICE(0x0846, 0x4210)},	/* Netgear WG121 the second ? */
  	{USB_DEVICE(0x0846, 0x4220)},	/* Netgear WG111 */
  	{USB_DEVICE(0x09aa, 0x1000)},	/* Spinnaker Proto board */
- 	{USB_DEVICE(0x0bf8, 0x1007)},	/* Fujitsu E-5400 USB */
  	{USB_DEVICE(0x0cde, 0x0006)},	/* Medion 40900, Roper Europe */
- 	{USB_DEVICE(0x0db0, 0x6826)},	/* MSI UB54G (MS-6826) */
  	{USB_DEVICE(0x107b, 0x55f2)},	/* Gateway WGU-210 (Gemtek) */
  	{USB_DEVICE(0x124a, 0x4023)},	/* Shuttle PN15, Airvast WM168g, IOGear GWU513 */
- 	{USB_DEVICE(0x1435, 0x0210)},	/* Inventel UR054G */
- 	{USB_DEVICE(0x15a9, 0x0002)},	/* Gemtek WUBI-100GW 802.11g */
  	{USB_DEVICE(0x1630, 0x0005)},	/* 2Wire 802.11g USB (v1) / Z-Com */
- 	{USB_DEVICE(0x182d, 0x096b)},	/* Sitecom WL-107 */
  	{USB_DEVICE(0x1915, 0x2234)},	/* Linksys WUSB54G OEM */
  	{USB_DEVICE(0x1915, 0x2235)},	/* Linksys WUSB54G Portable OEM */
  	{USB_DEVICE(0x2001, 0x3701)},	/* DLink DWL-G120 Spinnaker */
  	{USB_DEVICE(0x2001, 0x3703)},	/* DLink DWL-G122 */
- 	{USB_DEVICE(0x2001, 0x3762)},	/* Conceptronic C54U */
  	{USB_DEVICE(0x5041, 0x2234)},	/* Linksys WUSB54G */
  	{USB_DEVICE(0x5041, 0x2235)},	/* Linksys WUSB54G Portable */
  
--- 55,68 ----
***************
*** 99,107 ****
  	{USB_DEVICE(0x1413, 0x5400)},   /* Telsey 802.11g USB2.0 Adapter */
  	{USB_DEVICE(0x1435, 0x0427)},	/* Inventel UR054G */
  	{USB_DEVICE(0x1668, 0x1050)},	/* Actiontec 802UIG-1 */
- 	{USB_DEVICE(0x1740, 0x1000)},	/* Senao NUB-350 */
  	{USB_DEVICE(0x2001, 0x3704)},	/* DLink DWL-G122 rev A2 */
- 	{USB_DEVICE(0x2001, 0x3705)},	/* D-Link DWL-G120 rev C1 */
  	{USB_DEVICE(0x413c, 0x5513)},	/* Dell WLA3310 USB Wireless Adapter */
  	{USB_DEVICE(0x413c, 0x8102)},	/* Spinnaker DUT */
  	{USB_DEVICE(0x413c, 0x8104)},	/* Cohiba Proto board */
--- 92,98 ----
diff -cBr 2.6.35/drivers/net/wireless/p54/txrx.c linux-2.6.35.y-512ac85/drivers/net/wireless/p54/txrx.c
*** 2.6.35/drivers/net/wireless/p54/txrx.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/p54/txrx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 616,622 ****
  	else
  		*burst_possible = false;
  
! 	if (!(info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))
  		*flags |= P54_HDR_FLAG_DATA_OUT_SEQNR;
  
  	if (info->flags & IEEE80211_TX_CTL_PSPOLL_RESPONSE)
--- 616,622 ----
  	else
  		*burst_possible = false;
  
! 	if (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)
  		*flags |= P54_HDR_FLAG_DATA_OUT_SEQNR;
  
  	if (info->flags & IEEE80211_TX_CTL_PSPOLL_RESPONSE)
***************
*** 702,708 ****
  	struct p54_tx_info *p54info;
  	struct p54_hdr *hdr;
  	struct p54_tx_data *txhdr;
! 	unsigned int padding, len, extra_len = 0;
  	int i, j, ridx;
  	u16 hdr_flags = 0, aid = 0;
  	u8 rate, queue = 0, crypt_offset = 0;
--- 702,708 ----
  	struct p54_tx_info *p54info;
  	struct p54_hdr *hdr;
  	struct p54_tx_data *txhdr;
! 	unsigned int padding, len, extra_len;
  	int i, j, ridx;
  	u16 hdr_flags = 0, aid = 0;
  	u8 rate, queue = 0, crypt_offset = 0;
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2400pci.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2400pci.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt2400pci.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2400pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1462,1471 ****
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++) {
! 		info[i].max_power = TXPOWER_FROM_DEV(MAX_TXPOWER);
! 		info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 	}
  
  	return 0;
  }
--- 1462,1469 ----
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++)
! 		info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  
  	return 0;
  }
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2500pci.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2500pci.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt2500pci.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2500pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1780,1795 ****
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++) {
! 		info[i].max_power = MAX_TXPOWER;
! 		info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 	}
  
  	if (spec->num_channels > 14) {
! 		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].max_power = MAX_TXPOWER;
! 			info[i].default_power1 = DEFAULT_TXPOWER;
! 		}
  	}
  
  	return 0;
--- 1780,1791 ----
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++)
! 		info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  
  	if (spec->num_channels > 14) {
! 		for (i = 14; i < spec->num_channels; i++)
! 			info[i].tx_power1 = DEFAULT_TXPOWER;
  	}
  
  	return 0;
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2500usb.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2500usb.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt2500usb.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2500usb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1690,1705 ****
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++) {
! 		info[i].max_power = MAX_TXPOWER;
! 		info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 	}
  
  	if (spec->num_channels > 14) {
! 		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].max_power = MAX_TXPOWER;
! 			info[i].default_power1 = DEFAULT_TXPOWER;
! 		}
  	}
  
  	return 0;
--- 1690,1701 ----
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);
! 	for (i = 0; i < 14; i++)
! 		info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  
  	if (spec->num_channels > 14) {
! 		for (i = 14; i < spec->num_channels; i++)
! 			info[i].tx_power1 = DEFAULT_TXPOWER;
  	}
  
  	return 0;
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2800.h linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2800.h
*** 2.6.35/drivers/net/wireless/rt2x00/rt2800.h	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2800.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 1770,1782 ****
  #define EEPROM_RSSI_A2_LNA_A2		FIELD16(0xff00)
  
  /*
-  * EEPROM Maximum TX power values
-  */
- #define EEPROM_MAX_TX_POWER		0x0027
- #define EEPROM_MAX_TX_POWER_24GHZ	FIELD16(0x00ff)
- #define EEPROM_MAX_TX_POWER_5GHZ	FIELD16(0xff00)
- 
- /*
   * EEPROM TXpower delta: 20MHZ AND 40 MHZ use different power.
   *	This is delta in 40MHZ.
   * VALUE: Tx Power dalta value (MAX=4)
--- 1770,1775 ----
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2800lib.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2800lib.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt2800lib.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2800lib.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 840,866 ****
  		 * double meaning, and we should set a 7DBm boost flag.
  		 */
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_A_7DBM_BOOST,
! 				   (info->default_power1 >= 0));
  
! 		if (info->default_power1 < 0)
! 			info->default_power1 += 7;
  
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_A,
! 				   TXPOWER_A_TO_DEV(info->default_power1));
  
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_A_7DBM_BOOST,
! 				   (info->default_power2 >= 0));
  
! 		if (info->default_power2 < 0)
! 			info->default_power2 += 7;
  
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_A,
! 				   TXPOWER_A_TO_DEV(info->default_power2));
  	} else {
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_G,
! 				   TXPOWER_G_TO_DEV(info->default_power1));
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_G,
! 				   TXPOWER_G_TO_DEV(info->default_power2));
  	}
  
  	rt2x00_set_field32(&rf->rf4, RF4_HT40, conf_is_ht40(conf));
--- 840,866 ----
  		 * double meaning, and we should set a 7DBm boost flag.
  		 */
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_A_7DBM_BOOST,
! 				   (info->tx_power1 >= 0));
  
! 		if (info->tx_power1 < 0)
! 			info->tx_power1 += 7;
  
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_A,
! 				   TXPOWER_A_TO_DEV(info->tx_power1));
  
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_A_7DBM_BOOST,
! 				   (info->tx_power2 >= 0));
  
! 		if (info->tx_power2 < 0)
! 			info->tx_power2 += 7;
  
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_A,
! 				   TXPOWER_A_TO_DEV(info->tx_power2));
  	} else {
  		rt2x00_set_field32(&rf->rf3, RF3_TXPOWER_G,
! 				   TXPOWER_G_TO_DEV(info->tx_power1));
  		rt2x00_set_field32(&rf->rf4, RF4_TXPOWER_G,
! 				   TXPOWER_G_TO_DEV(info->tx_power2));
  	}
  
  	rt2x00_set_field32(&rf->rf4, RF4_HT40, conf_is_ht40(conf));
***************
*** 900,910 ****
  	rt2800_rfcsr_write(rt2x00dev, 6, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 12, &rfcsr);
! 	rt2x00_set_field8(&rfcsr, RFCSR12_TX_POWER, info->default_power1);
  	rt2800_rfcsr_write(rt2x00dev, 12, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 13, &rfcsr);
! 	rt2x00_set_field8(&rfcsr, RFCSR13_TX_POWER, info->default_power2);
  	rt2800_rfcsr_write(rt2x00dev, 13, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 23, &rfcsr);
--- 900,912 ----
  	rt2800_rfcsr_write(rt2x00dev, 6, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 12, &rfcsr);
! 	rt2x00_set_field8(&rfcsr, RFCSR12_TX_POWER,
! 			  TXPOWER_G_TO_DEV(info->tx_power1));
  	rt2800_rfcsr_write(rt2x00dev, 12, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 13, &rfcsr);
! 	rt2x00_set_field8(&rfcsr, RFCSR13_TX_POWER,
! 			  TXPOWER_G_TO_DEV(info->tx_power2));
  	rt2800_rfcsr_write(rt2x00dev, 13, rfcsr);
  
  	rt2800_rfcsr_read(rt2x00dev, 23, &rfcsr);
***************
*** 2224,2236 ****
  				   default_lna_gain);
  	rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_A2, word);
  
- 	rt2x00_eeprom_read(rt2x00dev, EEPROM_MAX_TX_POWER, &word);
- 	if (rt2x00_get_field16(word, EEPROM_MAX_TX_POWER_24GHZ) == 0xff)
- 		rt2x00_set_field16(&word, EEPROM_MAX_TX_POWER_24GHZ, MAX_G_TXPOWER);
- 	if (rt2x00_get_field16(word, EEPROM_MAX_TX_POWER_5GHZ) == 0xff)
- 		rt2x00_set_field16(&word, EEPROM_MAX_TX_POWER_5GHZ, MAX_A_TXPOWER);
- 	rt2x00_eeprom_write(rt2x00dev, EEPROM_MAX_TX_POWER, word);
- 
  	return 0;
  }
  EXPORT_SYMBOL_GPL(rt2800_validate_eeprom);
--- 2226,2231 ----
***************
*** 2471,2480 ****
  {
  	struct hw_mode_spec *spec = &rt2x00dev->spec;
  	struct channel_info *info;
! 	char *default_power1;
! 	char *default_power2;
  	unsigned int i;
- 	unsigned short max_power;
  	u16 eeprom;
  
  	/*
--- 2466,2474 ----
  {
  	struct hw_mode_spec *spec = &rt2x00dev->spec;
  	struct channel_info *info;
! 	char *tx_power1;
! 	char *tx_power2;
  	unsigned int i;
  	u16 eeprom;
  
  	/*
***************
*** 2572,2597 ****
  
  	spec->channels_info = info;
  
! 	rt2x00_eeprom_read(rt2x00dev, EEPROM_MAX_TX_POWER, &eeprom);
! 	max_power = rt2x00_get_field16(eeprom, EEPROM_MAX_TX_POWER_24GHZ);
! 	default_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG1);
! 	default_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG2);
  
  	for (i = 0; i < 14; i++) {
! 		info[i].max_power = max_power;
! 		info[i].default_power1 = TXPOWER_G_FROM_DEV(default_power1[i]);
! 		info[i].default_power2 = TXPOWER_G_FROM_DEV(default_power2[i]);
  	}
  
  	if (spec->num_channels > 14) {
! 		max_power = rt2x00_get_field16(eeprom, EEPROM_MAX_TX_POWER_5GHZ);
! 		default_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A1);
! 		default_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A2);
  
  		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].max_power = max_power;
! 			info[i].default_power1 = TXPOWER_A_FROM_DEV(default_power1[i]);
! 			info[i].default_power2 = TXPOWER_A_FROM_DEV(default_power2[i]);
  		}
  	}
  
--- 2566,2586 ----
  
  	spec->channels_info = info;
  
! 	tx_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG1);
! 	tx_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG2);
  
  	for (i = 0; i < 14; i++) {
! 		info[i].tx_power1 = TXPOWER_G_FROM_DEV(tx_power1[i]);
! 		info[i].tx_power2 = TXPOWER_G_FROM_DEV(tx_power2[i]);
  	}
  
  	if (spec->num_channels > 14) {
! 		tx_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A1);
! 		tx_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A2);
  
  		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].tx_power1 = TXPOWER_A_FROM_DEV(tx_power1[i]);
! 			info[i].tx_power2 = TXPOWER_A_FROM_DEV(tx_power2[i]);
  		}
  	}
  
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2x00dev.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2x00dev.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt2x00dev.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2x00dev.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 605,611 ****
  	for (i = 0; i < spec->num_channels; i++) {
  		rt2x00lib_channel(&channels[i],
  				  spec->channels[i].channel,
! 				  spec->channels_info[i].max_power, i);
  	}
  
  	/*
--- 605,611 ----
  	for (i = 0; i < spec->num_channels; i++) {
  		rt2x00lib_channel(&channels[i],
  				  spec->channels[i].channel,
! 				  spec->channels_info[i].tx_power1, i);
  	}
  
  	/*
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt2x00.h linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2x00.h
*** 2.6.35/drivers/net/wireless/rt2x00/rt2x00.h	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt2x00.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 211,219 ****
  	unsigned int flags;
  #define GEOGRAPHY_ALLOWED	0x00000001
  
! 	short max_power;
! 	short default_power1;
! 	short default_power2;
  };
  
  /*
--- 211,218 ----
  	unsigned int flags;
  #define GEOGRAPHY_ALLOWED	0x00000001
  
! 	short tx_power1;
! 	short tx_power2;
  };
  
  /*
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt61pci.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt61pci.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt61pci.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt61pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2605,2621 ****
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);
! 	for (i = 0; i < 14; i++) {
! 		info[i].max_power = MAX_TXPOWER;
! 		info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 	}
  
  	if (spec->num_channels > 14) {
  		tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);
! 		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].max_power = MAX_TXPOWER;
! 			info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 		}
  	}
  
  	return 0;
--- 2605,2617 ----
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);
! 	for (i = 0; i < 14; i++)
! 		info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  
  	if (spec->num_channels > 14) {
  		tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);
! 		for (i = 14; i < spec->num_channels; i++)
! 			info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  	}
  
  	return 0;
diff -cBr 2.6.35/drivers/net/wireless/rt2x00/rt73usb.c linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt73usb.c
*** 2.6.35/drivers/net/wireless/rt2x00/rt73usb.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/wireless/rt2x00/rt73usb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2092,2108 ****
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);
! 	for (i = 0; i < 14; i++) {
! 		info[i].max_power = MAX_TXPOWER;
! 		info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 	}
  
  	if (spec->num_channels > 14) {
  		tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);
! 		for (i = 14; i < spec->num_channels; i++) {
! 			info[i].max_power = MAX_TXPOWER;
! 			info[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);
! 		}
  	}
  
  	return 0;
--- 2092,2104 ----
  	spec->channels_info = info;
  
  	tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);
! 	for (i = 0; i < 14; i++)
! 		info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  
  	if (spec->num_channels > 14) {
  		tx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);
! 		for (i = 14; i < spec->num_channels; i++)
! 			info[i].tx_power1 = TXPOWER_FROM_DEV(tx_power[i]);
  	}
  
  	return 0;
***************
*** 2392,2398 ****
  	{ USB_DEVICE(0x04bb, 0x093d), USB_DEVICE_DATA(&rt73usb_ops) },
  	{ USB_DEVICE(0x148f, 0x2573), USB_DEVICE_DATA(&rt73usb_ops) },
  	{ USB_DEVICE(0x148f, 0x2671), USB_DEVICE_DATA(&rt73usb_ops) },
- 	{ USB_DEVICE(0x0812, 0x3101), USB_DEVICE_DATA(&rt73usb_ops) },
  	/* Qcom */
  	{ USB_DEVICE(0x18e8, 0x6196), USB_DEVICE_DATA(&rt73usb_ops) },
  	{ USB_DEVICE(0x18e8, 0x6229), USB_DEVICE_DATA(&rt73usb_ops) },
--- 2388,2393 ----
diff -cBr 2.6.35/drivers/net/xen-netfront.c linux-2.6.35.y-512ac85/drivers/net/xen-netfront.c
*** 2.6.35/drivers/net/xen-netfront.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/net/xen-netfront.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 66,73 ****
  
  #define GRANT_INVALID_REF	0
  
! #define NET_TX_RING_SIZE __CONST_RING_SIZE(xen_netif_tx, PAGE_SIZE)
! #define NET_RX_RING_SIZE __CONST_RING_SIZE(xen_netif_rx, PAGE_SIZE)
  #define TX_MAX_TARGET min_t(int, NET_RX_RING_SIZE, 256)
  
  struct netfront_info {
--- 66,73 ----
  
  #define GRANT_INVALID_REF	0
  
! #define NET_TX_RING_SIZE __RING_SIZE((struct xen_netif_tx_sring *)0, PAGE_SIZE)
! #define NET_RX_RING_SIZE __RING_SIZE((struct xen_netif_rx_sring *)0, PAGE_SIZE)
  #define TX_MAX_TARGET min_t(int, NET_RX_RING_SIZE, 256)
  
  struct netfront_info {
diff -cBr 2.6.35/drivers/oprofile/timer_int.c linux-2.6.35.y-512ac85/drivers/oprofile/timer_int.c
*** 2.6.35/drivers/oprofile/timer_int.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/oprofile/timer_int.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 21,27 ****
  #include "oprof.h"
  
  static DEFINE_PER_CPU(struct hrtimer, oprofile_hrtimer);
- static int ctr_running;
  
  static enum hrtimer_restart oprofile_hrtimer_notify(struct hrtimer *hrtimer)
  {
--- 21,26 ----
***************
*** 34,42 ****
  {
  	struct hrtimer *hrtimer = &__get_cpu_var(oprofile_hrtimer);
  
- 	if (!ctr_running)
- 		return;
- 
  	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
  	hrtimer->function = oprofile_hrtimer_notify;
  
--- 33,38 ----
***************
*** 46,55 ****
  
  static int oprofile_hrtimer_start(void)
  {
- 	get_online_cpus();
- 	ctr_running = 1;
  	on_each_cpu(__oprofile_hrtimer_start, NULL, 1);
- 	put_online_cpus();
  	return 0;
  }
  
--- 42,48 ----
***************
*** 57,65 ****
  {
  	struct hrtimer *hrtimer = &per_cpu(oprofile_hrtimer, cpu);
  
- 	if (!ctr_running)
- 		return;
- 
  	hrtimer_cancel(hrtimer);
  }
  
--- 50,55 ----
***************
*** 67,77 ****
  {
  	int cpu;
  
- 	get_online_cpus();
  	for_each_online_cpu(cpu)
  		__oprofile_hrtimer_stop(cpu);
- 	ctr_running = 0;
- 	put_online_cpus();
  }
  
  static int __cpuinit oprofile_cpu_notify(struct notifier_block *self,
--- 57,64 ----
diff -cBr 2.6.35/drivers/pci/dmar.c linux-2.6.35.y-512ac85/drivers/pci/dmar.c
*** 2.6.35/drivers/pci/dmar.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/dmar.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1414,1424 ****
  			       (unsigned long long)drhd->reg_base_addr, ret);
  			return -1;
  		}
- 
- 		/*
- 		 * Clear any previous faults.
- 		 */
- 		dmar_fault(iommu->irq, iommu);
  	}
  
  	return 0;
--- 1414,1419 ----
diff -cBr 2.6.35/drivers/pci/hotplug/acpiphp_glue.c linux-2.6.35.y-512ac85/drivers/pci/hotplug/acpiphp_glue.c
*** 2.6.35/drivers/pci/hotplug/acpiphp_glue.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/hotplug/acpiphp_glue.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 212,218 ****
  
  	pdev = pci_get_slot(pbus, PCI_DEVFN(device, function));
  	if (pdev) {
- 		pdev->current_state = PCI_D0;
  		slot->flags |= (SLOT_ENABLED | SLOT_POWEREDON);
  		pci_dev_put(pdev);
  	}
--- 212,217 ----
diff -cBr 2.6.35/drivers/pci/intel-iommu.c linux-2.6.35.y-512ac85/drivers/pci/intel-iommu.c
*** 2.6.35/drivers/pci/intel-iommu.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/intel-iommu.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1835,1841 ****
  
  	ret = iommu_attach_domain(domain, iommu);
  	if (ret) {
! 		free_domain_mem(domain);
  		goto error;
  	}
  
--- 1835,1841 ----
  
  	ret = iommu_attach_domain(domain, iommu);
  	if (ret) {
! 		domain_exit(domain);
  		goto error;
  	}
  
***************
*** 3260,3274 ****
  	if (!domain)
  		return 0;
  
! 	if (action == BUS_NOTIFY_UNBOUND_DRIVER && !iommu_pass_through) {
  		domain_remove_one_dev_info(domain, pdev);
  
- 		if (!(domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE) &&
- 		    !(domain->flags & DOMAIN_FLAG_STATIC_IDENTITY) &&
- 		    list_empty(&domain->devices))
- 			domain_exit(domain);
- 	}
- 
  	return 0;
  }
  
--- 3260,3268 ----
  	if (!domain)
  		return 0;
  
! 	if (action == BUS_NOTIFY_UNBOUND_DRIVER && !iommu_pass_through)
  		domain_remove_one_dev_info(domain, pdev);
  
  	return 0;
  }
  
***************
*** 3417,3427 ****
  		domain->iommu_count--;
  		domain_update_iommu_cap(domain);
  		spin_unlock_irqrestore(&domain->iommu_lock, tmp_flags);
- 
- 		spin_lock_irqsave(&iommu->lock, tmp_flags);
- 		clear_bit(domain->id, iommu->domain_ids);
- 		iommu->domains[domain->id] = NULL;
- 		spin_unlock_irqrestore(&iommu->lock, tmp_flags);
  	}
  
  	spin_unlock_irqrestore(&device_domain_lock, flags);
--- 3411,3416 ----
***************
*** 3638,3646 ****
  
  		pte = dmar_domain->pgd;
  		if (dma_pte_present(pte)) {
  			dmar_domain->pgd = (struct dma_pte *)
  				phys_to_virt(dma_pte_addr(pte));
- 			free_pgtable_page(pte);
  		}
  		dmar_domain->agaw--;
  	}
--- 3627,3635 ----
  
  		pte = dmar_domain->pgd;
  		if (dma_pte_present(pte)) {
+ 			free_pgtable_page(dmar_domain->pgd);
  			dmar_domain->pgd = (struct dma_pte *)
  				phys_to_virt(dma_pte_addr(pte));
  		}
  		dmar_domain->agaw--;
  	}
diff -cBr 2.6.35/drivers/pci/pci.h linux-2.6.35.y-512ac85/drivers/pci/pci.h
*** 2.6.35/drivers/pci/pci.h	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/pci.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 13,25 ****
  extern void pci_remove_sysfs_dev_files(struct pci_dev *pdev);
  extern void pci_cleanup_rom(struct pci_dev *dev);
  #ifdef HAVE_PCI_MMAP
- enum pci_mmap_api {
- 	PCI_MMAP_SYSFS,	/* mmap on /sys/bus/pci/devices/<BDF>/resource<N> */
- 	PCI_MMAP_PROCFS	/* mmap on /proc/bus/pci/<BDF> */
- };
  extern int pci_mmap_fits(struct pci_dev *pdev, int resno,
! 			 struct vm_area_struct *vmai,
! 			 enum pci_mmap_api mmap_api);
  #endif
  int pci_probe_reset_function(struct pci_dev *dev);
  
--- 13,20 ----
  extern void pci_remove_sysfs_dev_files(struct pci_dev *pdev);
  extern void pci_cleanup_rom(struct pci_dev *dev);
  #ifdef HAVE_PCI_MMAP
  extern int pci_mmap_fits(struct pci_dev *pdev, int resno,
! 			 struct vm_area_struct *vma);
  #endif
  int pci_probe_reset_function(struct pci_dev *dev);
  
diff -cBr 2.6.35/drivers/pci/pci-stub.c linux-2.6.35.y-512ac85/drivers/pci/pci-stub.c
*** 2.6.35/drivers/pci/pci-stub.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/pci-stub.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 54,62 ****
  			subdevice = PCI_ANY_ID, class=0, class_mask=0;
  		int fields;
  
- 		if (!strlen(id))
- 			continue;
- 
  		fields = sscanf(id, "%x:%x:%x:%x:%x:%x",
  				&vendor, &device, &subvendor, &subdevice,
  				&class, &class_mask);
--- 54,59 ----
diff -cBr 2.6.35/drivers/pci/pci-sysfs.c linux-2.6.35.y-512ac85/drivers/pci/pci-sysfs.c
*** 2.6.35/drivers/pci/pci-sysfs.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/pci-sysfs.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 705,725 ****
  
  #ifdef HAVE_PCI_MMAP
  
! int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
! 		  enum pci_mmap_api mmap_api)
  {
! 	unsigned long nr, start, size, pci_start;
  
- 	if (pci_resource_len(pdev, resno) == 0)
- 		return 0;
  	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
  	start = vma->vm_pgoff;
  	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
! 	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?
! 			pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
! 	if (start >= pci_start && start < pci_start + size &&
! 			start + nr <= pci_start + size)
  		return 1;
  	return 0;
  }
  
--- 705,721 ----
  
  #ifdef HAVE_PCI_MMAP
  
! int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma)
  {
! 	unsigned long nr, start, size;
  
  	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
  	start = vma->vm_pgoff;
  	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
! 	if (start < size && size - start >= nr)
  		return 1;
+ 	WARN(1, "process \"%s\" tried to map 0x%08lx-0x%08lx on %s BAR %d (size 0x%08lx)\n",
+ 		current->comm, start, start+nr, pci_name(pdev), resno, size);
  	return 0;
  }
  
***************
*** 749,762 ****
  	if (i >= PCI_ROM_RESOURCE)
  		return -ENODEV;
  
! 	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
! 		WARN(1, "process \"%s\" tried to map 0x%08lx bytes "
! 			"at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
! 			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
! 			pci_name(pdev), i,
! 			pci_resource_start(pdev, i), pci_resource_len(pdev, i));
  		return -EINVAL;
- 	}
  
  	/* pci_mmap_page_range() expects the same kind of entry as coming
  	 * from /proc/bus/pci/ which is a "user visible" value. If this is
--- 745,752 ----
  	if (i >= PCI_ROM_RESOURCE)
  		return -ENODEV;
  
! 	if (!pci_mmap_fits(pdev, i, vma))
  		return -EINVAL;
  
  	/* pci_mmap_page_range() expects the same kind of entry as coming
  	 * from /proc/bus/pci/ which is a "user visible" value. If this is
***************
*** 1018,1024 ****
  		attr->write = write_vpd_attr;
  		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
  		if (retval) {
! 			kfree(attr);
  			return retval;
  		}
  		dev->vpd->attr = attr;
--- 1008,1014 ----
  		attr->write = write_vpd_attr;
  		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
  		if (retval) {
! 			kfree(dev->vpd->attr);
  			return retval;
  		}
  		dev->vpd->attr = attr;
diff -cBr 2.6.35/drivers/pci/proc.c linux-2.6.35.y-512ac85/drivers/pci/proc.c
*** 2.6.35/drivers/pci/proc.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/proc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 260,266 ****
  
  	/* Make sure the caller is mapping a real resource for this device */
  	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
! 		if (pci_mmap_fits(dev, i, vma,  PCI_MMAP_PROCFS))
  			break;
  	}
  
--- 260,266 ----
  
  	/* Make sure the caller is mapping a real resource for this device */
  	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
! 		if (pci_mmap_fits(dev, i, vma))
  			break;
  	}
  
diff -cBr 2.6.35/drivers/pci/quirks.c linux-2.6.35.y-512ac85/drivers/pci/quirks.c
*** 2.6.35/drivers/pci/quirks.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pci/quirks.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 150,155 ****
--- 150,175 ----
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_3,	quirk_isa_dma_hangs);
  
  /*
+  * Intel NM10 "TigerPoint" LPC PM1a_STS.BM_STS must be clear
+  * for some HT machines to use C4 w/o hanging.
+  */
+ static void __devinit quirk_tigerpoint_bm_sts(struct pci_dev *dev)
+ {
+ 	u32 pmbase;
+ 	u16 pm1a;
+ 
+ 	pci_read_config_dword(dev, 0x40, &pmbase);
+ 	pmbase = pmbase & 0xff80;
+ 	pm1a = inw(pmbase);
+ 
+ 	if (pm1a & 0x10) {
+ 		dev_info(&dev->dev, FW_BUG "TigerPoint LPC.BM_STS cleared\n");
+ 		outw(0x10, pmbase);
+ 	}
+ }
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TGP_LPC, quirk_tigerpoint_bm_sts);
+ 
+ /*
   *	Chipsets where PCI->PCI transfers vanish or hang
   */
  static void __devinit quirk_nopcipci(struct pci_dev *dev)
***************
*** 499,515 ****
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_3,	quirk_piix4_acpi);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82443MX_3,	quirk_piix4_acpi);
  
- #define ICH_PMBASE	0x40
- #define ICH_ACPI_CNTL	0x44
- #define  ICH4_ACPI_EN	0x10
- #define  ICH6_ACPI_EN	0x80
- #define ICH4_GPIOBASE	0x58
- #define ICH4_GPIO_CNTL	0x5c
- #define  ICH4_GPIO_EN	0x10
- #define ICH6_GPIOBASE	0x48
- #define ICH6_GPIO_CNTL	0x4c
- #define  ICH6_GPIO_EN	0x10
- 
  /*
   * ICH4, ICH4-M, ICH5, ICH5-M ACPI: Three IO regions pointed to by longwords at
   *	0x40 (128 bytes of ACPI, GPIO & TCO registers)
--- 519,524 ----
***************
*** 518,550 ****
  static void __devinit quirk_ich4_lpc_acpi(struct pci_dev *dev)
  {
  	u32 region;
- 	u8 enable;
  
! 	/*
! 	 * The check for PCIBIOS_MIN_IO is to ensure we won't create a conflict
! 	 * with low legacy (and fixed) ports. We don't know the decoding
! 	 * priority and can't tell whether the legacy device or the one created
! 	 * here is really at that address.  This happens on boards with broken
! 	 * BIOSes.
! 	*/
! 
! 	pci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);
! 	if (enable & ICH4_ACPI_EN) {
! 		pci_read_config_dword(dev, ICH_PMBASE, &region);
! 		region &= PCI_BASE_ADDRESS_IO_MASK;
! 		if (region >= PCIBIOS_MIN_IO)
! 			quirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES,
! 					"ICH4 ACPI/GPIO/TCO");
! 	}
  
! 	pci_read_config_byte(dev, ICH4_GPIO_CNTL, &enable);
! 	if (enable & ICH4_GPIO_EN) {
! 		pci_read_config_dword(dev, ICH4_GPIOBASE, &region);
! 		region &= PCI_BASE_ADDRESS_IO_MASK;
! 		if (region >= PCIBIOS_MIN_IO)
! 			quirk_io_region(dev, region, 64,
! 					PCI_BRIDGE_RESOURCES + 1, "ICH4 GPIO");
! 	}
  }
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AA_0,		quirk_ich4_lpc_acpi);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AB_0,		quirk_ich4_lpc_acpi);
--- 527,538 ----
  static void __devinit quirk_ich4_lpc_acpi(struct pci_dev *dev)
  {
  	u32 region;
  
! 	pci_read_config_dword(dev, 0x40, &region);
! 	quirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES, "ICH4 ACPI/GPIO/TCO");
  
! 	pci_read_config_dword(dev, 0x58, &region);
! 	quirk_io_region(dev, region, 64, PCI_BRIDGE_RESOURCES+1, "ICH4 GPIO");
  }
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AA_0,		quirk_ich4_lpc_acpi);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AB_0,		quirk_ich4_lpc_acpi);
***************
*** 560,584 ****
  static void __devinit ich6_lpc_acpi_gpio(struct pci_dev *dev)
  {
  	u32 region;
- 	u8 enable;
  
! 	pci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);
! 	if (enable & ICH6_ACPI_EN) {
! 		pci_read_config_dword(dev, ICH_PMBASE, &region);
! 		region &= PCI_BASE_ADDRESS_IO_MASK;
! 		if (region >= PCIBIOS_MIN_IO)
! 			quirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES,
! 					"ICH6 ACPI/GPIO/TCO");
! 	}
  
! 	pci_read_config_byte(dev, ICH6_GPIO_CNTL, &enable);
! 	if (enable & ICH4_GPIO_EN) {
! 		pci_read_config_dword(dev, ICH6_GPIOBASE, &region);
! 		region &= PCI_BASE_ADDRESS_IO_MASK;
! 		if (region >= PCIBIOS_MIN_IO)
! 			quirk_io_region(dev, region, 64,
! 					PCI_BRIDGE_RESOURCES + 1, "ICH6 GPIO");
! 	}
  }
  
  static void __devinit ich6_lpc_generic_decode(struct pci_dev *dev, unsigned reg, const char *name, int dynsize)
--- 548,559 ----
  static void __devinit ich6_lpc_acpi_gpio(struct pci_dev *dev)
  {
  	u32 region;
  
! 	pci_read_config_dword(dev, 0x40, &region);
! 	quirk_io_region(dev, region, 128, PCI_BRIDGE_RESOURCES, "ICH6 ACPI/GPIO/TCO");
  
! 	pci_read_config_dword(dev, 0x48, &region);
! 	quirk_io_region(dev, region, 64, PCI_BRIDGE_RESOURCES+1, "ICH6 GPIO");
  }
  
  static void __devinit ich6_lpc_generic_decode(struct pci_dev *dev, unsigned reg, const char *name, int dynsize)
***************
*** 2703,2731 ****
  DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5C832, ricoh_mmc_fixup_r5c832);
  #endif /*CONFIG_MMC_RICOH_MMC*/
  
- #if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
- #define VTUNCERRMSK_REG	0x1ac
- #define VTD_MSK_SPEC_ERRORS	(1 << 31)
- /*
-  * This is a quirk for masking vt-d spec defined errors to platform error
-  * handling logic. With out this, platforms using Intel 7500, 5500 chipsets
-  * (and the derivative chipsets like X58 etc) seem to generate NMI/SMI (based
-  * on the RAS config settings of the platform) when a vt-d fault happens.
-  * The resulting SMI caused the system to hang.
-  *
-  * VT-d spec related errors are already handled by the VT-d OS code, so no
-  * need to report the same error through other channels.
-  */
- static void vtd_mask_spec_errors(struct pci_dev *dev)
- {
- 	u32 word;
- 
- 	pci_read_config_dword(dev, VTUNCERRMSK_REG, &word);
- 	pci_write_config_dword(dev, VTUNCERRMSK_REG, word | VTD_MSK_SPEC_ERRORS);
- }
- DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x342e, vtd_mask_spec_errors);
- DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x3c28, vtd_mask_spec_errors);
- #endif
  
  static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
  			  struct pci_fixup *end)
--- 2678,2683 ----
diff -cBr 2.6.35/drivers/pcmcia/soc_common.c linux-2.6.35.y-512ac85/drivers/pcmcia/soc_common.c
*** 2.6.35/drivers/pcmcia/soc_common.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pcmcia/soc_common.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 65,71 ****
  		va_end(args);
  	}
  }
- EXPORT_SYMBOL(soc_pcmcia_debug);
  
  #endif
  
--- 65,70 ----
diff -cBr 2.6.35/drivers/platform/x86/acer-wmi.c linux-2.6.35.y-512ac85/drivers/platform/x86/acer-wmi.c
*** 2.6.35/drivers/platform/x86/acer-wmi.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/acer-wmi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 91,97 ****
   */
  #define AMW0_GUID1		"67C3371D-95A3-4C37-BB61-DD47B491DAAB"
  #define AMW0_GUID2		"431F16ED-0C2B-444C-B267-27DEB140CF9C"
! #define WMID_GUID1		"6AF4F258-B401-42FD-BE91-3D4AC2D7C0D3"
  #define WMID_GUID2		"95764E09-FB56-4e83-B31A-37761F60994A"
  
  MODULE_ALIAS("wmi:67C3371D-95A3-4C37-BB61-DD47B491DAAB");
--- 91,97 ----
   */
  #define AMW0_GUID1		"67C3371D-95A3-4C37-BB61-DD47B491DAAB"
  #define AMW0_GUID2		"431F16ED-0C2B-444C-B267-27DEB140CF9C"
! #define WMID_GUID1		"6AF4F258-B401-42fd-BE91-3D4AC2D7C0D3"
  #define WMID_GUID2		"95764E09-FB56-4e83-B31A-37761F60994A"
  
  MODULE_ALIAS("wmi:67C3371D-95A3-4C37-BB61-DD47B491DAAB");
***************
*** 1066,1072 ****
  			return -EINVAL;
  	return count;
  }
! static DEVICE_ATTR(threeg, S_IRUGO | S_IWUSR, show_bool_threeg,
  	set_bool_threeg);
  
  static ssize_t show_interface(struct device *dev, struct device_attribute *attr,
--- 1066,1072 ----
  			return -EINVAL;
  	return count;
  }
! static DEVICE_ATTR(threeg, S_IWUGO | S_IRUGO | S_IWUSR, show_bool_threeg,
  	set_bool_threeg);
  
  static ssize_t show_interface(struct device *dev, struct device_attribute *attr,
diff -cBr 2.6.35/drivers/platform/x86/asus_acpi.c linux-2.6.35.y-512ac85/drivers/platform/x86/asus_acpi.c
*** 2.6.35/drivers/platform/x86/asus_acpi.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/asus_acpi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1079,1086 ****
  	struct proc_dir_entry *proc;
  	mode_t mode;
  
  	if ((asus_uid == 0) && (asus_gid == 0)) {
! 		mode = S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP;
  	} else {
  		mode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;
  		printk(KERN_WARNING "  asus_uid and asus_gid parameters are "
--- 1079,1092 ----
  	struct proc_dir_entry *proc;
  	mode_t mode;
  
+ 	/*
+ 	 * If parameter uid or gid is not changed, keep the default setting for
+ 	 * our proc entries (-rw-rw-rw-) else, it means we care about security,
+ 	 * and then set to -rw-rw----
+ 	 */
+ 
  	if ((asus_uid == 0) && (asus_gid == 0)) {
! 		mode = S_IFREG | S_IRUGO | S_IWUGO;
  	} else {
  		mode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;
  		printk(KERN_WARNING "  asus_uid and asus_gid parameters are "
diff -cBr 2.6.35/drivers/platform/x86/Kconfig linux-2.6.35.y-512ac85/drivers/platform/x86/Kconfig
*** 2.6.35/drivers/platform/x86/Kconfig	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/Kconfig	2010-11-22 14:01:26.000000000 -0500
***************
*** 520,526 ****
  config ACPI_CMPC
  	tristate "CMPC Laptop Extras"
  	depends on X86 && ACPI
- 	depends on RFKILL || RFKILL=n
  	select INPUT
  	select BACKLIGHT_CLASS_DEVICE
  	default n
--- 520,525 ----
diff -cBr 2.6.35/drivers/platform/x86/tc1100-wmi.c linux-2.6.35.y-512ac85/drivers/platform/x86/tc1100-wmi.c
*** 2.6.35/drivers/platform/x86/tc1100-wmi.c	2011-05-07 19:57:18.426750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/tc1100-wmi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 162,168 ****
  			return -EINVAL; \
  	return count; \
  } \
! static DEVICE_ATTR(value, S_IRUGO | S_IWUSR, \
  	show_bool_##value, set_bool_##value);
  
  show_set_bool(wireless, TC1100_INSTANCE_WIRELESS);
--- 162,168 ----
  			return -EINVAL; \
  	return count; \
  } \
! static DEVICE_ATTR(value, S_IWUGO | S_IRUGO | S_IWUSR, \
  	show_bool_##value, set_bool_##value);
  
  show_set_bool(wireless, TC1100_INSTANCE_WIRELESS);
diff -cBr 2.6.35/drivers/platform/x86/thinkpad_acpi.c linux-2.6.35.y-512ac85/drivers/platform/x86/thinkpad_acpi.c
*** 2.6.35/drivers/platform/x86/thinkpad_acpi.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/thinkpad_acpi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1911,1927 ****
  	TP_ACPI_HOTKEYSCAN_VOLUMEDOWN,
  	TP_ACPI_HOTKEYSCAN_MUTE,
  	TP_ACPI_HOTKEYSCAN_THINKPAD,
- 	TP_ACPI_HOTKEYSCAN_UNK1,
- 	TP_ACPI_HOTKEYSCAN_UNK2,
- 	TP_ACPI_HOTKEYSCAN_UNK3,
- 	TP_ACPI_HOTKEYSCAN_UNK4,
- 	TP_ACPI_HOTKEYSCAN_UNK5,
- 	TP_ACPI_HOTKEYSCAN_UNK6,
- 	TP_ACPI_HOTKEYSCAN_UNK7,
- 	TP_ACPI_HOTKEYSCAN_UNK8,
- 
- 	/* Hotkey keymap size */
- 	TPACPI_HOTKEY_MAP_LEN
  };
  
  enum {	/* Keys/events available through NVRAM polling */
--- 1911,1916 ----
***************
*** 3093,3101 ****
  	TPACPI_Q_IBM('1', 'D', TPACPI_HK_Q_INIMASK), /* X22, X23, X24 */
  };
  
- typedef u16 tpacpi_keymap_entry_t;
- typedef tpacpi_keymap_entry_t tpacpi_keymap_t[TPACPI_HOTKEY_MAP_LEN];
- 
  static int __init hotkey_init(struct ibm_init_struct *iibm)
  {
  	/* Requirements for changing the default keymaps:
--- 3082,3087 ----
***************
*** 3127,3143 ****
  	 * If the above is too much to ask, don't change the keymap.
  	 * Ask the thinkpad-acpi maintainer to do it, instead.
  	 */
! 
! 	enum keymap_index {
! 		TPACPI_KEYMAP_IBM_GENERIC = 0,
! 		TPACPI_KEYMAP_LENOVO_GENERIC,
! 	};
! 
! 	static const tpacpi_keymap_t tpacpi_keymaps[] __initconst = {
! 	/* Generic keymap for IBM ThinkPads */
! 	[TPACPI_KEYMAP_IBM_GENERIC] = {
  		/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */
! 		KEY_FN_F1,	KEY_BATTERY,	KEY_COFFEE,	KEY_SLEEP,
  		KEY_WLAN,	KEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,
  		KEY_FN_F9,	KEY_FN_F10,	KEY_FN_F11,	KEY_SUSPEND,
  
--- 3113,3121 ----
  	 * If the above is too much to ask, don't change the keymap.
  	 * Ask the thinkpad-acpi maintainer to do it, instead.
  	 */
! 	static u16 ibm_keycode_map[] __initdata = {
  		/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */
! 		KEY_FN_F1,	KEY_FN_F2,	KEY_COFFEE,	KEY_SLEEP,
  		KEY_WLAN,	KEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,
  		KEY_FN_F9,	KEY_FN_F10,	KEY_FN_F11,	KEY_SUSPEND,
  
***************
*** 3168,3180 ****
  		/* (assignments unknown, please report if found) */
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
! 		},
! 
! 	/* Generic keymap for Lenovo ThinkPads */
! 	[TPACPI_KEYMAP_LENOVO_GENERIC] = {
  		/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */
  		KEY_FN_F1,	KEY_COFFEE,	KEY_BATTERY,	KEY_SLEEP,
! 		KEY_WLAN,	KEY_CAMERA, KEY_SWITCHVIDEOMODE, KEY_FN_F8,
  		KEY_FN_F9,	KEY_FN_F10,	KEY_FN_F11,	KEY_SUSPEND,
  
  		/* Scan codes 0x0C to 0x1F: Other ACPI HKEY hot keys */
--- 3146,3156 ----
  		/* (assignments unknown, please report if found) */
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
! 	};
! 	static u16 lenovo_keycode_map[] __initdata = {
  		/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */
  		KEY_FN_F1,	KEY_COFFEE,	KEY_BATTERY,	KEY_SLEEP,
! 		KEY_WLAN,	KEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,
  		KEY_FN_F9,	KEY_FN_F10,	KEY_FN_F11,	KEY_SUSPEND,
  
  		/* Scan codes 0x0C to 0x1F: Other ACPI HKEY hot keys */
***************
*** 3213,3237 ****
  		/* (assignments unknown, please report if found) */
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
- 		},
- 	};
- 
- 	static const struct tpacpi_quirk tpacpi_keymap_qtable[] __initconst = {
- 		/* Generic maps (fallback) */
- 		{
- 		  .vendor = PCI_VENDOR_ID_IBM,
- 		  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,
- 		  .quirks = TPACPI_KEYMAP_IBM_GENERIC,
- 		},
- 		{
- 		  .vendor = PCI_VENDOR_ID_LENOVO,
- 		  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,
- 		  .quirks = TPACPI_KEYMAP_LENOVO_GENERIC,
- 		},
  	};
  
! #define TPACPI_HOTKEY_MAP_SIZE		sizeof(tpacpi_keymap_t)
! #define TPACPI_HOTKEY_MAP_TYPESIZE	sizeof(tpacpi_keymap_entry_t)
  
  	int res, i;
  	int status;
--- 3189,3199 ----
  		/* (assignments unknown, please report if found) */
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
  		KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
  	};
  
! #define TPACPI_HOTKEY_MAP_LEN		ARRAY_SIZE(ibm_keycode_map)
! #define TPACPI_HOTKEY_MAP_SIZE		sizeof(ibm_keycode_map)
! #define TPACPI_HOTKEY_MAP_TYPESIZE	sizeof(ibm_keycode_map[0])
  
  	int res, i;
  	int status;
***************
*** 3240,3246 ****
  	bool tabletsw_state = false;
  
  	unsigned long quirks;
- 	unsigned long keymap_id;
  
  	vdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,
  			"initializing hotkey subdriver\n");
--- 3202,3207 ----
***************
*** 3391,3404 ****
  		goto err_exit;
  	}
  
! 	keymap_id = tpacpi_check_quirks(tpacpi_keymap_qtable,
! 					ARRAY_SIZE(tpacpi_keymap_qtable));
! 	BUG_ON(keymap_id >= ARRAY_SIZE(tpacpi_keymaps));
! 	dbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,
! 		   "using keymap number %lu\n", keymap_id);
! 
! 	memcpy(hotkey_keycode_map, &tpacpi_keymaps[keymap_id],
! 		TPACPI_HOTKEY_MAP_SIZE);
  
  	input_set_capability(tpacpi_inputdev, EV_MSC, MSC_SCAN);
  	tpacpi_inputdev->keycodesize = TPACPI_HOTKEY_MAP_TYPESIZE;
--- 3352,3368 ----
  		goto err_exit;
  	}
  
! 	if (tpacpi_is_lenovo()) {
! 		dbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,
! 			   "using Lenovo default hot key map\n");
! 		memcpy(hotkey_keycode_map, &lenovo_keycode_map,
! 			TPACPI_HOTKEY_MAP_SIZE);
! 	} else {
! 		dbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,
! 			   "using IBM default hot key map\n");
! 		memcpy(hotkey_keycode_map, &ibm_keycode_map,
! 			TPACPI_HOTKEY_MAP_SIZE);
! 	}
  
  	input_set_capability(tpacpi_inputdev, EV_MSC, MSC_SCAN);
  	tpacpi_inputdev->keycodesize = TPACPI_HOTKEY_MAP_TYPESIZE;
***************
*** 3505,3512 ****
  	*send_acpi_ev = true;
  	*ignore_acpi_ev = false;
  
! 	/* HKEY event 0x1001 is scancode 0x00 */
! 	if (scancode > 0 && scancode <= TPACPI_HOTKEY_MAP_LEN) {
  		scancode--;
  		if (!(hotkey_source_mask & (1 << scancode))) {
  			tpacpi_input_send_key_masked(scancode);
--- 3469,3475 ----
  	*send_acpi_ev = true;
  	*ignore_acpi_ev = false;
  
! 	if (scancode > 0 && scancode < 0x21) {
  		scancode--;
  		if (!(hotkey_source_mask & (1 << scancode))) {
  			tpacpi_input_send_key_masked(scancode);
diff -cBr 2.6.35/drivers/platform/x86/wmi.c linux-2.6.35.y-512ac85/drivers/platform/x86/wmi.c
*** 2.6.35/drivers/platform/x86/wmi.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/platform/x86/wmi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 795,801 ****
  		wblock = list_entry(p, struct wmi_block, list);
  		gblock = &wblock->gblock;
  
! 		if (memcmp(gblock->guid, guid_string, 16) == 0)
  			return true;
  	}
  	return false;
--- 795,801 ----
  		wblock = list_entry(p, struct wmi_block, list);
  		gblock = &wblock->gblock;
  
! 		if (strncmp(gblock->guid, guid_string, 16) == 0)
  			return true;
  	}
  	return false;
diff -cBr 2.6.35/drivers/pnp/pnpacpi/core.c linux-2.6.35.y-512ac85/drivers/pnp/pnpacpi/core.c
*** 2.6.35/drivers/pnp/pnpacpi/core.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/pnp/pnpacpi/core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 28,34 ****
  #include "../base.h"
  #include "pnpacpi.h"
  
! static int num;
  
  /* We need only to blacklist devices that have already an acpi driver that
   * can't use pnp layer. We don't need to blacklist device that are directly
--- 28,34 ----
  #include "../base.h"
  #include "pnpacpi.h"
  
! static int num = 0;
  
  /* We need only to blacklist devices that have already an acpi driver that
   * can't use pnp layer. We don't need to blacklist device that are directly
***************
*** 157,180 ****
  };
  EXPORT_SYMBOL(pnpacpi_protocol);
  
- static char *pnpacpi_get_id(struct acpi_device *device)
- {
- 	struct acpi_hardware_id *id;
- 
- 	list_for_each_entry(id, &device->pnp.ids, list) {
- 		if (ispnpidacpi(id->id))
- 			return id->id;
- 	}
- 
- 	return NULL;
- }
- 
  static int __init pnpacpi_add_device(struct acpi_device *device)
  {
  	acpi_handle temp = NULL;
  	acpi_status status;
  	struct pnp_dev *dev;
- 	char *pnpid;
  	struct acpi_hardware_id *id;
  
  	/*
--- 157,167 ----
***************
*** 182,198 ****
  	 * driver should not be loaded.
  	 */
  	status = acpi_get_handle(device->handle, "_CRS", &temp);
! 	if (ACPI_FAILURE(status))
! 		return 0;
! 
! 	pnpid = pnpacpi_get_id(device);
! 	if (!pnpid)
! 		return 0;
! 
! 	if (is_exclusive_device(device) || !device->status.present)
  		return 0;
  
! 	dev = pnp_alloc_dev(&pnpacpi_protocol, num, pnpid);
  	if (!dev)
  		return -ENOMEM;
  
--- 169,179 ----
  	 * driver should not be loaded.
  	 */
  	status = acpi_get_handle(device->handle, "_CRS", &temp);
! 	if (ACPI_FAILURE(status) || !ispnpidacpi(acpi_device_hid(device)) ||
! 	    is_exclusive_device(device) || (!device->status.present))
  		return 0;
  
! 	dev = pnp_alloc_dev(&pnpacpi_protocol, num, acpi_device_hid(device));
  	if (!dev)
  		return -ENOMEM;
  
***************
*** 223,229 ****
  		pnpacpi_parse_resource_option_data(dev);
  
  	list_for_each_entry(id, &device->pnp.ids, list) {
! 		if (!strcmp(id->id, pnpid))
  			continue;
  		if (!ispnpidacpi(id->id))
  			continue;
--- 204,210 ----
  		pnpacpi_parse_resource_option_data(dev);
  
  	list_for_each_entry(id, &device->pnp.ids, list) {
! 		if (!strcmp(id->id, acpi_device_hid(device)))
  			continue;
  		if (!ispnpidacpi(id->id))
  			continue;
diff -cBr 2.6.35/drivers/power/ds2760_battery.c linux-2.6.35.y-512ac85/drivers/power/ds2760_battery.c
*** 2.6.35/drivers/power/ds2760_battery.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/power/ds2760_battery.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 212,218 ****
  	if (di->rem_capacity > 100)
  		di->rem_capacity = 100;
  
! 	if (di->current_uA < -100L)
  		di->life_sec = -((di->accum_current_uAh - di->empty_uAh) * 36L)
  					/ (di->current_uA / 100L);
  	else
--- 212,218 ----
  	if (di->rem_capacity > 100)
  		di->rem_capacity = 100;
  
! 	if (di->current_uA >= 100L)
  		di->life_sec = -((di->accum_current_uAh - di->empty_uAh) * 36L)
  					/ (di->current_uA / 100L);
  	else
Only in 2.6.35/drivers/power: fuel_gauge.c
diff -cBr 2.6.35/drivers/power/olpc_battery.c linux-2.6.35.y-512ac85/drivers/power/olpc_battery.c
*** 2.6.35/drivers/power/olpc_battery.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/power/olpc_battery.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 271,284 ****
  		if (ret)
  			return ret;
  
! 		val->intval = (s16)be16_to_cpu(ec_word) * 9760L / 32;
  		break;
  	case POWER_SUPPLY_PROP_CURRENT_AVG:
  		ret = olpc_ec_cmd(EC_BAT_CURRENT, NULL, 0, (void *)&ec_word, 2);
  		if (ret)
  			return ret;
  
! 		val->intval = (s16)be16_to_cpu(ec_word) * 15625L / 120;
  		break;
  	case POWER_SUPPLY_PROP_CAPACITY:
  		ret = olpc_ec_cmd(EC_BAT_SOC, NULL, 0, &ec_byte, 1);
--- 271,284 ----
  		if (ret)
  			return ret;
  
! 		val->intval = (int)be16_to_cpu(ec_word) * 9760L / 32;
  		break;
  	case POWER_SUPPLY_PROP_CURRENT_AVG:
  		ret = olpc_ec_cmd(EC_BAT_CURRENT, NULL, 0, (void *)&ec_word, 2);
  		if (ret)
  			return ret;
  
! 		val->intval = (int)be16_to_cpu(ec_word) * 15625L / 120;
  		break;
  	case POWER_SUPPLY_PROP_CAPACITY:
  		ret = olpc_ec_cmd(EC_BAT_SOC, NULL, 0, &ec_byte, 1);
***************
*** 299,305 ****
  		if (ret)
  			return ret;
  
! 		val->intval = (s16)be16_to_cpu(ec_word) * 100 / 256;
  		break;
  	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
  		ret = olpc_ec_cmd(EC_AMB_TEMP, NULL, 0, (void *)&ec_word, 2);
--- 299,305 ----
  		if (ret)
  			return ret;
  
! 		val->intval = (int)be16_to_cpu(ec_word) * 100 / 256;
  		break;
  	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
  		ret = olpc_ec_cmd(EC_AMB_TEMP, NULL, 0, (void *)&ec_word, 2);
***************
*** 313,319 ****
  		if (ret)
  			return ret;
  
! 		val->intval = (s16)be16_to_cpu(ec_word) * 6250 / 15;
  		break;
  	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
  		ret = olpc_ec_cmd(EC_BAT_SERIAL, NULL, 0, (void *)&ser_buf, 8);
--- 313,319 ----
  		if (ret)
  			return ret;
  
! 		val->intval = (int)be16_to_cpu(ec_word) * 6250 / 15;
  		break;
  	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
  		ret = olpc_ec_cmd(EC_BAT_SERIAL, NULL, 0, (void *)&ser_buf, 8);
Only in 2.6.35/drivers/power: s3c_fake_battery.c
Only in 2.6.35/drivers/power: s5pc110_battery.c
Only in 2.6.35/drivers/power: s5pc110_battery.h
Only in 2.6.35/drivers/regulator: max8998.c
Only in 2.6.35/drivers/rtc: alarm.c
Only in 2.6.35/drivers/rtc: alarm-dev.c
diff -cBr 2.6.35/drivers/rtc/rtc-cmos.c linux-2.6.35.y-512ac85/drivers/rtc/rtc-cmos.c
*** 2.6.35/drivers/rtc/rtc-cmos.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/rtc/rtc-cmos.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,42 ****
  #include <linux/platform_device.h>
  #include <linux/mod_devicetable.h>
  #include <linux/log2.h>
- #include <linux/pm.h>
  
  /* this is for "generic access to PC-style RTC" using CMOS_READ/CMOS_WRITE */
  #include <asm-generic/rtc.h>
--- 36,41 ----
***************
*** 851,857 ****
  
  #ifdef	CONFIG_PM
  
! static int cmos_suspend(struct device *dev)
  {
  	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
  	unsigned char	tmp;
--- 850,856 ----
  
  #ifdef	CONFIG_PM
  
! static int cmos_suspend(struct device *dev, pm_message_t mesg)
  {
  	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
  	unsigned char	tmp;
***************
*** 899,905 ****
   */
  static inline int cmos_poweroff(struct device *dev)
  {
! 	return cmos_suspend(dev);
  }
  
  static int cmos_resume(struct device *dev)
--- 898,904 ----
   */
  static inline int cmos_poweroff(struct device *dev)
  {
! 	return cmos_suspend(dev, PMSG_HIBERNATE);
  }
  
  static int cmos_resume(struct device *dev)
***************
*** 946,954 ****
  	return 0;
  }
  
- static SIMPLE_DEV_PM_OPS(cmos_pm_ops, cmos_suspend, cmos_resume);
- 
  #else
  
  static inline int cmos_poweroff(struct device *dev)
  {
--- 945,953 ----
  	return 0;
  }
  
  #else
+ #define	cmos_suspend	NULL
+ #define	cmos_resume	NULL
  
  static inline int cmos_poweroff(struct device *dev)
  {
***************
*** 1084,1090 ****
  
  static int cmos_pnp_suspend(struct pnp_dev *pnp, pm_message_t mesg)
  {
! 	return cmos_suspend(&pnp->dev);
  }
  
  static int cmos_pnp_resume(struct pnp_dev *pnp)
--- 1083,1089 ----
  
  static int cmos_pnp_suspend(struct pnp_dev *pnp, pm_message_t mesg)
  {
! 	return cmos_suspend(&pnp->dev, mesg);
  }
  
  static int cmos_pnp_resume(struct pnp_dev *pnp)
***************
*** 1164,1172 ****
  	.shutdown	= cmos_platform_shutdown,
  	.driver = {
  		.name		= (char *) driver_name,
! #ifdef CONFIG_PM
! 		.pm		= &cmos_pm_ops,
! #endif
  	}
  };
  
--- 1163,1170 ----
  	.shutdown	= cmos_platform_shutdown,
  	.driver = {
  		.name		= (char *) driver_name,
! 		.suspend	= cmos_suspend,
! 		.resume		= cmos_resume,
  	}
  };
  
diff -cBr 2.6.35/drivers/rtc/rtc-ds1511.c linux-2.6.35.y-512ac85/drivers/rtc/rtc-ds1511.c
*** 2.6.35/drivers/rtc/rtc-ds1511.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/rtc/rtc-ds1511.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 485,491 ****
  static struct bin_attribute ds1511_nvram_attr = {
  	.attr = {
  		.name = "nvram",
! 		.mode = S_IRUGO | S_IWUSR,
  	},
  	.size = DS1511_RAM_MAX,
  	.read = ds1511_nvram_read,
--- 485,491 ----
  static struct bin_attribute ds1511_nvram_attr = {
  	.attr = {
  		.name = "nvram",
! 		.mode = S_IRUGO | S_IWUGO,
  	},
  	.size = DS1511_RAM_MAX,
  	.read = ds1511_nvram_read,
Only in 2.6.35/drivers/rtc: rtc-max8998.c
diff -cBr 2.6.35/drivers/rtc/rtc-rs5c372.c linux-2.6.35.y-512ac85/drivers/rtc/rtc-rs5c372.c
*** 2.6.35/drivers/rtc/rtc-rs5c372.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/rtc/rtc-rs5c372.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 207,213 ****
  static int rs5c372_set_datetime(struct i2c_client *client, struct rtc_time *tm)
  {
  	struct rs5c372	*rs5c = i2c_get_clientdata(client);
! 	unsigned char	buf[7];
  	int		addr;
  
  	dev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d "
--- 207,213 ----
  static int rs5c372_set_datetime(struct i2c_client *client, struct rtc_time *tm)
  {
  	struct rs5c372	*rs5c = i2c_get_clientdata(client);
! 	unsigned char	buf[8];
  	int		addr;
  
  	dev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d "
Only in 2.6.35/drivers/rtc: rtc-s3c.h
diff -cBr 2.6.35/drivers/s390/block/dasd_eckd.c linux-2.6.35.y-512ac85/drivers/s390/block/dasd_eckd.c
*** 2.6.35/drivers/s390/block/dasd_eckd.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/s390/block/dasd_eckd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 63,69 ****
  static struct ccw_device_id dasd_eckd_ids[] = {
  	{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3390, 0), .driver_info = 0x1},
  	{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3390, 0), .driver_info = 0x2},
! 	{ CCW_DEVICE_DEVTYPE (0x3880, 0, 0x3380, 0), .driver_info = 0x3},
  	{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3380, 0), .driver_info = 0x4},
  	{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3380, 0), .driver_info = 0x5},
  	{ CCW_DEVICE_DEVTYPE (0x9343, 0, 0x9345, 0), .driver_info = 0x6},
--- 63,69 ----
  static struct ccw_device_id dasd_eckd_ids[] = {
  	{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3390, 0), .driver_info = 0x1},
  	{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3390, 0), .driver_info = 0x2},
! 	{ CCW_DEVICE_DEVTYPE (0x3880, 0, 0x3390, 0), .driver_info = 0x3},
  	{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3380, 0), .driver_info = 0x4},
  	{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3380, 0), .driver_info = 0x5},
  	{ CCW_DEVICE_DEVTYPE (0x9343, 0, 0x9345, 0), .driver_info = 0x6},
diff -cBr 2.6.35/drivers/s390/char/keyboard.c linux-2.6.35.y-512ac85/drivers/s390/char/keyboard.c
*** 2.6.35/drivers/s390/char/keyboard.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/s390/char/keyboard.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 460,467 ****
  	  unsigned int cmd, unsigned long arg)
  {
  	void __user *argp;
! 	unsigned int ct;
! 	int perm;
  
  	argp = (void __user *)arg;
  
--- 460,466 ----
  	  unsigned int cmd, unsigned long arg)
  {
  	void __user *argp;
! 	int ct, perm;
  
  	argp = (void __user *)arg;
  
diff -cBr 2.6.35/drivers/scsi/device_handler/scsi_dh_alua.c linux-2.6.35.y-512ac85/drivers/scsi/device_handler/scsi_dh_alua.c
*** 2.6.35/drivers/scsi/device_handler/scsi_dh_alua.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/device_handler/scsi_dh_alua.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 720,727 ****
  	{"Intel", "Multi-Flex"},
  	{"NETAPP", "LUN"},
  	{"AIX", "NVDISK"},
- 	{"NETAPP", "LUN"},
- 	{"AIX", "NVDISK"},
  	{NULL, NULL}
  };
  
--- 720,725 ----
diff -cBr 2.6.35/drivers/scsi/libsas/sas_scsi_host.c linux-2.6.35.y-512ac85/drivers/scsi/libsas/sas_scsi_host.c
*** 2.6.35/drivers/scsi/libsas/sas_scsi_host.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/libsas/sas_scsi_host.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 649,655 ****
  
  	spin_lock_irqsave(shost->host_lock, flags);
  	list_splice_init(&shost->eh_cmd_q, &eh_work_q);
- 	shost->host_eh_scheduled = 0;
  	spin_unlock_irqrestore(shost->host_lock, flags);
  
  	SAS_DPRINTK("Enter %s\n", __func__);
--- 649,654 ----
diff -cBr 2.6.35/drivers/scsi/mpt2sas/mpt2sas_base.c linux-2.6.35.y-512ac85/drivers/scsi/mpt2sas/mpt2sas_base.c
*** 2.6.35/drivers/scsi/mpt2sas/mpt2sas_base.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/mpt2sas/mpt2sas_base.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2050,2058 ****
  		/* adjust hba_queue_depth, reply_free_queue_depth,
  		 * and queue_size
  		 */
! 		ioc->hba_queue_depth -= (queue_diff / 2);
! 		ioc->reply_free_queue_depth -= (queue_diff / 2);
! 		queue_size = facts->MaxReplyDescriptorPostQueueDepth;
  	}
  	ioc->reply_post_queue_depth = queue_size;
  
--- 2050,2058 ----
  		/* adjust hba_queue_depth, reply_free_queue_depth,
  		 * and queue_size
  		 */
! 		ioc->hba_queue_depth -= queue_diff;
! 		ioc->reply_free_queue_depth -= queue_diff;
! 		queue_size -= queue_diff;
  	}
  	ioc->reply_post_queue_depth = queue_size;
  
***************
*** 3736,3743 ****
  static void
  _base_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)
  {
- 	mpt2sas_scsih_reset_handler(ioc, reset_phase);
- 	mpt2sas_ctl_reset_handler(ioc, reset_phase);
  	switch (reset_phase) {
  	case MPT2_IOC_PRE_RESET:
  		dtmprintk(ioc, printk(MPT2SAS_DEBUG_FMT "%s: "
--- 3736,3741 ----
***************
*** 3768,3773 ****
--- 3766,3773 ----
  		    "MPT2_IOC_DONE_RESET\n", ioc->name, __func__));
  		break;
  	}
+ 	mpt2sas_scsih_reset_handler(ioc, reset_phase);
+ 	mpt2sas_ctl_reset_handler(ioc, reset_phase);
  }
  
  /**
***************
*** 3821,3827 ****
  {
  	int r;
  	unsigned long flags;
- 	u8 pe_complete = ioc->wait_for_port_enable_to_complete;
  
  	dtmprintk(ioc, printk(MPT2SAS_DEBUG_FMT "%s: enter\n", ioc->name,
  	    __func__));
--- 3821,3826 ----
***************
*** 3846,3859 ****
  	if (r)
  		goto out;
  	_base_reset_handler(ioc, MPT2_IOC_AFTER_RESET);
- 
- 	/* If this hard reset is called while port enable is active, then
- 	 * there is no reason to call make_ioc_operational
- 	 */
- 	if (pe_complete) {
- 		r = -EFAULT;
- 		goto out;
- 	}
  	r = _base_make_ioc_operational(ioc, sleep_flag);
  	if (!r)
  		_base_reset_handler(ioc, MPT2_IOC_DONE_RESET);
--- 3845,3850 ----
diff -cBr 2.6.35/drivers/scsi/mpt2sas/mpt2sas_scsih.c linux-2.6.35.y-512ac85/drivers/scsi/mpt2sas/mpt2sas_scsih.c
*** 2.6.35/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2759,2764 ****
--- 2759,2767 ----
  	u16 handle;
  
  	for (i = 0 ; i < event_data->NumEntries; i++) {
+ 		if (event_data->PHY[i].PhyStatus &
+ 		    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT)
+ 			continue;
  		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
  		if (!handle)
  			continue;
diff -cBr 2.6.35/drivers/scsi/qla2xxx/qla_iocb.c linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_iocb.c
*** 2.6.35/drivers/scsi/qla2xxx/qla_iocb.c	2011-05-07 19:57:18.436750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_iocb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1122,1128 ****
  		fcp_cmnd->additional_cdb_len |= 2;
  
  	int_to_scsilun(sp->cmd->device->lun, &fcp_cmnd->lun);
- 	host_to_fcp_swap((uint8_t *)&fcp_cmnd->lun, sizeof(fcp_cmnd->lun));
  	memcpy(fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);
  	cmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(fcp_cmnd_len);
  	cmd_pkt->fcp_cmnd_dseg_address[0] = cpu_to_le32(
--- 1122,1127 ----
diff -cBr 2.6.35/drivers/scsi/qla2xxx/qla_isr.c linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_isr.c
*** 2.6.35/drivers/scsi/qla2xxx/qla_isr.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_isr.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1119,1127 ****
  			fcport->port_type = FCT_TARGET;
  			if (iop[0] & BIT_8)
  				fcport->flags |= FCF_FCP2_DEVICE;
! 		} else if (iop[0] & BIT_5)
  			fcport->port_type = FCT_INITIATOR;
- 
  		if (logio->io_parameter[7] || logio->io_parameter[8])
  			fcport->supported_classes |= FC_COS_CLASS2;
  		if (logio->io_parameter[9] || logio->io_parameter[10])
--- 1119,1127 ----
  			fcport->port_type = FCT_TARGET;
  			if (iop[0] & BIT_8)
  				fcport->flags |= FCF_FCP2_DEVICE;
! 		}
! 		if (iop[0] & BIT_5)
  			fcport->port_type = FCT_INITIATOR;
  		if (logio->io_parameter[7] || logio->io_parameter[8])
  			fcport->supported_classes |= FC_COS_CLASS2;
  		if (logio->io_parameter[9] || logio->io_parameter[10])
diff -cBr 2.6.35/drivers/scsi/qla2xxx/qla_nx.c linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_nx.c
*** 2.6.35/drivers/scsi/qla2xxx/qla_nx.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_nx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2798,2804 ****
  			goto queuing_error_fcp_cmnd;
  
  		int_to_scsilun(sp->cmd->device->lun, &cmd_pkt->lun);
- 		host_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));
  
  		/* build FCP_CMND IU */
  		memset(ctx->fcp_cmnd, 0, sizeof(struct fcp_cmnd));
--- 2798,2803 ----
diff -cBr 2.6.35/drivers/scsi/qla2xxx/qla_os.c linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_os.c
*** 2.6.35/drivers/scsi/qla2xxx/qla_os.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/qla2xxx/qla_os.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2102,2108 ****
  		ha->init_cb_size = sizeof(struct mid_init_cb_81xx);
  		ha->gid_list_info_size = 8;
  		ha->optrom_size = OPTROM_SIZE_82XX;
- 		ha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;
  		ha->isp_ops = &qla82xx_isp_ops;
  		ha->flash_conf_off = FARX_ACCESS_FLASH_CONF;
  		ha->flash_data_off = FARX_ACCESS_FLASH_DATA;
--- 2102,2107 ----
diff -cBr 2.6.35/drivers/scsi/scsi_lib.c linux-2.6.35.y-512ac85/drivers/scsi/scsi_lib.c
*** 2.6.35/drivers/scsi/scsi_lib.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/scsi_lib.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1640,1647 ****
  
  	blk_queue_max_segment_size(q, dma_get_max_seg_size(dev));
  
  	if (!shost->use_clustering)
! 		q->limits.cluster = 0;
  
  	/*
  	 * set a reasonable default alignment on word boundaries: the
--- 1640,1648 ----
  
  	blk_queue_max_segment_size(q, dma_get_max_seg_size(dev));
  
+ 	/* New queue, no concurrency on queue_flags */
  	if (!shost->use_clustering)
! 		queue_flag_clear_unlocked(QUEUE_FLAG_CLUSTER, q);
  
  	/*
  	 * set a reasonable default alignment on word boundaries: the
diff -cBr 2.6.35/drivers/scsi/sd.c linux-2.6.35.y-512ac85/drivers/scsi/sd.c
*** 2.6.35/drivers/scsi/sd.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/sd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1111,1122 ****
  	u64 end_lba = blk_rq_pos(scmd->request) + (scsi_bufflen(scmd) / 512);
  	u64 bad_lba;
  	int info_valid;
- 	/*
- 	 * resid is optional but mostly filled in.  When it's unused,
- 	 * its value is zero, so we assume the whole buffer transferred
- 	 */
- 	unsigned int transferred = scsi_bufflen(scmd) - scsi_get_resid(scmd);
- 	unsigned int good_bytes;
  
  	if (!blk_fs_request(scmd->request))
  		return 0;
--- 1111,1116 ----
***************
*** 1150,1157 ****
  	/* This computation should always be done in terms of
  	 * the resolution of the device's medium.
  	 */
! 	good_bytes = (bad_lba - start_lba) * scmd->device->sector_size;
! 	return min(good_bytes, transferred);
  }
  
  /**
--- 1144,1150 ----
  	/* This computation should always be done in terms of
  	 * the resolution of the device's medium.
  	 */
! 	return (bad_lba - start_lba) * scmd->device->sector_size;
  }
  
  /**
diff -cBr 2.6.35/drivers/scsi/ses.c linux-2.6.35.y-512ac85/drivers/scsi/ses.c
*** 2.6.35/drivers/scsi/ses.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/scsi/ses.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 390,398 ****
  		len = (desc_ptr[2] << 8) + desc_ptr[3];
  		/* skip past overall descriptor */
  		desc_ptr += len + 4;
  	}
- 	if (ses_dev->page10)
- 		addl_desc_ptr = ses_dev->page10 + 8;
  	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
  	components = 0;
  	for (i = 0; i < types; i++, type_ptr += 4) {
--- 390,398 ----
  		len = (desc_ptr[2] << 8) + desc_ptr[3];
  		/* skip past overall descriptor */
  		desc_ptr += len + 4;
+ 		if (ses_dev->page10)
+ 			addl_desc_ptr = ses_dev->page10 + 8;
  	}
  	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
  	components = 0;
  	for (i = 0; i < types; i++, type_ptr += 4) {
diff -cBr 2.6.35/drivers/serial/8250.c linux-2.6.35.y-512ac85/drivers/serial/8250.c
*** 2.6.35/drivers/serial/8250.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/serial/8250.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 256,263 ****
  		.fifo_size	= 128,
  		.tx_loadsz	= 128,
  		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
! 		/* UART_CAP_EFR breaks billionon CF bluetooth card. */
! 		.flags		= UART_CAP_FIFO | UART_CAP_SLEEP,
  	},
  	[PORT_RSA] = {
  		.name		= "RSA",
--- 256,262 ----
  		.fifo_size	= 128,
  		.tx_loadsz	= 128,
  		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
! 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
  	},
  	[PORT_RSA] = {
  		.name		= "RSA",
diff -cBr 2.6.35/drivers/serial/imx.c linux-2.6.35.y-512ac85/drivers/serial/imx.c
*** 2.6.35/drivers/serial/imx.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/serial/imx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 383,395 ****
  static irqreturn_t imx_rtsint(int irq, void *dev_id)
  {
  	struct imx_port *sport = dev_id;
! 	unsigned int val;
  	unsigned long flags;
  
  	spin_lock_irqsave(&sport->port.lock, flags);
  
  	writel(USR1_RTSD, sport->port.membase + USR1);
- 	val = readl(sport->port.membase + USR1) & USR1_RTSS;
  	uart_handle_cts_change(&sport->port, !!val);
  	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
  
--- 383,394 ----
  static irqreturn_t imx_rtsint(int irq, void *dev_id)
  {
  	struct imx_port *sport = dev_id;
! 	unsigned int val = readl(sport->port.membase + USR1) & USR1_RTSS;
  	unsigned long flags;
  
  	spin_lock_irqsave(&sport->port.lock, flags);
  
  	writel(USR1_RTSD, sport->port.membase + USR1);
  	uart_handle_cts_change(&sport->port, !!val);
  	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
  
diff -cBr 2.6.35/drivers/ssb/b43_pci_bridge.c linux-2.6.35.y-512ac85/drivers/ssb/b43_pci_bridge.c
*** 2.6.35/drivers/ssb/b43_pci_bridge.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/ssb/b43_pci_bridge.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 24,30 ****
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4315) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4318) },
- 	{ PCI_DEVICE(PCI_VENDOR_ID_BCM_GVC,  0x4318) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4320) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
--- 24,29 ----
Only in 2.6.35/drivers/staging: android
diff -cBr 2.6.35/drivers/staging/asus_oled/asus_oled.c linux-2.6.35.y-512ac85/drivers/staging/asus_oled/asus_oled.c
*** 2.6.35/drivers/staging/asus_oled/asus_oled.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/asus_oled/asus_oled.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 620,632 ****
  
  #define ASUS_OLED_DEVICE_ATTR(_file)		dev_attr_asus_oled_##_file
  
! static DEVICE_ATTR(asus_oled_enabled, S_IWUSR | S_IRUGO,
  		   get_enabled, set_enabled);
! static DEVICE_ATTR(asus_oled_picture, S_IWUSR , NULL, set_picture);
  
! static DEVICE_ATTR(enabled, S_IWUSR | S_IRUGO,
  		   class_get_enabled, class_set_enabled);
! static DEVICE_ATTR(picture, S_IWUSR, NULL, class_set_picture);
  
  static int asus_oled_probe(struct usb_interface *interface,
  			   const struct usb_device_id *id)
--- 620,632 ----
  
  #define ASUS_OLED_DEVICE_ATTR(_file)		dev_attr_asus_oled_##_file
  
! static DEVICE_ATTR(asus_oled_enabled, S_IWUGO | S_IRUGO,
  		   get_enabled, set_enabled);
! static DEVICE_ATTR(asus_oled_picture, S_IWUGO , NULL, set_picture);
  
! static DEVICE_ATTR(enabled, S_IWUGO | S_IRUGO,
  		   class_get_enabled, class_set_enabled);
! static DEVICE_ATTR(picture, S_IWUGO, NULL, class_set_picture);
  
  static int asus_oled_probe(struct usb_interface *interface,
  			   const struct usb_device_id *id)
diff -cBr 2.6.35/drivers/staging/batman-adv/soft-interface.c linux-2.6.35.y-512ac85/drivers/staging/batman-adv/soft-interface.c
*** 2.6.35/drivers/staging/batman-adv/soft-interface.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/batman-adv/soft-interface.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 295,304 ****
  	skb_pull_rcsum(skb, hdr_size);
  /*	skb_set_mac_header(skb, -sizeof(struct ethhdr));*/
  
- 	if (unlikely(!pskb_may_pull(skb, ETH_HLEN))) {
- 		kfree_skb(skb);
- 		return;
- 	}
  	skb->dev = dev;
  	skb->protocol = eth_type_trans(skb, dev);
  
--- 295,300 ----
diff -cBr 2.6.35/drivers/staging/comedi/drivers/jr3_pci.c linux-2.6.35.y-512ac85/drivers/staging/comedi/drivers/jr3_pci.c
*** 2.6.35/drivers/staging/comedi/drivers/jr3_pci.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/comedi/drivers/jr3_pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 53,59 ****
  
  #define PCI_VENDOR_ID_JR3 0x1762
  #define PCI_DEVICE_ID_JR3_1_CHANNEL 0x3111
- #define PCI_DEVICE_ID_JR3_1_CHANNEL_NEW 0x1111
  #define PCI_DEVICE_ID_JR3_2_CHANNEL 0x3112
  #define PCI_DEVICE_ID_JR3_3_CHANNEL 0x3113
  #define PCI_DEVICE_ID_JR3_4_CHANNEL 0x3114
--- 53,58 ----
***************
*** 73,80 ****
  	{
  	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_1_CHANNEL,
  		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
- 	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_1_CHANNEL_NEW,
- 		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
  	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_2_CHANNEL,
  		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
  	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_3_CHANNEL,
--- 72,77 ----
***************
*** 811,820 ****
  					devpriv->n_channels = 1;
  				}
  				break;
- 			case PCI_DEVICE_ID_JR3_1_CHANNEL_NEW:{
- 					devpriv->n_channels = 1;
- 				}
- 				break;
  			case PCI_DEVICE_ID_JR3_2_CHANNEL:{
  					devpriv->n_channels = 2;
  				}
--- 808,813 ----
diff -cBr 2.6.35/drivers/staging/comedi/drivers/ni_labpc.c linux-2.6.35.y-512ac85/drivers/staging/comedi/drivers/ni_labpc.c
*** 2.6.35/drivers/staging/comedi/drivers/ni_labpc.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/comedi/drivers/ni_labpc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 571,578 ****
  	/* grab our IRQ */
  	if (irq) {
  		isr_flags = 0;
! 		if (thisboard->bustype == pci_bustype
! 		    || thisboard->bustype == pcmcia_bustype)
  			isr_flags |= IRQF_SHARED;
  		if (request_irq(irq, labpc_interrupt, isr_flags,
  				driver_labpc.driver_name, dev)) {
--- 571,577 ----
  	/* grab our IRQ */
  	if (irq) {
  		isr_flags = 0;
! 		if (thisboard->bustype == pci_bustype)
  			isr_flags |= IRQF_SHARED;
  		if (request_irq(irq, labpc_interrupt, isr_flags,
  				driver_labpc.driver_name, dev)) {
diff -cBr 2.6.35/drivers/staging/frontier/tranzport.c linux-2.6.35.y-512ac85/drivers/staging/frontier/tranzport.c
*** 2.6.35/drivers/staging/frontier/tranzport.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/frontier/tranzport.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 204,210 ****
      t->value = temp;							\
      return count;							\
    }									\
!   static DEVICE_ATTR(value, S_IWUSR | S_IRUGO, show_##value, set_##value);
  
  show_int(enable);
  show_int(offline);
--- 204,210 ----
      t->value = temp;							\
      return count;							\
    }									\
!   static DEVICE_ATTR(value, S_IWUGO | S_IRUGO, show_##value, set_##value);
  
  show_int(enable);
  show_int(offline);
diff -cBr 2.6.35/drivers/staging/hv/blkvsc_drv.c linux-2.6.35.y-512ac85/drivers/staging/hv/blkvsc_drv.c
*** 2.6.35/drivers/staging/hv/blkvsc_drv.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/blkvsc_drv.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 378,384 ****
  		blkdev->gd->first_minor = 0;
  	blkdev->gd->fops = &block_ops;
  	blkdev->gd->private_data = blkdev;
- 	blkdev->gd->driverfs_dev = &(blkdev->device_ctx->device);
  	sprintf(blkdev->gd->disk_name, "hd%c", 'a' + devnum);
  
  	blkvsc_do_inquiry(blkdev);
--- 378,383 ----
diff -cBr 2.6.35/drivers/staging/hv/channel.c linux-2.6.35.y-512ac85/drivers/staging/hv/channel.c
*** 2.6.35/drivers/staging/hv/channel.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/channel.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 78,91 ****
  
  	if (Channel->OfferMsg.MonitorAllocated) {
  		/* Each u32 represents 32 channels */
! 		sync_set_bit(Channel->OfferMsg.ChildRelId & 31,
  			(unsigned long *) gVmbusConnection.SendInterruptPage +
  			(Channel->OfferMsg.ChildRelId >> 5));
  
  		monitorPage = gVmbusConnection.MonitorPages;
  		monitorPage++; /* Get the child to parent monitor page */
  
! 		sync_set_bit(Channel->MonitorBit,
  			(unsigned long *)&monitorPage->TriggerGroup
  					[Channel->MonitorGroup].Pending);
  
--- 78,91 ----
  
  	if (Channel->OfferMsg.MonitorAllocated) {
  		/* Each u32 represents 32 channels */
! 		set_bit(Channel->OfferMsg.ChildRelId & 31,
  			(unsigned long *) gVmbusConnection.SendInterruptPage +
  			(Channel->OfferMsg.ChildRelId >> 5));
  
  		monitorPage = gVmbusConnection.MonitorPages;
  		monitorPage++; /* Get the child to parent monitor page */
  
! 		set_bit(Channel->MonitorBit,
  			(unsigned long *)&monitorPage->TriggerGroup
  					[Channel->MonitorGroup].Pending);
  
***************
*** 105,111 ****
  
  	if (Channel->OfferMsg.MonitorAllocated) {
  		/* Each u32 represents 32 channels */
! 		sync_clear_bit(Channel->OfferMsg.ChildRelId & 31,
  			  (unsigned long *)gVmbusConnection.SendInterruptPage +
  			  (Channel->OfferMsg.ChildRelId >> 5));
  
--- 105,111 ----
  
  	if (Channel->OfferMsg.MonitorAllocated) {
  		/* Each u32 represents 32 channels */
! 		clear_bit(Channel->OfferMsg.ChildRelId & 31,
  			  (unsigned long *)gVmbusConnection.SendInterruptPage +
  			  (Channel->OfferMsg.ChildRelId >> 5));
  
***************
*** 113,119 ****
  			(struct hv_monitor_page *)gVmbusConnection.MonitorPages;
  		monitorPage++; /* Get the child to parent monitor page */
  
! 		sync_clear_bit(Channel->MonitorBit,
  			  (unsigned long *)&monitorPage->TriggerGroup
  					[Channel->MonitorGroup].Pending);
  	}
--- 113,119 ----
  			(struct hv_monitor_page *)gVmbusConnection.MonitorPages;
  		monitorPage++; /* Get the child to parent monitor page */
  
! 		clear_bit(Channel->MonitorBit,
  			  (unsigned long *)&monitorPage->TriggerGroup
  					[Channel->MonitorGroup].Pending);
  	}
diff -cBr 2.6.35/drivers/staging/hv/connection.c linux-2.6.35.y-512ac85/drivers/staging/hv/connection.c
*** 2.6.35/drivers/staging/hv/connection.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/connection.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 292,300 ****
  		for (dword = 0; dword < maxdword; dword++) {
  			if (recvInterruptPage[dword]) {
  				for (bit = 0; bit < 32; bit++) {
! 					if (sync_test_and_clear_bit(bit,
! 						(unsigned long *)
! 						&recvInterruptPage[dword])) {
  						relid = (dword << 5) + bit;
  						DPRINT_DBG(VMBUS, "event detected for relid - %d", relid);
  
--- 292,298 ----
  		for (dword = 0; dword < maxdword; dword++) {
  			if (recvInterruptPage[dword]) {
  				for (bit = 0; bit < 32; bit++) {
! 					if (test_and_clear_bit(bit, (unsigned long *)&recvInterruptPage[dword])) {
  						relid = (dword << 5) + bit;
  						DPRINT_DBG(VMBUS, "event detected for relid - %d", relid);
  
***************
*** 339,345 ****
  	DPRINT_ENTER(VMBUS);
  
  	/* Each u32 represents 32 channels */
! 	sync_set_bit(childRelId & 31,
  		(unsigned long *)gVmbusConnection.SendInterruptPage +
  		(childRelId >> 5));
  
--- 337,343 ----
  	DPRINT_ENTER(VMBUS);
  
  	/* Each u32 represents 32 channels */
! 	set_bit(childRelId & 31,
  		(unsigned long *)gVmbusConnection.SendInterruptPage +
  		(childRelId >> 5));
  
diff -cBr 2.6.35/drivers/staging/hv/netvsc_drv.c linux-2.6.35.y-512ac85/drivers/staging/hv/netvsc_drv.c
*** 2.6.35/drivers/staging/hv/netvsc_drv.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/netvsc_drv.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 46,52 ****
  	/* point back to our device context */
  	struct vm_device *device_ctx;
  	unsigned long avail;
- 	struct work_struct work;
  };
  
  struct netvsc_driver_context {
--- 46,51 ----
***************
*** 238,244 ****
  {
  	struct vm_device *device_ctx = to_vm_device(device_obj);
  	struct net_device *net = dev_get_drvdata(&device_ctx->device);
- 	struct net_device_context *ndev_ctx;
  
  	DPRINT_ENTER(NETVSC_DRV);
  
--- 237,242 ----
***************
*** 251,259 ****
  	if (status == 1) {
  		netif_carrier_on(net);
  		netif_wake_queue(net);
- 		netif_notify_peers(net);
- 		ndev_ctx = netdev_priv(net);
- 		schedule_work(&ndev_ctx->work);
  	} else {
  		netif_carrier_off(net);
  		netif_stop_queue(net);
--- 249,254 ----
***************
*** 358,382 ****
  	.ndo_set_mac_address =		eth_mac_addr,
  };
  
- /*
-  * Send GARP packet to network peers after migrations.
-  * After Quick Migration, the network is not immediately operational in the
-  * current context when receiving RNDIS_STATUS_MEDIA_CONNECT event. So, add
-  * another netif_notify_peers() into a scheduled work, otherwise GARP packet
-  * will not be sent after quick migration, and cause network disconnection.
-  */
- static void netvsc_send_garp(struct work_struct *w)
- {
- 	struct net_device_context *ndev_ctx;
- 	struct net_device *net;
- 
- 	msleep(20);
- 	ndev_ctx = container_of(w, struct net_device_context, work);
- 	net = dev_get_drvdata(&ndev_ctx->device_ctx->device);
- 	netif_notify_peers(net);
- }
- 
- 
  static int netvsc_probe(struct device *device)
  {
  	struct driver_context *driver_ctx =
--- 353,358 ----
***************
*** 408,414 ****
  	net_device_ctx->device_ctx = device_ctx;
  	net_device_ctx->avail = ring_size;
  	dev_set_drvdata(device, net);
- 	INIT_WORK(&net_device_ctx->work, netvsc_send_garp);
  
  	/* Notify the netvsc driver of the new device */
  	ret = net_drv_obj->Base.OnDeviceAdd(device_obj, &device_info);
--- 384,389 ----
diff -cBr 2.6.35/drivers/staging/hv/vmbus.c linux-2.6.35.y-512ac85/drivers/staging/hv/vmbus.c
*** 2.6.35/drivers/staging/hv/vmbus.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/vmbus.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 254,260 ****
  	event = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;
  
  	/* Since we are a child, we only need to check bit 0 */
! 	if (sync_test_and_clear_bit(0, (unsigned long *) &event->Flags32[0])) {
  		DPRINT_DBG(VMBUS, "received event %d", event->Flags32[0]);
  		ret |= 0x2;
  	}
--- 254,260 ----
  	event = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;
  
  	/* Since we are a child, we only need to check bit 0 */
! 	if (test_and_clear_bit(0, (unsigned long *) &event->Flags32[0])) {
  		DPRINT_DBG(VMBUS, "received event %d", event->Flags32[0]);
  		ret |= 0x2;
  	}
diff -cBr 2.6.35/drivers/staging/hv/vmbus_private.h linux-2.6.35.y-512ac85/drivers/staging/hv/vmbus_private.h
*** 2.6.35/drivers/staging/hv/vmbus_private.h	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/hv/vmbus_private.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 32,38 ****
  #include "channel_interface.h"
  #include "ring_buffer.h"
  #include <linux/list.h>
- #include <asm/sync_bitops.h>
  
  
  /*
--- 32,37 ----
diff -cBr 2.6.35/drivers/staging/iio/accel/adis16220_core.c linux-2.6.35.y-512ac85/drivers/staging/iio/accel/adis16220_core.c
*** 2.6.35/drivers/staging/iio/accel/adis16220_core.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/iio/accel/adis16220_core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 506,512 ****
  		adis16220_write_reset, 0);
  
  #define IIO_DEV_ATTR_CAPTURE(_store)				\
! 	IIO_DEVICE_ATTR(capture, S_IWUSR, NULL, _store, 0)
  
  static IIO_DEV_ATTR_CAPTURE(adis16220_write_capture);
  
--- 506,512 ----
  		adis16220_write_reset, 0);
  
  #define IIO_DEV_ATTR_CAPTURE(_store)				\
! 	IIO_DEVICE_ATTR(capture, S_IWUGO, NULL, _store, 0)
  
  static IIO_DEV_ATTR_CAPTURE(adis16220_write_capture);
  
diff -cBr 2.6.35/drivers/staging/line6/control.c linux-2.6.35.y-512ac85/drivers/staging/line6/control.c
*** 2.6.35/drivers/staging/line6/control.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/line6/control.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 268,477 ****
  VARIAX_PARAM_R(float, mix1);
  VARIAX_PARAM_R(int, pickup_wiring);
  
! static DEVICE_ATTR(tweak, S_IWUSR | S_IRUGO, pod_get_tweak, pod_set_tweak);
! static DEVICE_ATTR(wah_position, S_IWUSR | S_IRUGO, pod_get_wah_position,
  		   pod_set_wah_position);
! static DEVICE_ATTR(compression_gain, S_IWUSR | S_IRUGO,
  		   pod_get_compression_gain, pod_set_compression_gain);
! static DEVICE_ATTR(vol_pedal_position, S_IWUSR | S_IRUGO,
  		   pod_get_vol_pedal_position, pod_set_vol_pedal_position);
! static DEVICE_ATTR(compression_threshold, S_IWUSR | S_IRUGO,
  		   pod_get_compression_threshold,
  		   pod_set_compression_threshold);
! static DEVICE_ATTR(pan, S_IWUSR | S_IRUGO, pod_get_pan, pod_set_pan);
! static DEVICE_ATTR(amp_model_setup, S_IWUSR | S_IRUGO, pod_get_amp_model_setup,
  		   pod_set_amp_model_setup);
! static DEVICE_ATTR(amp_model, S_IWUSR | S_IRUGO, pod_get_amp_model,
  		   pod_set_amp_model);
! static DEVICE_ATTR(drive, S_IWUSR | S_IRUGO, pod_get_drive, pod_set_drive);
! static DEVICE_ATTR(bass, S_IWUSR | S_IRUGO, pod_get_bass, pod_set_bass);
! static DEVICE_ATTR(mid, S_IWUSR | S_IRUGO, pod_get_mid, pod_set_mid);
! static DEVICE_ATTR(lowmid, S_IWUSR | S_IRUGO, pod_get_lowmid, pod_set_lowmid);
! static DEVICE_ATTR(treble, S_IWUSR | S_IRUGO, pod_get_treble, pod_set_treble);
! static DEVICE_ATTR(highmid, S_IWUSR | S_IRUGO, pod_get_highmid,
  		   pod_set_highmid);
! static DEVICE_ATTR(chan_vol, S_IWUSR | S_IRUGO, pod_get_chan_vol,
  		   pod_set_chan_vol);
! static DEVICE_ATTR(reverb_mix, S_IWUSR | S_IRUGO, pod_get_reverb_mix,
  		   pod_set_reverb_mix);
! static DEVICE_ATTR(effect_setup, S_IWUSR | S_IRUGO, pod_get_effect_setup,
  		   pod_set_effect_setup);
! static DEVICE_ATTR(band_1_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_1_frequency, pod_set_band_1_frequency);
! static DEVICE_ATTR(presence, S_IWUSR | S_IRUGO, pod_get_presence,
  		   pod_set_presence);
! static DEVICE_ATTR2(treble__bass, treble, S_IWUSR | S_IRUGO,
  		    pod_get_treble__bass, pod_set_treble__bass);
! static DEVICE_ATTR(noise_gate_enable, S_IWUSR | S_IRUGO,
  		   pod_get_noise_gate_enable, pod_set_noise_gate_enable);
! static DEVICE_ATTR(gate_threshold, S_IWUSR | S_IRUGO, pod_get_gate_threshold,
  		   pod_set_gate_threshold);
! static DEVICE_ATTR(gate_decay_time, S_IWUSR | S_IRUGO, pod_get_gate_decay_time,
  		   pod_set_gate_decay_time);
! static DEVICE_ATTR(stomp_enable, S_IWUSR | S_IRUGO, pod_get_stomp_enable,
  		   pod_set_stomp_enable);
! static DEVICE_ATTR(comp_enable, S_IWUSR | S_IRUGO, pod_get_comp_enable,
  		   pod_set_comp_enable);
! static DEVICE_ATTR(stomp_time, S_IWUSR | S_IRUGO, pod_get_stomp_time,
  		   pod_set_stomp_time);
! static DEVICE_ATTR(delay_enable, S_IWUSR | S_IRUGO, pod_get_delay_enable,
  		   pod_set_delay_enable);
! static DEVICE_ATTR(mod_param_1, S_IWUSR | S_IRUGO, pod_get_mod_param_1,
  		   pod_set_mod_param_1);
! static DEVICE_ATTR(delay_param_1, S_IWUSR | S_IRUGO, pod_get_delay_param_1,
  		   pod_set_delay_param_1);
! static DEVICE_ATTR(delay_param_1_note_value, S_IWUSR | S_IRUGO,
  		   pod_get_delay_param_1_note_value,
  		   pod_set_delay_param_1_note_value);
! static DEVICE_ATTR2(band_2_frequency__bass, band_2_frequency, S_IWUSR | S_IRUGO,
  		    pod_get_band_2_frequency__bass,
  		    pod_set_band_2_frequency__bass);
! static DEVICE_ATTR(delay_param_2, S_IWUSR | S_IRUGO, pod_get_delay_param_2,
  		   pod_set_delay_param_2);
! static DEVICE_ATTR(delay_volume_mix, S_IWUSR | S_IRUGO,
  		   pod_get_delay_volume_mix, pod_set_delay_volume_mix);
! static DEVICE_ATTR(delay_param_3, S_IWUSR | S_IRUGO, pod_get_delay_param_3,
  		   pod_set_delay_param_3);
! static DEVICE_ATTR(reverb_enable, S_IWUSR | S_IRUGO, pod_get_reverb_enable,
  		   pod_set_reverb_enable);
! static DEVICE_ATTR(reverb_type, S_IWUSR | S_IRUGO, pod_get_reverb_type,
  		   pod_set_reverb_type);
! static DEVICE_ATTR(reverb_decay, S_IWUSR | S_IRUGO, pod_get_reverb_decay,
  		   pod_set_reverb_decay);
! static DEVICE_ATTR(reverb_tone, S_IWUSR | S_IRUGO, pod_get_reverb_tone,
  		   pod_set_reverb_tone);
! static DEVICE_ATTR(reverb_pre_delay, S_IWUSR | S_IRUGO,
  		   pod_get_reverb_pre_delay, pod_set_reverb_pre_delay);
! static DEVICE_ATTR(reverb_pre_post, S_IWUSR | S_IRUGO, pod_get_reverb_pre_post,
  		   pod_set_reverb_pre_post);
! static DEVICE_ATTR(band_2_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_2_frequency, pod_set_band_2_frequency);
! static DEVICE_ATTR2(band_3_frequency__bass, band_3_frequency, S_IWUSR | S_IRUGO,
  		    pod_get_band_3_frequency__bass,
  		    pod_set_band_3_frequency__bass);
! static DEVICE_ATTR(wah_enable, S_IWUSR | S_IRUGO, pod_get_wah_enable,
  		   pod_set_wah_enable);
! static DEVICE_ATTR(modulation_lo_cut, S_IWUSR | S_IRUGO,
  		   pod_get_modulation_lo_cut, pod_set_modulation_lo_cut);
! static DEVICE_ATTR(delay_reverb_lo_cut, S_IWUSR | S_IRUGO,
  		   pod_get_delay_reverb_lo_cut, pod_set_delay_reverb_lo_cut);
! static DEVICE_ATTR(volume_pedal_minimum, S_IWUSR | S_IRUGO,
  		   pod_get_volume_pedal_minimum, pod_set_volume_pedal_minimum);
! static DEVICE_ATTR(eq_pre_post, S_IWUSR | S_IRUGO, pod_get_eq_pre_post,
  		   pod_set_eq_pre_post);
! static DEVICE_ATTR(volume_pre_post, S_IWUSR | S_IRUGO, pod_get_volume_pre_post,
  		   pod_set_volume_pre_post);
! static DEVICE_ATTR(di_model, S_IWUSR | S_IRUGO, pod_get_di_model,
  		   pod_set_di_model);
! static DEVICE_ATTR(di_delay, S_IWUSR | S_IRUGO, pod_get_di_delay,
  		   pod_set_di_delay);
! static DEVICE_ATTR(mod_enable, S_IWUSR | S_IRUGO, pod_get_mod_enable,
  		   pod_set_mod_enable);
! static DEVICE_ATTR(mod_param_1_note_value, S_IWUSR | S_IRUGO,
  		   pod_get_mod_param_1_note_value,
  		   pod_set_mod_param_1_note_value);
! static DEVICE_ATTR(mod_param_2, S_IWUSR | S_IRUGO, pod_get_mod_param_2,
  		   pod_set_mod_param_2);
! static DEVICE_ATTR(mod_param_3, S_IWUSR | S_IRUGO, pod_get_mod_param_3,
  		   pod_set_mod_param_3);
! static DEVICE_ATTR(mod_param_4, S_IWUSR | S_IRUGO, pod_get_mod_param_4,
  		   pod_set_mod_param_4);
! static DEVICE_ATTR(mod_param_5, S_IWUSR | S_IRUGO, pod_get_mod_param_5,
  		   pod_set_mod_param_5);
! static DEVICE_ATTR(mod_volume_mix, S_IWUSR | S_IRUGO, pod_get_mod_volume_mix,
  		   pod_set_mod_volume_mix);
! static DEVICE_ATTR(mod_pre_post, S_IWUSR | S_IRUGO, pod_get_mod_pre_post,
  		   pod_set_mod_pre_post);
! static DEVICE_ATTR(modulation_model, S_IWUSR | S_IRUGO,
  		   pod_get_modulation_model, pod_set_modulation_model);
! static DEVICE_ATTR(band_3_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_3_frequency, pod_set_band_3_frequency);
! static DEVICE_ATTR2(band_4_frequency__bass, band_4_frequency, S_IWUSR | S_IRUGO,
  		    pod_get_band_4_frequency__bass,
  		    pod_set_band_4_frequency__bass);
! static DEVICE_ATTR(mod_param_1_double_precision, S_IWUSR | S_IRUGO,
  		   pod_get_mod_param_1_double_precision,
  		   pod_set_mod_param_1_double_precision);
! static DEVICE_ATTR(delay_param_1_double_precision, S_IWUSR | S_IRUGO,
  		   pod_get_delay_param_1_double_precision,
  		   pod_set_delay_param_1_double_precision);
! static DEVICE_ATTR(eq_enable, S_IWUSR | S_IRUGO, pod_get_eq_enable,
  		   pod_set_eq_enable);
! static DEVICE_ATTR(tap, S_IWUSR | S_IRUGO, pod_get_tap, pod_set_tap);
! static DEVICE_ATTR(volume_tweak_pedal_assign, S_IWUSR | S_IRUGO,
  		   pod_get_volume_tweak_pedal_assign,
  		   pod_set_volume_tweak_pedal_assign);
! static DEVICE_ATTR(band_5_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_5_frequency, pod_set_band_5_frequency);
! static DEVICE_ATTR(tuner, S_IWUSR | S_IRUGO, pod_get_tuner, pod_set_tuner);
! static DEVICE_ATTR(mic_selection, S_IWUSR | S_IRUGO, pod_get_mic_selection,
  		   pod_set_mic_selection);
! static DEVICE_ATTR(cabinet_model, S_IWUSR | S_IRUGO, pod_get_cabinet_model,
  		   pod_set_cabinet_model);
! static DEVICE_ATTR(stomp_model, S_IWUSR | S_IRUGO, pod_get_stomp_model,
  		   pod_set_stomp_model);
! static DEVICE_ATTR(roomlevel, S_IWUSR | S_IRUGO, pod_get_roomlevel,
  		   pod_set_roomlevel);
! static DEVICE_ATTR(band_4_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_4_frequency, pod_set_band_4_frequency);
! static DEVICE_ATTR(band_6_frequency, S_IWUSR | S_IRUGO,
  		   pod_get_band_6_frequency, pod_set_band_6_frequency);
! static DEVICE_ATTR(stomp_param_1_note_value, S_IWUSR | S_IRUGO,
  		   pod_get_stomp_param_1_note_value,
  		   pod_set_stomp_param_1_note_value);
! static DEVICE_ATTR(stomp_param_2, S_IWUSR | S_IRUGO, pod_get_stomp_param_2,
  		   pod_set_stomp_param_2);
! static DEVICE_ATTR(stomp_param_3, S_IWUSR | S_IRUGO, pod_get_stomp_param_3,
  		   pod_set_stomp_param_3);
! static DEVICE_ATTR(stomp_param_4, S_IWUSR | S_IRUGO, pod_get_stomp_param_4,
  		   pod_set_stomp_param_4);
! static DEVICE_ATTR(stomp_param_5, S_IWUSR | S_IRUGO, pod_get_stomp_param_5,
  		   pod_set_stomp_param_5);
! static DEVICE_ATTR(stomp_param_6, S_IWUSR | S_IRUGO, pod_get_stomp_param_6,
  		   pod_set_stomp_param_6);
! static DEVICE_ATTR(amp_switch_select, S_IWUSR | S_IRUGO,
  		   pod_get_amp_switch_select, pod_set_amp_switch_select);
! static DEVICE_ATTR(delay_param_4, S_IWUSR | S_IRUGO, pod_get_delay_param_4,
  		   pod_set_delay_param_4);
! static DEVICE_ATTR(delay_param_5, S_IWUSR | S_IRUGO, pod_get_delay_param_5,
  		   pod_set_delay_param_5);
! static DEVICE_ATTR(delay_pre_post, S_IWUSR | S_IRUGO, pod_get_delay_pre_post,
  		   pod_set_delay_pre_post);
! static DEVICE_ATTR(delay_model, S_IWUSR | S_IRUGO, pod_get_delay_model,
  		   pod_set_delay_model);
! static DEVICE_ATTR(delay_verb_model, S_IWUSR | S_IRUGO,
  		   pod_get_delay_verb_model, pod_set_delay_verb_model);
! static DEVICE_ATTR(tempo_msb, S_IWUSR | S_IRUGO, pod_get_tempo_msb,
  		   pod_set_tempo_msb);
! static DEVICE_ATTR(tempo_lsb, S_IWUSR | S_IRUGO, pod_get_tempo_lsb,
  		   pod_set_tempo_lsb);
! static DEVICE_ATTR(wah_model, S_IWUSR | S_IRUGO, pod_get_wah_model,
  		   pod_set_wah_model);
! static DEVICE_ATTR(bypass_volume, S_IWUSR | S_IRUGO, pod_get_bypass_volume,
  		   pod_set_bypass_volume);
! static DEVICE_ATTR(fx_loop_on_off, S_IWUSR | S_IRUGO, pod_get_fx_loop_on_off,
  		   pod_set_fx_loop_on_off);
! static DEVICE_ATTR(tweak_param_select, S_IWUSR | S_IRUGO,
  		   pod_get_tweak_param_select, pod_set_tweak_param_select);
! static DEVICE_ATTR(amp1_engage, S_IWUSR | S_IRUGO, pod_get_amp1_engage,
  		   pod_set_amp1_engage);
! static DEVICE_ATTR(band_1_gain, S_IWUSR | S_IRUGO, pod_get_band_1_gain,
  		   pod_set_band_1_gain);
! static DEVICE_ATTR2(band_2_gain__bass, band_2_gain, S_IWUSR | S_IRUGO,
  		    pod_get_band_2_gain__bass, pod_set_band_2_gain__bass);
! static DEVICE_ATTR(band_2_gain, S_IWUSR | S_IRUGO, pod_get_band_2_gain,
  		   pod_set_band_2_gain);
! static DEVICE_ATTR2(band_3_gain__bass, band_3_gain, S_IWUSR | S_IRUGO,
  		    pod_get_band_3_gain__bass, pod_set_band_3_gain__bass);
! static DEVICE_ATTR(band_3_gain, S_IWUSR | S_IRUGO, pod_get_band_3_gain,
  		   pod_set_band_3_gain);
! static DEVICE_ATTR2(band_4_gain__bass, band_4_gain, S_IWUSR | S_IRUGO,
  		    pod_get_band_4_gain__bass, pod_set_band_4_gain__bass);
! static DEVICE_ATTR2(band_5_gain__bass, band_5_gain, S_IWUSR | S_IRUGO,
  		    pod_get_band_5_gain__bass, pod_set_band_5_gain__bass);
! static DEVICE_ATTR(band_4_gain, S_IWUSR | S_IRUGO, pod_get_band_4_gain,
  		   pod_set_band_4_gain);
! static DEVICE_ATTR2(band_6_gain__bass, band_6_gain, S_IWUSR | S_IRUGO,
  		    pod_get_band_6_gain__bass, pod_set_band_6_gain__bass);
  static DEVICE_ATTR(body, S_IRUGO, variax_get_body, line6_nop_write);
  static DEVICE_ATTR(pickup1_enable, S_IRUGO, variax_get_pickup1_enable,
--- 268,477 ----
  VARIAX_PARAM_R(float, mix1);
  VARIAX_PARAM_R(int, pickup_wiring);
  
! static DEVICE_ATTR(tweak, S_IWUGO | S_IRUGO, pod_get_tweak, pod_set_tweak);
! static DEVICE_ATTR(wah_position, S_IWUGO | S_IRUGO, pod_get_wah_position,
  		   pod_set_wah_position);
! static DEVICE_ATTR(compression_gain, S_IWUGO | S_IRUGO,
  		   pod_get_compression_gain, pod_set_compression_gain);
! static DEVICE_ATTR(vol_pedal_position, S_IWUGO | S_IRUGO,
  		   pod_get_vol_pedal_position, pod_set_vol_pedal_position);
! static DEVICE_ATTR(compression_threshold, S_IWUGO | S_IRUGO,
  		   pod_get_compression_threshold,
  		   pod_set_compression_threshold);
! static DEVICE_ATTR(pan, S_IWUGO | S_IRUGO, pod_get_pan, pod_set_pan);
! static DEVICE_ATTR(amp_model_setup, S_IWUGO | S_IRUGO, pod_get_amp_model_setup,
  		   pod_set_amp_model_setup);
! static DEVICE_ATTR(amp_model, S_IWUGO | S_IRUGO, pod_get_amp_model,
  		   pod_set_amp_model);
! static DEVICE_ATTR(drive, S_IWUGO | S_IRUGO, pod_get_drive, pod_set_drive);
! static DEVICE_ATTR(bass, S_IWUGO | S_IRUGO, pod_get_bass, pod_set_bass);
! static DEVICE_ATTR(mid, S_IWUGO | S_IRUGO, pod_get_mid, pod_set_mid);
! static DEVICE_ATTR(lowmid, S_IWUGO | S_IRUGO, pod_get_lowmid, pod_set_lowmid);
! static DEVICE_ATTR(treble, S_IWUGO | S_IRUGO, pod_get_treble, pod_set_treble);
! static DEVICE_ATTR(highmid, S_IWUGO | S_IRUGO, pod_get_highmid,
  		   pod_set_highmid);
! static DEVICE_ATTR(chan_vol, S_IWUGO | S_IRUGO, pod_get_chan_vol,
  		   pod_set_chan_vol);
! static DEVICE_ATTR(reverb_mix, S_IWUGO | S_IRUGO, pod_get_reverb_mix,
  		   pod_set_reverb_mix);
! static DEVICE_ATTR(effect_setup, S_IWUGO | S_IRUGO, pod_get_effect_setup,
  		   pod_set_effect_setup);
! static DEVICE_ATTR(band_1_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_1_frequency, pod_set_band_1_frequency);
! static DEVICE_ATTR(presence, S_IWUGO | S_IRUGO, pod_get_presence,
  		   pod_set_presence);
! static DEVICE_ATTR2(treble__bass, treble, S_IWUGO | S_IRUGO,
  		    pod_get_treble__bass, pod_set_treble__bass);
! static DEVICE_ATTR(noise_gate_enable, S_IWUGO | S_IRUGO,
  		   pod_get_noise_gate_enable, pod_set_noise_gate_enable);
! static DEVICE_ATTR(gate_threshold, S_IWUGO | S_IRUGO, pod_get_gate_threshold,
  		   pod_set_gate_threshold);
! static DEVICE_ATTR(gate_decay_time, S_IWUGO | S_IRUGO, pod_get_gate_decay_time,
  		   pod_set_gate_decay_time);
! static DEVICE_ATTR(stomp_enable, S_IWUGO | S_IRUGO, pod_get_stomp_enable,
  		   pod_set_stomp_enable);
! static DEVICE_ATTR(comp_enable, S_IWUGO | S_IRUGO, pod_get_comp_enable,
  		   pod_set_comp_enable);
! static DEVICE_ATTR(stomp_time, S_IWUGO | S_IRUGO, pod_get_stomp_time,
  		   pod_set_stomp_time);
! static DEVICE_ATTR(delay_enable, S_IWUGO | S_IRUGO, pod_get_delay_enable,
  		   pod_set_delay_enable);
! static DEVICE_ATTR(mod_param_1, S_IWUGO | S_IRUGO, pod_get_mod_param_1,
  		   pod_set_mod_param_1);
! static DEVICE_ATTR(delay_param_1, S_IWUGO | S_IRUGO, pod_get_delay_param_1,
  		   pod_set_delay_param_1);
! static DEVICE_ATTR(delay_param_1_note_value, S_IWUGO | S_IRUGO,
  		   pod_get_delay_param_1_note_value,
  		   pod_set_delay_param_1_note_value);
! static DEVICE_ATTR2(band_2_frequency__bass, band_2_frequency, S_IWUGO | S_IRUGO,
  		    pod_get_band_2_frequency__bass,
  		    pod_set_band_2_frequency__bass);
! static DEVICE_ATTR(delay_param_2, S_IWUGO | S_IRUGO, pod_get_delay_param_2,
  		   pod_set_delay_param_2);
! static DEVICE_ATTR(delay_volume_mix, S_IWUGO | S_IRUGO,
  		   pod_get_delay_volume_mix, pod_set_delay_volume_mix);
! static DEVICE_ATTR(delay_param_3, S_IWUGO | S_IRUGO, pod_get_delay_param_3,
  		   pod_set_delay_param_3);
! static DEVICE_ATTR(reverb_enable, S_IWUGO | S_IRUGO, pod_get_reverb_enable,
  		   pod_set_reverb_enable);
! static DEVICE_ATTR(reverb_type, S_IWUGO | S_IRUGO, pod_get_reverb_type,
  		   pod_set_reverb_type);
! static DEVICE_ATTR(reverb_decay, S_IWUGO | S_IRUGO, pod_get_reverb_decay,
  		   pod_set_reverb_decay);
! static DEVICE_ATTR(reverb_tone, S_IWUGO | S_IRUGO, pod_get_reverb_tone,
  		   pod_set_reverb_tone);
! static DEVICE_ATTR(reverb_pre_delay, S_IWUGO | S_IRUGO,
  		   pod_get_reverb_pre_delay, pod_set_reverb_pre_delay);
! static DEVICE_ATTR(reverb_pre_post, S_IWUGO | S_IRUGO, pod_get_reverb_pre_post,
  		   pod_set_reverb_pre_post);
! static DEVICE_ATTR(band_2_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_2_frequency, pod_set_band_2_frequency);
! static DEVICE_ATTR2(band_3_frequency__bass, band_3_frequency, S_IWUGO | S_IRUGO,
  		    pod_get_band_3_frequency__bass,
  		    pod_set_band_3_frequency__bass);
! static DEVICE_ATTR(wah_enable, S_IWUGO | S_IRUGO, pod_get_wah_enable,
  		   pod_set_wah_enable);
! static DEVICE_ATTR(modulation_lo_cut, S_IWUGO | S_IRUGO,
  		   pod_get_modulation_lo_cut, pod_set_modulation_lo_cut);
! static DEVICE_ATTR(delay_reverb_lo_cut, S_IWUGO | S_IRUGO,
  		   pod_get_delay_reverb_lo_cut, pod_set_delay_reverb_lo_cut);
! static DEVICE_ATTR(volume_pedal_minimum, S_IWUGO | S_IRUGO,
  		   pod_get_volume_pedal_minimum, pod_set_volume_pedal_minimum);
! static DEVICE_ATTR(eq_pre_post, S_IWUGO | S_IRUGO, pod_get_eq_pre_post,
  		   pod_set_eq_pre_post);
! static DEVICE_ATTR(volume_pre_post, S_IWUGO | S_IRUGO, pod_get_volume_pre_post,
  		   pod_set_volume_pre_post);
! static DEVICE_ATTR(di_model, S_IWUGO | S_IRUGO, pod_get_di_model,
  		   pod_set_di_model);
! static DEVICE_ATTR(di_delay, S_IWUGO | S_IRUGO, pod_get_di_delay,
  		   pod_set_di_delay);
! static DEVICE_ATTR(mod_enable, S_IWUGO | S_IRUGO, pod_get_mod_enable,
  		   pod_set_mod_enable);
! static DEVICE_ATTR(mod_param_1_note_value, S_IWUGO | S_IRUGO,
  		   pod_get_mod_param_1_note_value,
  		   pod_set_mod_param_1_note_value);
! static DEVICE_ATTR(mod_param_2, S_IWUGO | S_IRUGO, pod_get_mod_param_2,
  		   pod_set_mod_param_2);
! static DEVICE_ATTR(mod_param_3, S_IWUGO | S_IRUGO, pod_get_mod_param_3,
  		   pod_set_mod_param_3);
! static DEVICE_ATTR(mod_param_4, S_IWUGO | S_IRUGO, pod_get_mod_param_4,
  		   pod_set_mod_param_4);
! static DEVICE_ATTR(mod_param_5, S_IWUGO | S_IRUGO, pod_get_mod_param_5,
  		   pod_set_mod_param_5);
! static DEVICE_ATTR(mod_volume_mix, S_IWUGO | S_IRUGO, pod_get_mod_volume_mix,
  		   pod_set_mod_volume_mix);
! static DEVICE_ATTR(mod_pre_post, S_IWUGO | S_IRUGO, pod_get_mod_pre_post,
  		   pod_set_mod_pre_post);
! static DEVICE_ATTR(modulation_model, S_IWUGO | S_IRUGO,
  		   pod_get_modulation_model, pod_set_modulation_model);
! static DEVICE_ATTR(band_3_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_3_frequency, pod_set_band_3_frequency);
! static DEVICE_ATTR2(band_4_frequency__bass, band_4_frequency, S_IWUGO | S_IRUGO,
  		    pod_get_band_4_frequency__bass,
  		    pod_set_band_4_frequency__bass);
! static DEVICE_ATTR(mod_param_1_double_precision, S_IWUGO | S_IRUGO,
  		   pod_get_mod_param_1_double_precision,
  		   pod_set_mod_param_1_double_precision);
! static DEVICE_ATTR(delay_param_1_double_precision, S_IWUGO | S_IRUGO,
  		   pod_get_delay_param_1_double_precision,
  		   pod_set_delay_param_1_double_precision);
! static DEVICE_ATTR(eq_enable, S_IWUGO | S_IRUGO, pod_get_eq_enable,
  		   pod_set_eq_enable);
! static DEVICE_ATTR(tap, S_IWUGO | S_IRUGO, pod_get_tap, pod_set_tap);
! static DEVICE_ATTR(volume_tweak_pedal_assign, S_IWUGO | S_IRUGO,
  		   pod_get_volume_tweak_pedal_assign,
  		   pod_set_volume_tweak_pedal_assign);
! static DEVICE_ATTR(band_5_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_5_frequency, pod_set_band_5_frequency);
! static DEVICE_ATTR(tuner, S_IWUGO | S_IRUGO, pod_get_tuner, pod_set_tuner);
! static DEVICE_ATTR(mic_selection, S_IWUGO | S_IRUGO, pod_get_mic_selection,
  		   pod_set_mic_selection);
! static DEVICE_ATTR(cabinet_model, S_IWUGO | S_IRUGO, pod_get_cabinet_model,
  		   pod_set_cabinet_model);
! static DEVICE_ATTR(stomp_model, S_IWUGO | S_IRUGO, pod_get_stomp_model,
  		   pod_set_stomp_model);
! static DEVICE_ATTR(roomlevel, S_IWUGO | S_IRUGO, pod_get_roomlevel,
  		   pod_set_roomlevel);
! static DEVICE_ATTR(band_4_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_4_frequency, pod_set_band_4_frequency);
! static DEVICE_ATTR(band_6_frequency, S_IWUGO | S_IRUGO,
  		   pod_get_band_6_frequency, pod_set_band_6_frequency);
! static DEVICE_ATTR(stomp_param_1_note_value, S_IWUGO | S_IRUGO,
  		   pod_get_stomp_param_1_note_value,
  		   pod_set_stomp_param_1_note_value);
! static DEVICE_ATTR(stomp_param_2, S_IWUGO | S_IRUGO, pod_get_stomp_param_2,
  		   pod_set_stomp_param_2);
! static DEVICE_ATTR(stomp_param_3, S_IWUGO | S_IRUGO, pod_get_stomp_param_3,
  		   pod_set_stomp_param_3);
! static DEVICE_ATTR(stomp_param_4, S_IWUGO | S_IRUGO, pod_get_stomp_param_4,
  		   pod_set_stomp_param_4);
! static DEVICE_ATTR(stomp_param_5, S_IWUGO | S_IRUGO, pod_get_stomp_param_5,
  		   pod_set_stomp_param_5);
! static DEVICE_ATTR(stomp_param_6, S_IWUGO | S_IRUGO, pod_get_stomp_param_6,
  		   pod_set_stomp_param_6);
! static DEVICE_ATTR(amp_switch_select, S_IWUGO | S_IRUGO,
  		   pod_get_amp_switch_select, pod_set_amp_switch_select);
! static DEVICE_ATTR(delay_param_4, S_IWUGO | S_IRUGO, pod_get_delay_param_4,
  		   pod_set_delay_param_4);
! static DEVICE_ATTR(delay_param_5, S_IWUGO | S_IRUGO, pod_get_delay_param_5,
  		   pod_set_delay_param_5);
! static DEVICE_ATTR(delay_pre_post, S_IWUGO | S_IRUGO, pod_get_delay_pre_post,
  		   pod_set_delay_pre_post);
! static DEVICE_ATTR(delay_model, S_IWUGO | S_IRUGO, pod_get_delay_model,
  		   pod_set_delay_model);
! static DEVICE_ATTR(delay_verb_model, S_IWUGO | S_IRUGO,
  		   pod_get_delay_verb_model, pod_set_delay_verb_model);
! static DEVICE_ATTR(tempo_msb, S_IWUGO | S_IRUGO, pod_get_tempo_msb,
  		   pod_set_tempo_msb);
! static DEVICE_ATTR(tempo_lsb, S_IWUGO | S_IRUGO, pod_get_tempo_lsb,
  		   pod_set_tempo_lsb);
! static DEVICE_ATTR(wah_model, S_IWUGO | S_IRUGO, pod_get_wah_model,
  		   pod_set_wah_model);
! static DEVICE_ATTR(bypass_volume, S_IWUGO | S_IRUGO, pod_get_bypass_volume,
  		   pod_set_bypass_volume);
! static DEVICE_ATTR(fx_loop_on_off, S_IWUGO | S_IRUGO, pod_get_fx_loop_on_off,
  		   pod_set_fx_loop_on_off);
! static DEVICE_ATTR(tweak_param_select, S_IWUGO | S_IRUGO,
  		   pod_get_tweak_param_select, pod_set_tweak_param_select);
! static DEVICE_ATTR(amp1_engage, S_IWUGO | S_IRUGO, pod_get_amp1_engage,
  		   pod_set_amp1_engage);
! static DEVICE_ATTR(band_1_gain, S_IWUGO | S_IRUGO, pod_get_band_1_gain,
  		   pod_set_band_1_gain);
! static DEVICE_ATTR2(band_2_gain__bass, band_2_gain, S_IWUGO | S_IRUGO,
  		    pod_get_band_2_gain__bass, pod_set_band_2_gain__bass);
! static DEVICE_ATTR(band_2_gain, S_IWUGO | S_IRUGO, pod_get_band_2_gain,
  		   pod_set_band_2_gain);
! static DEVICE_ATTR2(band_3_gain__bass, band_3_gain, S_IWUGO | S_IRUGO,
  		    pod_get_band_3_gain__bass, pod_set_band_3_gain__bass);
! static DEVICE_ATTR(band_3_gain, S_IWUGO | S_IRUGO, pod_get_band_3_gain,
  		   pod_set_band_3_gain);
! static DEVICE_ATTR2(band_4_gain__bass, band_4_gain, S_IWUGO | S_IRUGO,
  		    pod_get_band_4_gain__bass, pod_set_band_4_gain__bass);
! static DEVICE_ATTR2(band_5_gain__bass, band_5_gain, S_IWUGO | S_IRUGO,
  		    pod_get_band_5_gain__bass, pod_set_band_5_gain__bass);
! static DEVICE_ATTR(band_4_gain, S_IWUGO | S_IRUGO, pod_get_band_4_gain,
  		   pod_set_band_4_gain);
! static DEVICE_ATTR2(band_6_gain__bass, band_6_gain, S_IWUGO | S_IRUGO,
  		    pod_get_band_6_gain__bass, pod_set_band_6_gain__bass);
  static DEVICE_ATTR(body, S_IRUGO, variax_get_body, line6_nop_write);
  static DEVICE_ATTR(pickup1_enable, S_IRUGO, variax_get_pickup1_enable,
diff -cBr 2.6.35/drivers/staging/line6/midi.c linux-2.6.35.y-512ac85/drivers/staging/line6/midi.c
*** 2.6.35/drivers/staging/line6/midi.c	2011-05-07 19:57:18.446750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/line6/midi.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 362,369 ****
  	return count;
  }
  
! static DEVICE_ATTR(midi_mask_transmit, S_IWUSR | S_IRUGO, midi_get_midi_mask_transmit, midi_set_midi_mask_transmit);
! static DEVICE_ATTR(midi_mask_receive, S_IWUSR | S_IRUGO, midi_get_midi_mask_receive, midi_set_midi_mask_receive);
  
  /* MIDI device destructor */
  static int snd_line6_midi_free(struct snd_device *device)
--- 362,369 ----
  	return count;
  }
  
! static DEVICE_ATTR(midi_mask_transmit, S_IWUGO | S_IRUGO, midi_get_midi_mask_transmit, midi_set_midi_mask_transmit);
! static DEVICE_ATTR(midi_mask_receive, S_IWUGO | S_IRUGO, midi_get_midi_mask_receive, midi_set_midi_mask_receive);
  
  /* MIDI device destructor */
  static int snd_line6_midi_free(struct snd_device *device)
diff -cBr 2.6.35/drivers/staging/line6/pod.c linux-2.6.35.y-512ac85/drivers/staging/line6/pod.c
*** 2.6.35/drivers/staging/line6/pod.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/line6/pod.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 952,984 ****
  #undef GET_SYSTEM_PARAM
  
  /* POD special files: */
! static DEVICE_ATTR(channel, S_IWUSR | S_IRUGO, pod_get_channel, pod_set_channel);
  static DEVICE_ATTR(clip, S_IRUGO, pod_wait_for_clip, line6_nop_write);
  static DEVICE_ATTR(device_id, S_IRUGO, pod_get_device_id, line6_nop_write);
  static DEVICE_ATTR(dirty, S_IRUGO, pod_get_dirty, line6_nop_write);
! static DEVICE_ATTR(dump, S_IWUSR | S_IRUGO, pod_get_dump, pod_set_dump);
! static DEVICE_ATTR(dump_buf, S_IWUSR | S_IRUGO, pod_get_dump_buf, pod_set_dump_buf);
! static DEVICE_ATTR(finish, S_IWUSR, line6_nop_read, pod_set_finish);
  static DEVICE_ATTR(firmware_version, S_IRUGO, pod_get_firmware_version, line6_nop_write);
! static DEVICE_ATTR(midi_postprocess, S_IWUSR | S_IRUGO, pod_get_midi_postprocess, pod_set_midi_postprocess);
! static DEVICE_ATTR(monitor_level, S_IWUSR | S_IRUGO, pod_get_monitor_level, pod_set_monitor_level);
  static DEVICE_ATTR(name, S_IRUGO, pod_get_name, line6_nop_write);
  static DEVICE_ATTR(name_buf, S_IRUGO, pod_get_name_buf, line6_nop_write);
! static DEVICE_ATTR(retrieve_amp_setup, S_IWUSR, line6_nop_read, pod_set_retrieve_amp_setup);
! static DEVICE_ATTR(retrieve_channel, S_IWUSR, line6_nop_read, pod_set_retrieve_channel);
! static DEVICE_ATTR(retrieve_effects_setup, S_IWUSR, line6_nop_read, pod_set_retrieve_effects_setup);
! static DEVICE_ATTR(routing, S_IWUSR | S_IRUGO, pod_get_routing, pod_set_routing);
  static DEVICE_ATTR(serial_number, S_IRUGO, pod_get_serial_number, line6_nop_write);
! static DEVICE_ATTR(store_amp_setup, S_IWUSR, line6_nop_read, pod_set_store_amp_setup);
! static DEVICE_ATTR(store_channel, S_IWUSR, line6_nop_read, pod_set_store_channel);
! static DEVICE_ATTR(store_effects_setup, S_IWUSR, line6_nop_read, pod_set_store_effects_setup);
! static DEVICE_ATTR(tuner_freq, S_IWUSR | S_IRUGO, pod_get_tuner_freq, pod_set_tuner_freq);
! static DEVICE_ATTR(tuner_mute, S_IWUSR | S_IRUGO, pod_get_tuner_mute, pod_set_tuner_mute);
  static DEVICE_ATTR(tuner_note, S_IRUGO, pod_get_tuner_note, line6_nop_write);
  static DEVICE_ATTR(tuner_pitch, S_IRUGO, pod_get_tuner_pitch, line6_nop_write);
  
  #if CREATE_RAW_FILE
! static DEVICE_ATTR(raw, S_IWUSR, line6_nop_read, line6_set_raw);
  #endif
  
  /*
--- 952,984 ----
  #undef GET_SYSTEM_PARAM
  
  /* POD special files: */
! static DEVICE_ATTR(channel, S_IWUGO | S_IRUGO, pod_get_channel, pod_set_channel);
  static DEVICE_ATTR(clip, S_IRUGO, pod_wait_for_clip, line6_nop_write);
  static DEVICE_ATTR(device_id, S_IRUGO, pod_get_device_id, line6_nop_write);
  static DEVICE_ATTR(dirty, S_IRUGO, pod_get_dirty, line6_nop_write);
! static DEVICE_ATTR(dump, S_IWUGO | S_IRUGO, pod_get_dump, pod_set_dump);
! static DEVICE_ATTR(dump_buf, S_IWUGO | S_IRUGO, pod_get_dump_buf, pod_set_dump_buf);
! static DEVICE_ATTR(finish, S_IWUGO, line6_nop_read, pod_set_finish);
  static DEVICE_ATTR(firmware_version, S_IRUGO, pod_get_firmware_version, line6_nop_write);
! static DEVICE_ATTR(midi_postprocess, S_IWUGO | S_IRUGO, pod_get_midi_postprocess, pod_set_midi_postprocess);
! static DEVICE_ATTR(monitor_level, S_IWUGO | S_IRUGO, pod_get_monitor_level, pod_set_monitor_level);
  static DEVICE_ATTR(name, S_IRUGO, pod_get_name, line6_nop_write);
  static DEVICE_ATTR(name_buf, S_IRUGO, pod_get_name_buf, line6_nop_write);
! static DEVICE_ATTR(retrieve_amp_setup, S_IWUGO, line6_nop_read, pod_set_retrieve_amp_setup);
! static DEVICE_ATTR(retrieve_channel, S_IWUGO, line6_nop_read, pod_set_retrieve_channel);
! static DEVICE_ATTR(retrieve_effects_setup, S_IWUGO, line6_nop_read, pod_set_retrieve_effects_setup);
! static DEVICE_ATTR(routing, S_IWUGO | S_IRUGO, pod_get_routing, pod_set_routing);
  static DEVICE_ATTR(serial_number, S_IRUGO, pod_get_serial_number, line6_nop_write);
! static DEVICE_ATTR(store_amp_setup, S_IWUGO, line6_nop_read, pod_set_store_amp_setup);
! static DEVICE_ATTR(store_channel, S_IWUGO, line6_nop_read, pod_set_store_channel);
! static DEVICE_ATTR(store_effects_setup, S_IWUGO, line6_nop_read, pod_set_store_effects_setup);
! static DEVICE_ATTR(tuner_freq, S_IWUGO | S_IRUGO, pod_get_tuner_freq, pod_set_tuner_freq);
! static DEVICE_ATTR(tuner_mute, S_IWUGO | S_IRUGO, pod_get_tuner_mute, pod_set_tuner_mute);
  static DEVICE_ATTR(tuner_note, S_IRUGO, pod_get_tuner_note, line6_nop_write);
  static DEVICE_ATTR(tuner_pitch, S_IRUGO, pod_get_tuner_pitch, line6_nop_write);
  
  #if CREATE_RAW_FILE
! static DEVICE_ATTR(raw, S_IWUGO, line6_nop_read, line6_set_raw);
  #endif
  
  /*
diff -cBr 2.6.35/drivers/staging/line6/toneport.c linux-2.6.35.y-512ac85/drivers/staging/line6/toneport.c
*** 2.6.35/drivers/staging/line6/toneport.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/line6/toneport.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 124,132 ****
  	return count;
  }
  
! static DEVICE_ATTR(led_red, S_IWUSR | S_IRUGO, line6_nop_read,
  		   toneport_set_led_red);
! static DEVICE_ATTR(led_green, S_IWUSR | S_IRUGO, line6_nop_read,
  		   toneport_set_led_green);
  
  static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)
--- 124,132 ----
  	return count;
  }
  
! static DEVICE_ATTR(led_red, S_IWUGO | S_IRUGO, line6_nop_read,
  		   toneport_set_led_red);
! static DEVICE_ATTR(led_green, S_IWUGO | S_IRUGO, line6_nop_read,
  		   toneport_set_led_green);
  
  static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)
diff -cBr 2.6.35/drivers/staging/line6/variax.c linux-2.6.35.y-512ac85/drivers/staging/line6/variax.c
*** 2.6.35/drivers/staging/line6/variax.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/line6/variax.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 389,405 ****
  #endif
  
  /* Variax workbench special files: */
! static DEVICE_ATTR(model, S_IWUSR | S_IRUGO, variax_get_model, variax_set_model);
! static DEVICE_ATTR(volume, S_IWUSR | S_IRUGO, variax_get_volume, variax_set_volume);
! static DEVICE_ATTR(tone, S_IWUSR | S_IRUGO, variax_get_tone, variax_set_tone);
  static DEVICE_ATTR(name, S_IRUGO, variax_get_name, line6_nop_write);
  static DEVICE_ATTR(bank, S_IRUGO, variax_get_bank, line6_nop_write);
  static DEVICE_ATTR(dump, S_IRUGO, variax_get_dump, line6_nop_write);
! static DEVICE_ATTR(active, S_IWUSR | S_IRUGO, variax_get_active, variax_set_active);
  
  #if CREATE_RAW_FILE
! static DEVICE_ATTR(raw, S_IWUSR, line6_nop_read, line6_set_raw);
! static DEVICE_ATTR(raw2, S_IWUSR, line6_nop_read, variax_set_raw2);
  #endif
  
  
--- 389,405 ----
  #endif
  
  /* Variax workbench special files: */
! static DEVICE_ATTR(model, S_IWUGO | S_IRUGO, variax_get_model, variax_set_model);
! static DEVICE_ATTR(volume, S_IWUGO | S_IRUGO, variax_get_volume, variax_set_volume);
! static DEVICE_ATTR(tone, S_IWUGO | S_IRUGO, variax_get_tone, variax_set_tone);
  static DEVICE_ATTR(name, S_IRUGO, variax_get_name, line6_nop_write);
  static DEVICE_ATTR(bank, S_IRUGO, variax_get_bank, line6_nop_write);
  static DEVICE_ATTR(dump, S_IRUGO, variax_get_dump, line6_nop_write);
! static DEVICE_ATTR(active, S_IWUGO | S_IRUGO, variax_get_active, variax_set_active);
  
  #if CREATE_RAW_FILE
! static DEVICE_ATTR(raw, S_IWUGO, line6_nop_read, line6_set_raw);
! static DEVICE_ATTR(raw2, S_IWUGO, line6_nop_read, variax_set_raw2);
  #endif
  
  
diff -cBr 2.6.35/drivers/staging/rt2860/usb_main_dev.c linux-2.6.35.y-512ac85/drivers/staging/rt2860/usb_main_dev.c
*** 2.6.35/drivers/staging/rt2860/usb_main_dev.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/rt2860/usb_main_dev.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 65,71 ****
  	{USB_DEVICE(0x14B2, 0x3C07)},	/* AL */
  	{USB_DEVICE(0x050D, 0x8053)},	/* Belkin */
  	{USB_DEVICE(0x050D, 0x825B)},	/* Belkin */
- 	{USB_DEVICE(0x050D, 0x935A)},	/* Belkin F6D4050 v1 */
  	{USB_DEVICE(0x050D, 0x935B)},	/* Belkin F6D4050 v2 */
  	{USB_DEVICE(0x14B2, 0x3C23)},	/* Airlink */
  	{USB_DEVICE(0x14B2, 0x3C27)},	/* Airlink */
--- 65,70 ----
***************
*** 182,188 ****
  	{USB_DEVICE(0x2001, 0x3C09)},	/* D-Link */
  	{USB_DEVICE(0x2001, 0x3C0A)},	/* D-Link 3072 */
  	{USB_DEVICE(0x2019, 0xED14)},	/* Planex Communications, Inc. */
- 	{USB_DEVICE(0x0411, 0x015D)},	/* Buffalo Airstation WLI-UC-GN */
  	{}			/* Terminating entry */
  };
  
--- 181,186 ----
diff -cBr 2.6.35/drivers/staging/rtl8187se/r8185b_init.c linux-2.6.35.y-512ac85/drivers/staging/rtl8187se/r8185b_init.c
*** 2.6.35/drivers/staging/rtl8187se/r8185b_init.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/rtl8187se/r8185b_init.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 268,279 ****
  			}
  			udelay(10);
  		}
! 		if (TryCnt == TC_3W_POLL_MAX_TRY_CNT) {
! 			printk(KERN_ERR "rtl8187se: HwThreeWire(): CmdReg:"
! 			       " %#X RE|WE bits are not clear!!\n", u1bTmp);
! 			dump_stack();
! 			return 0;
! 		}
  
  		// RTL8187S HSSI Read/Write Function
  		u1bTmp = read_nic_byte(dev, RF_SW_CONFIG);
--- 268,275 ----
  			}
  			udelay(10);
  		}
! 		if (TryCnt == TC_3W_POLL_MAX_TRY_CNT)
! 			panic("HwThreeWire(): CmdReg: %#X RE|WE bits are not clear!!\n", u1bTmp);
  
  		// RTL8187S HSSI Read/Write Function
  		u1bTmp = read_nic_byte(dev, RF_SW_CONFIG);
***************
*** 313,335 ****
  				int idx;
  				int ByteCnt = nDataBufBitCnt / 8;
                                  //printk("%d\n",nDataBufBitCnt);
! 				if ((nDataBufBitCnt % 8) != 0) {
! 					printk(KERN_ERR "rtl8187se: "
! 					       "HwThreeWire(): nDataBufBitCnt(%d)"
! 					       " should be multiple of 8!!!\n",
! 					       nDataBufBitCnt);
! 					dump_stack();
! 					nDataBufBitCnt += 8;
! 					nDataBufBitCnt &= ~7;
! 				}
! 
! 			       if (nDataBufBitCnt > 64) {
! 					printk(KERN_ERR "rtl8187se: HwThreeWire():"
! 					       " nDataBufBitCnt(%d) should <= 64!!!\n",
! 					       nDataBufBitCnt);
! 					dump_stack();
! 					nDataBufBitCnt = 64;
! 				}
  
  				for(idx = 0; idx < ByteCnt; idx++)
  				{
--- 309,321 ----
  				int idx;
  				int ByteCnt = nDataBufBitCnt / 8;
                                  //printk("%d\n",nDataBufBitCnt);
! 				if ((nDataBufBitCnt % 8) != 0)
! 				panic("HwThreeWire(): nDataBufBitCnt(%d) should be multiple of 8!!!\n",
! 				nDataBufBitCnt);
! 
! 			       if (nDataBufBitCnt > 64)
! 				panic("HwThreeWire(): nDataBufBitCnt(%d) should <= 64!!!\n",
! 				nDataBufBitCnt);
  
  				for(idx = 0; idx < ByteCnt; idx++)
  				{
diff -cBr 2.6.35/drivers/staging/samsung-laptop/samsung-laptop.c linux-2.6.35.y-512ac85/drivers/staging/samsung-laptop/samsung-laptop.c
*** 2.6.35/drivers/staging/samsung-laptop/samsung-laptop.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/samsung-laptop/samsung-laptop.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 356,362 ****
  	}
  	return count;
  }
! static DEVICE_ATTR(silent, S_IWUSR | S_IRUGO,
  		   get_silent_state, set_silent_state);
  
  
--- 356,362 ----
  	}
  	return count;
  }
! static DEVICE_ATTR(silent, S_IWUGO | S_IRUGO,
  		   get_silent_state, set_silent_state);
  
  
diff -cBr 2.6.35/drivers/staging/udlfb/udlfb.c linux-2.6.35.y-512ac85/drivers/staging/udlfb/udlfb.c
*** 2.6.35/drivers/staging/udlfb/udlfb.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/udlfb/udlfb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1143,1149 ****
  	__ATTR_RO(metrics_bytes_sent),
  	__ATTR_RO(metrics_cpu_kcycles_used),
  	__ATTR_RO(metrics_misc),
! 	__ATTR(metrics_reset, S_IWUSR, NULL, metrics_reset_store),
  	__ATTR_RW(use_defio),
  };
  
--- 1143,1149 ----
  	__ATTR_RO(metrics_bytes_sent),
  	__ATTR_RO(metrics_cpu_kcycles_used),
  	__ATTR_RO(metrics_misc),
! 	__ATTR(metrics_reset, S_IWUGO, NULL, metrics_reset_store),
  	__ATTR_RW(use_defio),
  };
  
diff -cBr 2.6.35/drivers/staging/usbip/stub_rx.c linux-2.6.35.y-512ac85/drivers/staging/usbip/stub_rx.c
*** 2.6.35/drivers/staging/usbip/stub_rx.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/stub_rx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 170,192 ****
  
  static int tweak_reset_device_cmd(struct urb *urb)
  {
! 	struct stub_priv *priv = (struct stub_priv *) urb->context;
! 	struct stub_device *sdev = priv->sdev;
  
! 	usbip_uinfo("reset_device %s\n", dev_name(&urb->dev->dev));
  
! 	/*
! 	 * usb_lock_device_for_reset caused a deadlock: it causes the driver
! 	 * to unbind. In the shutdown the rx thread is signalled to shut down
! 	 * but this thread is pending in the usb_lock_device_for_reset.
! 	 *
! 	 * Instead queue the reset.
! 	 *
! 	 * Unfortunatly an existing usbip connection will be dropped due to
! 	 * driver unbinding.
! 	 */
! 	usb_queue_reset_device(sdev->interface);
! 	return 0;
  }
  
  /*
--- 170,202 ----
  
  static int tweak_reset_device_cmd(struct urb *urb)
  {
! 	struct usb_ctrlrequest *req;
! 	__u16 value;
! 	__u16 index;
! 	int ret;
  
! 	req = (struct usb_ctrlrequest *) urb->setup_packet;
! 	value = le16_to_cpu(req->wValue);
! 	index = le16_to_cpu(req->wIndex);
  
! 	usbip_uinfo("reset_device (port %d) to %s\n", index,
! 						dev_name(&urb->dev->dev));
! 
! 	/* all interfaces should be owned by usbip driver, so just reset it.  */
! 	ret = usb_lock_device_for_reset(urb->dev, NULL);
! 	if (ret < 0) {
! 		dev_err(&urb->dev->dev, "lock for reset\n");
! 		return ret;
! 	}
! 
! 	/* try to reset the device */
! 	ret = usb_reset_device(urb->dev);
! 	if (ret < 0)
! 		dev_err(&urb->dev->dev, "device reset\n");
! 
! 	usb_unlock_device(urb->dev);
! 
! 	return ret;
  }
  
  /*
diff -cBr 2.6.35/drivers/staging/usbip/stub_tx.c linux-2.6.35.y-512ac85/drivers/staging/usbip/stub_tx.c
*** 2.6.35/drivers/staging/usbip/stub_tx.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/stub_tx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 169,174 ****
--- 169,175 ----
  	struct stub_priv *priv, *tmp;
  
  	struct msghdr msg;
+ 	struct kvec iov[3];
  	size_t txsize;
  
  	size_t total_size = 0;
***************
*** 178,250 ****
  		struct urb *urb = priv->urb;
  		struct usbip_header pdu_header;
  		void *iso_buffer = NULL;
- 		struct kvec *iov = NULL;
- 		int iovnum = 0;
  
  		txsize = 0;
  		memset(&pdu_header, 0, sizeof(pdu_header));
  		memset(&msg, 0, sizeof(msg));
  
! 		if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
! 			iovnum = 2 + urb->number_of_packets;
! 		else
! 			iovnum = 2;
  
- 		iov = kzalloc(iovnum * sizeof(struct kvec), GFP_KERNEL);
- 
- 		if (!iov) {
- 			usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);
- 			return -1;
- 		}
- 
- 		iovnum = 0;
  
  		/* 1. setup usbip_header */
  		setup_ret_submit_pdu(&pdu_header, urb);
- 		usbip_dbg_stub_tx("setup txdata seqnum: %d urb: %p\n",
- 						pdu_header.base.seqnum, urb);
- 		/*usbip_dump_header(pdu_header);*/
  		usbip_header_correct_endian(&pdu_header, 1);
  
! 		iov[iovnum].iov_base = &pdu_header;
! 		iov[iovnum].iov_len  = sizeof(pdu_header);
! 		iovnum++;
  		txsize += sizeof(pdu_header);
  
  		/* 2. setup transfer buffer */
! 		if (usb_pipein(urb->pipe) &&
! 				usb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&
! 					urb->actual_length > 0) {
! 			iov[iovnum].iov_base = urb->transfer_buffer;
! 			iov[iovnum].iov_len  = urb->actual_length;
! 			iovnum++;
  			txsize += urb->actual_length;
- 		} else if (usb_pipein(urb->pipe) &&
- 				usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
- 			/*
- 			 * For isochronous packets: actual length is the sum of
- 			 * the actual length of the individual, packets, but as
- 			 * the packet offsets are not changed there will be
- 			 * padding between the packets. To optimally use the
- 			 * bandwidth the padding is not transmitted.
- 			 */
- 
- 			int i;
- 			for (i = 0; i < urb->number_of_packets; i++) {
- 				iov[iovnum].iov_base = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
- 				iov[iovnum].iov_len = urb->iso_frame_desc[i].actual_length;
- 				iovnum++;
- 				txsize += urb->iso_frame_desc[i].actual_length;
- 			}
- 
- 			if (txsize != sizeof(pdu_header) + urb->actual_length) {
- 				dev_err(&sdev->interface->dev,
- 					"actual length of urb (%d) does not match iso packet sizes (%d)\n",
- 					urb->actual_length, txsize-sizeof(pdu_header));
- 				kfree(iov);
- 				usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);
- 			   return -1;
- 			}
  		}
  
  		/* 3. setup iso_packet_descriptor */
--- 179,206 ----
  		struct urb *urb = priv->urb;
  		struct usbip_header pdu_header;
  		void *iso_buffer = NULL;
  
  		txsize = 0;
  		memset(&pdu_header, 0, sizeof(pdu_header));
  		memset(&msg, 0, sizeof(msg));
+ 		memset(&iov, 0, sizeof(iov));
  
! 		usbip_dbg_stub_tx("setup txdata urb %p\n", urb);
  
  
  		/* 1. setup usbip_header */
  		setup_ret_submit_pdu(&pdu_header, urb);
  		usbip_header_correct_endian(&pdu_header, 1);
  
! 		iov[0].iov_base = &pdu_header;
! 		iov[0].iov_len  = sizeof(pdu_header);
  		txsize += sizeof(pdu_header);
  
  		/* 2. setup transfer buffer */
! 		if (usb_pipein(urb->pipe) && urb->actual_length > 0) {
! 			iov[1].iov_base = urb->transfer_buffer;
! 			iov[1].iov_len  = urb->actual_length;
  			txsize += urb->actual_length;
  		}
  
  		/* 3. setup iso_packet_descriptor */
***************
*** 255,284 ****
  			if (!iso_buffer) {
  				usbip_event_add(&sdev->ud,
  						SDEV_EVENT_ERROR_MALLOC);
- 				kfree(iov);
  				return -1;
  			}
  
! 			iov[iovnum].iov_base = iso_buffer;
! 			iov[iovnum].iov_len  = len;
  			txsize += len;
- 			iovnum++;
  		}
  
! 		ret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,
! 						iov,  iovnum, txsize);
  		if (ret != txsize) {
  			dev_err(&sdev->interface->dev,
  				"sendmsg failed!, retval %d for %zd\n",
  				ret, txsize);
- 			kfree(iov);
  			kfree(iso_buffer);
  			usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);
  			return -1;
  		}
  
- 		kfree(iov);
  		kfree(iso_buffer);
  
  		total_size += txsize;
  	}
--- 211,237 ----
  			if (!iso_buffer) {
  				usbip_event_add(&sdev->ud,
  						SDEV_EVENT_ERROR_MALLOC);
  				return -1;
  			}
  
! 			iov[2].iov_base = iso_buffer;
! 			iov[2].iov_len  = len;
  			txsize += len;
  		}
  
! 		ret = kernel_sendmsg(sdev->ud.tcp_socket, &msg, iov,
! 				     3, txsize);
  		if (ret != txsize) {
  			dev_err(&sdev->interface->dev,
  				"sendmsg failed!, retval %d for %zd\n",
  				ret, txsize);
  			kfree(iso_buffer);
  			usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);
  			return -1;
  		}
  
  		kfree(iso_buffer);
+ 		usbip_dbg_stub_tx("send txdata\n");
  
  		total_size += txsize;
  	}
diff -cBr 2.6.35/drivers/staging/usbip/usbip_common.c linux-2.6.35.y-512ac85/drivers/staging/usbip/usbip_common.c
*** 2.6.35/drivers/staging/usbip/usbip_common.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/usbip_common.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 334,344 ****
  		usbip_udbg("CMD_UNLINK: seq %u\n", pdu->u.cmd_unlink.seqnum);
  		break;
  	case USBIP_RET_SUBMIT:
! 		usbip_udbg("RET_SUBMIT: st %d al %u sf %d #p %d ec %d\n",
  				pdu->u.ret_submit.status,
  				pdu->u.ret_submit.actual_length,
  				pdu->u.ret_submit.start_frame,
- 				pdu->u.ret_submit.number_of_packets,
  				pdu->u.ret_submit.error_count);
  	case USBIP_RET_UNLINK:
  		usbip_udbg("RET_UNLINK: status %d\n", pdu->u.ret_unlink.status);
--- 334,343 ----
  		usbip_udbg("CMD_UNLINK: seq %u\n", pdu->u.cmd_unlink.seqnum);
  		break;
  	case USBIP_RET_SUBMIT:
! 		usbip_udbg("RET_SUBMIT: st %d al %u sf %d ec %d\n",
  				pdu->u.ret_submit.status,
  				pdu->u.ret_submit.actual_length,
  				pdu->u.ret_submit.start_frame,
  				pdu->u.ret_submit.error_count);
  	case USBIP_RET_UNLINK:
  		usbip_udbg("RET_UNLINK: status %d\n", pdu->u.ret_unlink.status);
***************
*** 626,632 ****
  		rpdu->status		= urb->status;
  		rpdu->actual_length	= urb->actual_length;
  		rpdu->start_frame	= urb->start_frame;
- 		rpdu->number_of_packets = urb->number_of_packets;
  		rpdu->error_count	= urb->error_count;
  	} else {
  		/* vhci_rx.c */
--- 625,630 ----
***************
*** 634,640 ****
  		urb->status		= rpdu->status;
  		urb->actual_length	= rpdu->actual_length;
  		urb->start_frame	= rpdu->start_frame;
- 		urb->number_of_packets = rpdu->number_of_packets;
  		urb->error_count	= rpdu->error_count;
  	}
  }
--- 632,637 ----
***************
*** 703,715 ****
  		cpu_to_be32s(&pdu->status);
  		cpu_to_be32s(&pdu->actual_length);
  		cpu_to_be32s(&pdu->start_frame);
- 		cpu_to_be32s(&pdu->number_of_packets);
  		cpu_to_be32s(&pdu->error_count);
  	} else {
  		be32_to_cpus(&pdu->status);
  		be32_to_cpus(&pdu->actual_length);
  		be32_to_cpus(&pdu->start_frame);
- 		cpu_to_be32s(&pdu->number_of_packets);
  		be32_to_cpus(&pdu->error_count);
  	}
  }
--- 700,710 ----
***************
*** 835,841 ****
  	int size = np * sizeof(*iso);
  	int i;
  	int ret;
- 	int total_length = 0;
  
  	if (!usb_pipeisoc(urb->pipe))
  		return 0;
--- 830,835 ----
***************
*** 870,938 ****
  
  		usbip_iso_pakcet_correct_endian(iso, 0);
  		usbip_pack_iso(iso, &urb->iso_frame_desc[i], 0);
- 		total_length += urb->iso_frame_desc[i].actual_length;
  	}
  
  	kfree(buff);
  
- 	if (total_length != urb->actual_length) {
- 		dev_err(&urb->dev->dev,
- 		  "total length of iso packets (%d) not equal to actual length of buffer (%d)\n",
- 		  total_length, urb->actual_length);
- 
- 		if (ud->side == USBIP_STUB)
- 			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
- 		else
- 			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
- 
- 		return -EPIPE;
- 	}
- 
  	return ret;
  }
  EXPORT_SYMBOL_GPL(usbip_recv_iso);
  
- /*
-  * This functions restores the padding which was removed for optimizing
-  * the bandwidth during transfer over tcp/ip
-  *
-  * buffer and iso packets need to be stored and be in propeper endian in urb
-  * before calling this function
-  */
- int usbip_pad_iso(struct usbip_device *ud, struct urb *urb)
- {
- 	int np = urb->number_of_packets;
- 	int i;
- 	int ret;
- 	int actualoffset = urb->actual_length;
- 
- 	if (!usb_pipeisoc(urb->pipe))
- 		return 0;
- 
- 	/* if no packets or length of data is 0, then nothing to unpack */
- 	if (np == 0 || urb->actual_length == 0)
- 		return 0;
- 
- 	/*
- 	 * if actual_length is transfer_buffer_length then no padding is
- 	 * present.
- 	*/
- 	if (urb->actual_length == urb->transfer_buffer_length)
- 		return 0;
- 
- 	/*
- 	 * loop over all packets from last to first (to prevent overwritting
- 	 * memory when padding) and move them into the proper place
- 	 */
- 	for (i = np-1; i > 0; i--) {
- 		actualoffset -= urb->iso_frame_desc[i].actual_length;
- 		memmove(urb->transfer_buffer + urb->iso_frame_desc[i].offset,
- 				  urb->transfer_buffer + actualoffset,
- 				  urb->iso_frame_desc[i].actual_length);
- 	}
- 	return ret;
- }
- EXPORT_SYMBOL_GPL(usbip_pad_iso);
  
  /* some members of urb must be substituted before. */
  int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
--- 864,877 ----
diff -cBr 2.6.35/drivers/staging/usbip/usbip_common.h linux-2.6.35.y-512ac85/drivers/staging/usbip/usbip_common.h
*** 2.6.35/drivers/staging/usbip/usbip_common.h	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/usbip_common.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 393,400 ****
  int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb);
  /* some members of urb must be substituted before. */
  int usbip_recv_iso(struct usbip_device *ud, struct urb *urb);
- /* some members of urb must be substituted before. */
- int usbip_pad_iso(struct usbip_device *ud, struct urb *urb);
  void *usbip_alloc_iso_desc_pdu(struct urb *urb, ssize_t *bufflen);
  
  
--- 393,398 ----
diff -cBr 2.6.35/drivers/staging/usbip/vhci.h linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci.h
*** 2.6.35/drivers/staging/usbip/vhci.h	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 100,105 ****
--- 100,108 ----
  	 * But, the index of this array begins from 0.
  	 */
  	struct vhci_device vdev[VHCI_NPORTS];
+ 
+ 	/* vhci_device which has not been assiged its address yet */
+ 	int pending_port;
  };
  
  
***************
*** 116,124 ****
  void vhci_rx_loop(struct usbip_task *ut);
  void vhci_tx_loop(struct usbip_task *ut);
  
- struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev,
- 					    __u32 seqnum);
- 
  #define hardware		(&the_controller->pdev.dev)
  
  static inline struct vhci_device *port_to_vdev(__u32 port)
--- 119,124 ----
diff -cBr 2.6.35/drivers/staging/usbip/vhci_hcd.c linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci_hcd.c
*** 2.6.35/drivers/staging/usbip/vhci_hcd.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci_hcd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 138,143 ****
--- 138,145 ----
  	 * the_controller->vdev[rhport].ud.status = VDEV_CONNECT;
  	 * spin_unlock(&the_controller->vdev[rhport].ud.lock); */
  
+ 	the_controller->pending_port = rhport;
+ 
  	spin_unlock_irqrestore(&the_controller->lock, flags);
  
  	usb_hcd_poll_rh_status(vhci_to_hcd(the_controller));
***************
*** 557,563 ****
  	struct device *dev = &urb->dev->dev;
  	int ret = 0;
  	unsigned long flags;
- 	struct vhci_device *vdev;
  
  	usbip_dbg_vhci_hc("enter, usb_hcd %p urb %p mem_flags %d\n",
  		    hcd, urb, mem_flags);
--- 559,564 ----
***************
*** 573,590 ****
  		return urb->status;
  	}
  
- 	vdev = port_to_vdev(urb->dev->portnum-1);
- 
- 	/* refuse enqueue for dead connection */
- 	spin_lock(&vdev->ud.lock);
- 	if (vdev->ud.status == VDEV_ST_NULL || vdev->ud.status == VDEV_ST_ERROR) {
- 		usbip_uerr("enqueue for inactive port %d\n", vdev->rhport);
- 		spin_unlock(&vdev->ud.lock);
- 		spin_unlock_irqrestore(&the_controller->lock, flags);
- 		return -ENODEV;
- 	}
- 	spin_unlock(&vdev->ud.lock);
- 
  	ret = usb_hcd_link_urb_to_ep(hcd, urb);
  	if (ret)
  		goto no_need_unlink;
--- 574,579 ----
***************
*** 603,608 ****
--- 592,599 ----
  		__u8 type = usb_pipetype(urb->pipe);
  		struct usb_ctrlrequest *ctrlreq =
  				(struct usb_ctrlrequest *) urb->setup_packet;
+ 		struct vhci_device *vdev =
+ 				port_to_vdev(the_controller->pending_port);
  
  		if (type != PIPE_CONTROL || !ctrlreq) {
  			dev_err(dev, "invalid request to devnum 0\n");
***************
*** 616,624 ****
  			dev_info(dev, "SetAddress Request (%d) to port %d\n",
  				 ctrlreq->wValue, vdev->rhport);
  
! 			if (vdev->udev)
! 				usb_put_dev(vdev->udev);
! 			vdev->udev = usb_get_dev(urb->dev);
  
  			spin_lock(&vdev->ud.lock);
  			vdev->ud.status = VDEV_ST_USED;
--- 607,613 ----
  			dev_info(dev, "SetAddress Request (%d) to port %d\n",
  				 ctrlreq->wValue, vdev->rhport);
  
! 			vdev->udev = urb->dev;
  
  			spin_lock(&vdev->ud.lock);
  			vdev->ud.status = VDEV_ST_USED;
***************
*** 638,646 ****
  						"Get_Descriptor to device 0 "
  						"(get max pipe size)\n");
  
! 			if (vdev->udev)
! 				usb_put_dev(vdev->udev);
! 			vdev->udev = usb_get_dev(urb->dev);
  			goto out;
  
  		default:
--- 627,634 ----
  						"Get_Descriptor to device 0 "
  						"(get max pipe size)\n");
  
! 			/* FIXME: reference count? (usb_get_dev()) */
! 			vdev->udev = urb->dev;
  			goto out;
  
  		default:
***************
*** 811,816 ****
--- 799,818 ----
  		spin_unlock_irqrestore(&vdev->priv_lock, flags2);
  	}
  
+ 
+ 	if (!vdev->ud.tcp_socket) {
+ 		/* tcp connection is closed */
+ 		usbip_uinfo("vhci_hcd: vhci_urb_dequeue() gives back urb %p\n",
+ 									urb);
+ 
+ 		usb_hcd_unlink_urb_from_ep(hcd, urb);
+ 
+ 		spin_unlock_irqrestore(&the_controller->lock, flags);
+ 		usb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb,
+ 								urb->status);
+ 		spin_lock_irqsave(&the_controller->lock, flags);
+ 	}
+ 
  	spin_unlock_irqrestore(&the_controller->lock, flags);
  
  	usbip_dbg_vhci_hc("leave\n");
***************
*** 825,858 ****
  	spin_lock(&vdev->priv_lock);
  
  	list_for_each_entry_safe(unlink, tmp, &vdev->unlink_tx, list) {
- 		usbip_uinfo("unlink cleanup tx %lu\n", unlink->unlink_seqnum);
  		list_del(&unlink->list);
  		kfree(unlink);
  	}
  
  	list_for_each_entry_safe(unlink, tmp, &vdev->unlink_rx, list) {
- 		struct urb *urb;
- 
- 		/* give back URB of unanswered unlink request */
- 		usbip_uinfo("unlink cleanup rx %lu\n", unlink->unlink_seqnum);
- 
- 		urb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);
- 		if (!urb) {
- 			usbip_uinfo("the urb (seqnum %lu) was already given back\n",
- 							unlink->unlink_seqnum);
- 			list_del(&unlink->list);
- 			kfree(unlink);
- 			continue;
- 		}
- 
- 		urb->status = -ENODEV;
- 
- 		spin_lock(&the_controller->lock);
- 		usb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);
- 		spin_unlock(&the_controller->lock);
- 
- 		usb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb, urb->status);
- 
  		list_del(&unlink->list);
  		kfree(unlink);
  	}
--- 827,837 ----
***************
*** 922,931 ****
  	vdev->speed  = 0;
  	vdev->devid  = 0;
  
- 	if (vdev->udev)
- 		usb_put_dev(vdev->udev);
- 	vdev->udev = NULL;
- 
  	ud->tcp_socket = NULL;
  
  	ud->status = VDEV_ST_NULL;
--- 901,906 ----
diff -cBr 2.6.35/drivers/staging/usbip/vhci_rx.c linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci_rx.c
*** 2.6.35/drivers/staging/usbip/vhci_rx.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/staging/usbip/vhci_rx.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 23,36 ****
  #include "vhci.h"
  
  
! /* get URB from transmitted urb queue. caller must hold vdev->priv_lock */
! struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev,
  					    __u32 seqnum)
  {
  	struct vhci_priv *priv, *tmp;
  	struct urb *urb = NULL;
  	int status;
  
  	list_for_each_entry_safe(priv, tmp, &vdev->priv_rx, list) {
  		if (priv->seqnum == seqnum) {
  			urb = priv->urb;
--- 23,38 ----
  #include "vhci.h"
  
  
! /* get URB from transmitted urb queue */
! static struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev,
  					    __u32 seqnum)
  {
  	struct vhci_priv *priv, *tmp;
  	struct urb *urb = NULL;
  	int status;
  
+ 	spin_lock(&vdev->priv_lock);
+ 
  	list_for_each_entry_safe(priv, tmp, &vdev->priv_rx, list) {
  		if (priv->seqnum == seqnum) {
  			urb = priv->urb;
***************
*** 61,66 ****
--- 63,70 ----
  		}
  	}
  
+ 	spin_unlock(&vdev->priv_lock);
+ 
  	return urb;
  }
  
***************
*** 70,80 ****
  	struct usbip_device *ud = &vdev->ud;
  	struct urb *urb;
  
- 	spin_lock(&vdev->priv_lock);
  
  	urb = pickup_urb_and_free_priv(vdev, pdu->base.seqnum);
  
- 	spin_unlock(&vdev->priv_lock);
  
  	if (!urb) {
  		usbip_uerr("cannot find a urb of seqnum %u\n",
--- 74,82 ----
***************
*** 99,107 ****
  	if (usbip_recv_iso(ud, urb) < 0)
  		return;
  
- 	/* restore the padding in iso packets */
- 	if (usbip_pad_iso(ud, urb) < 0)
- 		return;
  
  	if (usbip_dbg_flag_vhci_rx)
  		usbip_dump_urb(urb);
--- 101,106 ----
***************
*** 162,173 ****
  		return;
  	}
  
- 	spin_lock(&vdev->priv_lock);
- 
  	urb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);
- 
- 	spin_unlock(&vdev->priv_lock);
- 
  	if (!urb) {
  		/*
  		 * I get the result of a unlink request. But, it seems that I
--- 161,167 ----
Only in 2.6.35/drivers: switch
diff -cBr 2.6.35/drivers/usb/atm/ueagle-atm.c linux-2.6.35.y-512ac85/drivers/usb/atm/ueagle-atm.c
*** 2.6.35/drivers/usb/atm/ueagle-atm.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/atm/ueagle-atm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2291,2297 ****
  	return ret;
  }
  
! static DEVICE_ATTR(stat_status, S_IWUSR | S_IRUGO, read_status, reboot);
  
  static ssize_t read_human_status(struct device *dev,
  			struct device_attribute *attr, char *buf)
--- 2291,2297 ----
  	return ret;
  }
  
! static DEVICE_ATTR(stat_status, S_IWUGO | S_IRUGO, read_status, reboot);
  
  static ssize_t read_human_status(struct device *dev,
  			struct device_attribute *attr, char *buf)
***************
*** 2354,2360 ****
  	return ret;
  }
  
! static DEVICE_ATTR(stat_human_status, S_IRUGO, read_human_status, NULL);
  
  static ssize_t read_delin(struct device *dev, struct device_attribute *attr,
  		char *buf)
--- 2354,2361 ----
  	return ret;
  }
  
! static DEVICE_ATTR(stat_human_status, S_IWUGO | S_IRUGO,
! 				read_human_status, NULL);
  
  static ssize_t read_delin(struct device *dev, struct device_attribute *attr,
  		char *buf)
***************
*** 2386,2392 ****
  	return ret;
  }
  
! static DEVICE_ATTR(stat_delin, S_IRUGO, read_delin, NULL);
  
  #define UEA_ATTR(name, reset)					\
  								\
--- 2387,2393 ----
  	return ret;
  }
  
! static DEVICE_ATTR(stat_delin, S_IWUGO | S_IRUGO, read_delin, NULL);
  
  #define UEA_ATTR(name, reset)					\
  								\
diff -cBr 2.6.35/drivers/usb/class/cdc-acm.c linux-2.6.35.y-512ac85/drivers/usb/class/cdc-acm.c
*** 2.6.35/drivers/usb/class/cdc-acm.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/class/cdc-acm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 297,304 ****
  	if (!ACM_READY(acm))
  		goto exit;
  
- 	usb_mark_last_busy(acm->dev);
- 
  	data = (unsigned char *)(dr + 1);
  	switch (dr->bNotificationType) {
  	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
--- 297,302 ----
***************
*** 338,343 ****
--- 336,342 ----
  		break;
  	}
  exit:
+ 	usb_mark_last_busy(acm->dev);
  	retval = usb_submit_urb(urb, GFP_ATOMIC);
  	if (retval)
  		dev_err(&urb->dev->dev, "%s - usb_submit_urb failed with "
***************
*** 534,541 ****
  	if (!ACM_READY(acm))
  		return;
  	tty = tty_port_tty_get(&acm->port);
- 	if (!tty)
- 		return;
  	tty_wakeup(tty);
  	tty_kref_put(tty);
  }
--- 533,538 ----
***************
*** 655,664 ****
  		usb_kill_urb(acm->ctrlurb);
  		for (i = 0; i < ACM_NW; i++)
  			usb_kill_urb(acm->wb[i].urb);
- 		tasklet_disable(&acm->urb_task);
  		for (i = 0; i < nr; i++)
  			usb_kill_urb(acm->ru[i].urb);
- 		tasklet_enable(&acm->urb_task);
  		acm->control->needs_remote_wakeup = 0;
  		usb_autopm_put_interface(acm->control);
  	}
--- 652,659 ----
***************
*** 1618,1624 ****
  	{ NOKIA_PCSUITE_ACM_INFO(0x0154), }, /* Nokia 5800 XpressMusic */
  	{ NOKIA_PCSUITE_ACM_INFO(0x04ce), }, /* Nokia E90 */
  	{ NOKIA_PCSUITE_ACM_INFO(0x01d4), }, /* Nokia E55 */
- 	{ NOKIA_PCSUITE_ACM_INFO(0x0302), }, /* Nokia N8 */
  	{ SAMSUNG_PCSUITE_ACM_INFO(0x6651), }, /* Samsung GTi8510 (INNOV8) */
  
  	/* NOTE: non-Nokia COMM/ACM/0xff is likely MSFT RNDIS... NOT a modem! */
--- 1613,1618 ----
diff -cBr 2.6.35/drivers/usb/core/devices.c linux-2.6.35.y-512ac85/drivers/usb/core/devices.c
*** 2.6.35/drivers/usb/core/devices.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/core/devices.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 222,228 ****
  		break;
  	case USB_ENDPOINT_XFER_INT:
  		type = "Int.";
! 		if (speed == USB_SPEED_HIGH || speed == USB_SPEED_SUPER)
  			interval = 1 << (desc->bInterval - 1);
  		else
  			interval = desc->bInterval;
--- 222,228 ----
  		break;
  	case USB_ENDPOINT_XFER_INT:
  		type = "Int.";
! 		if (speed == USB_SPEED_HIGH)
  			interval = 1 << (desc->bInterval - 1);
  		else
  			interval = desc->bInterval;
***************
*** 230,237 ****
  	default:	/* "can't happen" */
  		return start;
  	}
! 	interval *= (speed == USB_SPEED_HIGH ||
! 		     speed == USB_SPEED_SUPER) ? 125 : 1000;
  	if (interval % 1000)
  		unit = 'u';
  	else {
--- 230,236 ----
  	default:	/* "can't happen" */
  		return start;
  	}
! 	interval *= (speed == USB_SPEED_HIGH) ? 125 : 1000;
  	if (interval % 1000)
  		unit = 'u';
  	else {
***************
*** 541,549 ****
  	if (level == 0) {
  		int	max;
  
! 		/* super/high speed reserves 80%, full/low reserves 90% */
! 		if (usbdev->speed == USB_SPEED_HIGH ||
! 		    usbdev->speed == USB_SPEED_SUPER)
  			max = 800;
  		else
  			max = FRAME_TIME_MAX_USECS_ALLOC;
--- 540,547 ----
  	if (level == 0) {
  		int	max;
  
! 		/* high speed reserves 80%, full/low reserves 90% */
! 		if (usbdev->speed == USB_SPEED_HIGH)
  			max = 800;
  		else
  			max = FRAME_TIME_MAX_USECS_ALLOC;
diff -cBr 2.6.35/drivers/usb/core/devio.c linux-2.6.35.y-512ac85/drivers/usb/core/devio.c
*** 2.6.35/drivers/usb/core/devio.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/core/devio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 965,975 ****
  
  static int proc_connectinfo(struct dev_state *ps, void __user *arg)
  {
! 	struct usbdevfs_connectinfo ci = {
! 		.devnum = ps->dev->devnum,
! 		.slow = ps->dev->speed == USB_SPEED_LOW
! 	};
  
  	if (copy_to_user(arg, &ci, sizeof(ci)))
  		return -EFAULT;
  	return 0;
--- 965,974 ----
  
  static int proc_connectinfo(struct dev_state *ps, void __user *arg)
  {
! 	struct usbdevfs_connectinfo ci;
  
+ 	ci.devnum = ps->dev->devnum;
+ 	ci.slow = ps->dev->speed == USB_SPEED_LOW;
  	if (copy_to_user(arg, &ci, sizeof(ci)))
  		return -EFAULT;
  	return 0;
diff -cBr 2.6.35/drivers/usb/core/hcd.c linux-2.6.35.y-512ac85/drivers/usb/core/hcd.c
*** 2.6.35/drivers/usb/core/hcd.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/core/hcd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1874,1880 ****
  
  	/* Streams only apply to bulk endpoints. */
  	for (i = 0; i < num_eps; i++)
! 		if (!eps[i] || !usb_endpoint_xfer_bulk(&eps[i]->desc))
  			return;
  
  	hcd->driver->free_streams(hcd, dev, eps, num_eps, mem_flags);
--- 1874,1880 ----
  
  	/* Streams only apply to bulk endpoints. */
  	for (i = 0; i < num_eps; i++)
! 		if (!usb_endpoint_xfer_bulk(&eps[i]->desc))
  			return;
  
  	hcd->driver->free_streams(hcd, dev, eps, num_eps, mem_flags);
diff -cBr 2.6.35/drivers/usb/core/hub.c linux-2.6.35.y-512ac85/drivers/usb/core/hub.c
*** 2.6.35/drivers/usb/core/hub.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/core/hub.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 677,684 ****
  static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
  {
  	struct usb_device *hdev = hub->hdev;
- 	struct usb_hcd *hcd;
- 	int ret;
  	int port1;
  	int status;
  	bool need_debounce_delay = false;
--- 677,682 ----
***************
*** 717,741 ****
  			usb_autopm_get_interface_no_resume(
  					to_usb_interface(hub->intfdev));
  			return;		/* Continues at init2: below */
- 		} else if (type == HUB_RESET_RESUME) {
- 			/* The internal host controller state for the hub device
- 			 * may be gone after a host power loss on system resume.
- 			 * Update the device's info so the HW knows it's a hub.
- 			 */
- 			hcd = bus_to_hcd(hdev->bus);
- 			if (hcd->driver->update_hub_device) {
- 				ret = hcd->driver->update_hub_device(hcd, hdev,
- 						&hub->tt, GFP_NOIO);
- 				if (ret < 0) {
- 					dev_err(hub->intfdev, "Host not "
- 							"accepting hub info "
- 							"update.\n");
- 					dev_err(hub->intfdev, "LS/FS devices "
- 							"and hubs may not work "
- 							"under this hub\n.");
- 				}
- 			}
- 			hub_power_on(hub, true);
  		} else {
  			hub_power_on(hub, true);
  		}
--- 715,720 ----
***************
*** 2742,2752 ****
  		udev->ttport = hdev->ttport;
  	} else if (udev->speed != USB_SPEED_HIGH
  			&& hdev->speed == USB_SPEED_HIGH) {
- 		if (!hub->tt.hub) {
- 			dev_err(&udev->dev, "parent hub has no TT\n");
- 			retval = -EINVAL;
- 			goto fail;
- 		}
  		udev->tt = &hub->tt;
  		udev->ttport = port1;
  	}
--- 2721,2726 ----
diff -cBr 2.6.35/drivers/usb/core/quirks.c linux-2.6.35.y-512ac85/drivers/usb/core/quirks.c
*** 2.6.35/drivers/usb/core/quirks.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/core/quirks.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 72,81 ****
  	/* M-Systems Flash Disk Pioneers */
  	{ USB_DEVICE(0x08ec, 0x1000), .driver_info = USB_QUIRK_RESET_RESUME },
  
- 	/* Keytouch QWERTY Panel keyboard */
- 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
- 			USB_QUIRK_CONFIG_INTF_STRINGS },
- 
  	/* X-Rite/Gretag-Macbeth Eye-One Pro display colorimeter */
  	{ USB_DEVICE(0x0971, 0x2000), .driver_info = USB_QUIRK_NO_SET_INTF },
  
--- 68,73 ----
Only in 2.6.35/drivers/usb/gadget: android.c
diff -cBr 2.6.35/drivers/usb/gadget/atmel_usba_udc.c linux-2.6.35.y-512ac85/drivers/usb/gadget/atmel_usba_udc.c
*** 2.6.35/drivers/usb/gadget/atmel_usba_udc.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/gadget/atmel_usba_udc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2016,2022 ****
  			}
  		} else {
  			/* gpio_request fail so use -EINVAL for gpio_is_valid */
! 			udc->vbus_pin = -EINVAL;
  		}
  	}
  
--- 2016,2022 ----
  			}
  		} else {
  			/* gpio_request fail so use -EINVAL for gpio_is_valid */
! 			ubc->vbus_pin = -EINVAL;
  		}
  	}
  
diff -cBr 2.6.35/drivers/usb/gadget/composite.c linux-2.6.35.y-512ac85/drivers/usb/gadget/composite.c
*** 2.6.35/drivers/usb/gadget/composite.c	2011-05-07 19:57:18.456750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/gadget/composite.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1018,1023 ****
--- 1018,1031 ----
  	 */
  	usb_ep_autoconfig_reset(cdev->gadget);
  
+ 	/* standardized runtime overrides for device ID data */
+ 	if (idVendor)
+ 		cdev->desc.idVendor = cpu_to_le16(idVendor);
+ 	if (idProduct)
+ 		cdev->desc.idProduct = cpu_to_le16(idProduct);
+ 	if (bcdDevice)
+ 		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+ 
  	/* composite gadget needs to assign strings for whole device (like
  	 * serial number), register function drivers, potentially update
  	 * power state and consumption, etc
***************
*** 1029,1042 ****
  	cdev->desc = *composite->dev;
  	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
  
- 	/* standardized runtime overrides for device ID data */
- 	if (idVendor)
- 		cdev->desc.idVendor = cpu_to_le16(idVendor);
- 	if (idProduct)
- 		cdev->desc.idProduct = cpu_to_le16(idProduct);
- 	if (bcdDevice)
- 		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
- 
  	/* strings can't be assigned before bind() allocates the
  	 * releavnt identifiers
  	 */
--- 1037,1042 ----
Only in 2.6.35/drivers/usb/gadget: f_accessory.c
Only in 2.6.35/drivers/usb/gadget: f_adb.c
Only in 2.6.35/drivers/usb/gadget: f_mtp.c
diff -cBr 2.6.35/drivers/usb/gadget/printer.c linux-2.6.35.y-512ac85/drivers/usb/gadget/printer.c
*** 2.6.35/drivers/usb/gadget/printer.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/gadget/printer.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 130,160 ****
   * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
   */
  
! static ushort idVendor;
  module_param(idVendor, ushort, S_IRUGO);
  MODULE_PARM_DESC(idVendor, "USB Vendor ID");
  
! static ushort idProduct;
  module_param(idProduct, ushort, S_IRUGO);
  MODULE_PARM_DESC(idProduct, "USB Product ID");
  
! static ushort bcdDevice;
  module_param(bcdDevice, ushort, S_IRUGO);
  MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
  
! static char *iManufacturer;
  module_param(iManufacturer, charp, S_IRUGO);
  MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
  
! static char *iProduct;
  module_param(iProduct, charp, S_IRUGO);
  MODULE_PARM_DESC(iProduct, "USB Product string");
  
! static char *iSerialNum;
  module_param(iSerialNum, charp, S_IRUGO);
  MODULE_PARM_DESC(iSerialNum, "1");
  
! static char *iPNPstring;
  module_param(iPNPstring, charp, S_IRUGO);
  MODULE_PARM_DESC(iPNPstring, "MFG:linux;MDL:g_printer;CLS:PRINTER;SN:1;");
  
--- 130,160 ----
   * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
   */
  
! static ushort __initdata idVendor;
  module_param(idVendor, ushort, S_IRUGO);
  MODULE_PARM_DESC(idVendor, "USB Vendor ID");
  
! static ushort __initdata idProduct;
  module_param(idProduct, ushort, S_IRUGO);
  MODULE_PARM_DESC(idProduct, "USB Product ID");
  
! static ushort __initdata bcdDevice;
  module_param(bcdDevice, ushort, S_IRUGO);
  MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
  
! static char *__initdata iManufacturer;
  module_param(iManufacturer, charp, S_IRUGO);
  MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
  
! static char *__initdata iProduct;
  module_param(iProduct, charp, S_IRUGO);
  MODULE_PARM_DESC(iProduct, "USB Product string");
  
! static char *__initdata iSerialNum;
  module_param(iSerialNum, charp, S_IRUGO);
  MODULE_PARM_DESC(iSerialNum, "1");
  
! static char *__initdata iPNPstring;
  module_param(iPNPstring, charp, S_IRUGO);
  MODULE_PARM_DESC(iPNPstring, "MFG:linux;MDL:g_printer;CLS:PRINTER;SN:1;");
  
Only in 2.6.35/drivers/usb/gadget: s3c_udc.h
Only in 2.6.35/drivers/usb/gadget: s3c_udc_otg.c
Only in 2.6.35/drivers/usb/gadget: s3c_udc_otg_xfer_dma.c
diff -cBr 2.6.35/drivers/usb/host/ehci.h linux-2.6.35.y-512ac85/drivers/usb/host/ehci.h
*** 2.6.35/drivers/usb/host/ehci.h	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/ehci.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 131,137 ****
  	unsigned		need_io_watchdog:1;
  	unsigned		broken_periodic:1;
  	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
- 	unsigned		amd_l1_fix:1;
  
  	/* required for usb32 quirk */
  	#define OHCI_CTRL_HCFS          (3 << 6)
--- 131,136 ----
diff -cBr 2.6.35/drivers/usb/host/ehci-hcd.c linux-2.6.35.y-512ac85/drivers/usb/host/ehci-hcd.c
*** 2.6.35/drivers/usb/host/ehci-hcd.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/ehci-hcd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 102,110 ****
  
  #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
  
- /* for ASPM quirk of ISOC on AMD SB800 */
- static struct pci_dev *amd_nb_dev;
- 
  /*-------------------------------------------------------------------------*/
  
  #include "ehci.h"
--- 102,107 ----
***************
*** 504,514 ****
  	spin_unlock_irq (&ehci->lock);
  	ehci_mem_cleanup (ehci);
  
- 	if (amd_nb_dev) {
- 		pci_dev_put(amd_nb_dev);
- 		amd_nb_dev = NULL;
- 	}
- 
  #ifdef	EHCI_STATS
  	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
  		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
--- 501,506 ----
***************
*** 544,551 ****
  	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
  	ehci->iaa_watchdog.data = (unsigned long) ehci;
  
- 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
- 
  	/*
  	 * hw default: 1K periodic list heads, one per frame.
  	 * periodic_size can shrink by USBCMD update if hcc_params allows.
--- 536,541 ----
***************
*** 553,572 ****
  	ehci->periodic_size = DEFAULT_I_TDPS;
  	INIT_LIST_HEAD(&ehci->cached_itd_list);
  	INIT_LIST_HEAD(&ehci->cached_sitd_list);
- 
- 	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
- 		/* periodic schedule size can be smaller than default */
- 		switch (EHCI_TUNE_FLS) {
- 		case 0: ehci->periodic_size = 1024; break;
- 		case 1: ehci->periodic_size = 512; break;
- 		case 2: ehci->periodic_size = 256; break;
- 		default:	BUG();
- 		}
- 	}
  	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
  		return retval;
  
  	/* controllers may cache some of the periodic schedule ... */
  	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
  		ehci->i_thresh = 2 + 8;
  	else					// N microframes cached
--- 543,553 ----
  	ehci->periodic_size = DEFAULT_I_TDPS;
  	INIT_LIST_HEAD(&ehci->cached_itd_list);
  	INIT_LIST_HEAD(&ehci->cached_sitd_list);
  	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
  		return retval;
  
  	/* controllers may cache some of the periodic schedule ... */
+ 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
  	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
  		ehci->i_thresh = 2 + 8;
  	else					// N microframes cached
***************
*** 615,620 ****
--- 596,607 ----
  		/* periodic schedule size can be smaller than default */
  		temp &= ~(3 << 2);
  		temp |= (EHCI_TUNE_FLS << 2);
+ 		switch (EHCI_TUNE_FLS) {
+ 		case 0: ehci->periodic_size = 1024; break;
+ 		case 1: ehci->periodic_size = 512; break;
+ 		case 2: ehci->periodic_size = 256; break;
+ 		default:	BUG();
+ 		}
  	}
  	ehci->command = temp;
  
***************
*** 1022,1032 ****
  				tmp && tmp != qh;
  				tmp = tmp->qh_next.qh)
  			continue;
! 		/* periodic qh self-unlinks on empty, and a COMPLETING qh
! 		 * may already be unlinked.
! 		 */
! 		if (tmp)
! 			unlink_async(ehci, qh);
  		/* FALL THROUGH */
  	case QH_STATE_UNLINK:		/* wait for hw to finish? */
  	case QH_STATE_UNLINK_WAIT:
--- 1009,1018 ----
  				tmp && tmp != qh;
  				tmp = tmp->qh_next.qh)
  			continue;
! 		/* periodic qh self-unlinks on empty */
! 		if (!tmp)
! 			goto nogood;
! 		unlink_async (ehci, qh);
  		/* FALL THROUGH */
  	case QH_STATE_UNLINK:		/* wait for hw to finish? */
  	case QH_STATE_UNLINK_WAIT:
***************
*** 1043,1048 ****
--- 1029,1035 ----
  		}
  		/* else FALL THROUGH */
  	default:
+ nogood:
  		/* caller was supposed to have unlinked any requests;
  		 * that's not our job.  just leak this memory.
  		 */
diff -cBr 2.6.35/drivers/usb/host/ehci-pci.c linux-2.6.35.y-512ac85/drivers/usb/host/ehci-pci.c
*** 2.6.35/drivers/usb/host/ehci-pci.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/ehci-pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 41,82 ****
  	return 0;
  }
  
- static int ehci_quirk_amd_hudson(struct ehci_hcd *ehci)
- {
- 	struct pci_dev *amd_smbus_dev;
- 	u8 rev = 0;
- 
- 	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI, 0x4385, NULL);
- 	if (amd_smbus_dev) {
- 		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
- 		if (rev < 0x40) {
- 			pci_dev_put(amd_smbus_dev);
- 			amd_smbus_dev = NULL;
- 			return 0;
- 		}
- 	} else {
- 		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x780b, NULL);
- 		if (!amd_smbus_dev)
- 			return 0;
- 		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
- 		if (rev < 0x11 || rev > 0x18) {
- 			pci_dev_put(amd_smbus_dev);
- 			amd_smbus_dev = NULL;
- 			return 0;
- 		}
- 	}
- 
- 	if (!amd_nb_dev)
- 		amd_nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);
- 
- 	ehci_info(ehci, "QUIRK: Enable exception for AMD Hudson ASPM\n");
- 
- 	pci_dev_put(amd_smbus_dev);
- 	amd_smbus_dev = NULL;
- 
- 	return 1;
- }
- 
  /* called during probe() after chip reset completes */
  static int ehci_pci_setup(struct usb_hcd *hcd)
  {
--- 41,46 ----
***************
*** 135,143 ****
  	/* cache this readonly data; minimize chip reads */
  	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
  
- 	if (ehci_quirk_amd_hudson(ehci))
- 		ehci->amd_l1_fix = 1;
- 
  	retval = ehci_halt(ehci);
  	if (retval)
  		return retval;
--- 99,104 ----
diff -cBr 2.6.35/drivers/usb/host/ehci-q.c linux-2.6.35.y-512ac85/drivers/usb/host/ehci-q.c
*** 2.6.35/drivers/usb/host/ehci-q.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/ehci-q.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 315,320 ****
--- 315,321 ----
  	int			stopped;
  	unsigned		count = 0;
  	u8			state;
+ 	const __le32		halt = HALT_BIT(ehci);
  	struct ehci_qh_hw	*hw = qh->hw;
  
  	if (unlikely (list_empty (&qh->qtd_list)))
***************
*** 421,426 ****
--- 422,428 ----
  					&& !(qtd->hw_alt_next
  						& EHCI_LIST_END(ehci))) {
  				stopped = 1;
+ 				goto halt;
  			}
  
  		/* stop scanning when we reach qtds the hc is using */
***************
*** 454,459 ****
--- 456,471 ----
  				 */
  				ehci_clear_tt_buffer(ehci, qh, urb, token);
  			}
+ 
+ 			/* force halt for unlinked or blocked qh, so we'll
+ 			 * patch the qh later and so that completions can't
+ 			 * activate it while we "know" it's stopped.
+ 			 */
+ 			if ((halt & hw->hw_token) == 0) {
+ halt:
+ 				hw->hw_token |= halt;
+ 				wmb ();
+ 			}
  		}
  
  		/* unless we already know the urb's status, collect qtd status
***************
*** 1246,1272 ****
  
  static void scan_async (struct ehci_hcd *ehci)
  {
- 	bool			stopped;
  	struct ehci_qh		*qh;
  	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
  
  	ehci->stamp = ehci_readl(ehci, &ehci->regs->frame_index);
  	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
  rescan:
- 	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)->state);
  	qh = ehci->async->qh_next.qh;
  	if (likely (qh != NULL)) {
  		do {
  			/* clean any finished work for this qh */
! 			if (!list_empty(&qh->qtd_list) && (stopped ||
! 					qh->stamp != ehci->stamp)) {
  				int temp;
  
  				/* unlinks could happen here; completion
  				 * reporting drops the lock.  rescan using
  				 * the latest schedule, but don't rescan
! 				 * qhs we already finished (no looping)
! 				 * unless the controller is stopped.
  				 */
  				qh = qh_get (qh);
  				qh->stamp = ehci->stamp;
--- 1258,1281 ----
  
  static void scan_async (struct ehci_hcd *ehci)
  {
  	struct ehci_qh		*qh;
  	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
  
  	ehci->stamp = ehci_readl(ehci, &ehci->regs->frame_index);
  	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
  rescan:
  	qh = ehci->async->qh_next.qh;
  	if (likely (qh != NULL)) {
  		do {
  			/* clean any finished work for this qh */
! 			if (!list_empty (&qh->qtd_list)
! 					&& qh->stamp != ehci->stamp) {
  				int temp;
  
  				/* unlinks could happen here; completion
  				 * reporting drops the lock.  rescan using
  				 * the latest schedule, but don't rescan
! 				 * qhs we already finished (no looping).
  				 */
  				qh = qh_get (qh);
  				qh->stamp = ehci->stamp;
***************
*** 1287,1295 ****
  			 */
  			if (list_empty(&qh->qtd_list)
  					&& qh->qh_state == QH_STATE_LINKED) {
! 				if (!ehci->reclaim && (stopped ||
! 					((ehci->stamp - qh->stamp) & 0x1fff)
! 						>= EHCI_SHRINK_FRAMES * 8))
  					start_unlink_async(ehci, qh);
  				else
  					action = TIMER_ASYNC_SHRINK;
--- 1296,1304 ----
  			 */
  			if (list_empty(&qh->qtd_list)
  					&& qh->qh_state == QH_STATE_LINKED) {
! 				if (!ehci->reclaim
! 					&& ((ehci->stamp - qh->stamp) & 0x1fff)
! 						>= (EHCI_SHRINK_FRAMES * 8))
  					start_unlink_async(ehci, qh);
  				else
  					action = TIMER_ASYNC_SHRINK;
diff -cBr 2.6.35/drivers/usb/host/ehci-sched.c linux-2.6.35.y-512ac85/drivers/usb/host/ehci-sched.c
*** 2.6.35/drivers/usb/host/ehci-sched.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/ehci-sched.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1586,1648 ****
  	*hw_p = cpu_to_hc32(ehci, itd->itd_dma | Q_TYPE_ITD);
  }
  
- #define AB_REG_BAR_LOW 0xe0
- #define AB_REG_BAR_HIGH 0xe1
- #define AB_INDX(addr) ((addr) + 0x00)
- #define AB_DATA(addr) ((addr) + 0x04)
- #define NB_PCIE_INDX_ADDR 0xe0
- #define NB_PCIE_INDX_DATA 0xe4
- #define NB_PIF0_PWRDOWN_0 0x01100012
- #define NB_PIF0_PWRDOWN_1 0x01100013
- 
- static void ehci_quirk_amd_L1(struct ehci_hcd *ehci, int disable)
- {
- 	u32 addr, addr_low, addr_high, val;
- 
- 	outb_p(AB_REG_BAR_LOW, 0xcd6);
- 	addr_low = inb_p(0xcd7);
- 	outb_p(AB_REG_BAR_HIGH, 0xcd6);
- 	addr_high = inb_p(0xcd7);
- 	addr = addr_high << 8 | addr_low;
- 	outl_p(0x30, AB_INDX(addr));
- 	outl_p(0x40, AB_DATA(addr));
- 	outl_p(0x34, AB_INDX(addr));
- 	val = inl_p(AB_DATA(addr));
- 
- 	if (disable) {
- 		val &= ~0x8;
- 		val |= (1 << 4) | (1 << 9);
- 	} else {
- 		val |= 0x8;
- 		val &= ~((1 << 4) | (1 << 9));
- 	}
- 	outl_p(val, AB_DATA(addr));
- 
- 	if (amd_nb_dev) {
- 		addr = NB_PIF0_PWRDOWN_0;
- 		pci_write_config_dword(amd_nb_dev, NB_PCIE_INDX_ADDR, addr);
- 		pci_read_config_dword(amd_nb_dev, NB_PCIE_INDX_DATA, &val);
- 		if (disable)
- 			val &= ~(0x3f << 7);
- 		else
- 			val |= 0x3f << 7;
- 
- 		pci_write_config_dword(amd_nb_dev, NB_PCIE_INDX_DATA, val);
- 
- 		addr = NB_PIF0_PWRDOWN_1;
- 		pci_write_config_dword(amd_nb_dev, NB_PCIE_INDX_ADDR, addr);
- 		pci_read_config_dword(amd_nb_dev, NB_PCIE_INDX_DATA, &val);
- 		if (disable)
- 			val &= ~(0x3f << 7);
- 		else
- 			val |= 0x3f << 7;
- 
- 		pci_write_config_dword(amd_nb_dev, NB_PCIE_INDX_DATA, val);
- 	}
- 
- 	return;
- }
- 
  /* fit urb's itds into the selected schedule slot; activate as needed */
  static int
  itd_link_urb (
--- 1586,1591 ----
***************
*** 1670,1681 ****
  			next_uframe >> 3, next_uframe & 0x7);
  		stream->start = jiffies;
  	}
- 
- 	if (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {
- 		if (ehci->amd_l1_fix == 1)
- 			ehci_quirk_amd_L1(ehci, 1);
- 	}
- 
  	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;
  
  	/* fill iTDs uframe by uframe */
--- 1613,1618 ----
***************
*** 1802,1812 ****
  	(void) disable_periodic(ehci);
  	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
  
- 	if (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {
- 		if (ehci->amd_l1_fix == 1)
- 			ehci_quirk_amd_L1(ehci, 0);
- 	}
- 
  	if (unlikely(list_is_singular(&stream->td_list))) {
  		ehci_to_hcd(ehci)->self.bandwidth_allocated
  				-= stream->bandwidth;
--- 1739,1744 ----
***************
*** 2094,2105 ****
  			stream->interval, hc32_to_cpu(ehci, stream->splits));
  		stream->start = jiffies;
  	}
- 
- 	if (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {
- 		if (ehci->amd_l1_fix == 1)
- 			ehci_quirk_amd_L1(ehci, 1);
- 	}
- 
  	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;
  
  	/* fill sITDs frame by frame */
--- 2026,2031 ----
***************
*** 2202,2212 ****
  	(void) disable_periodic(ehci);
  	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
  
- 	if (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {
- 		if (ehci->amd_l1_fix == 1)
- 			ehci_quirk_amd_L1(ehci, 0);
- 	}
- 
  	if (list_is_singular(&stream->td_list)) {
  		ehci_to_hcd(ehci)->self.bandwidth_allocated
  				-= stream->bandwidth;
--- 2128,2133 ----
diff -cBr 2.6.35/drivers/usb/host/isp1760-hcd.c linux-2.6.35.y-512ac85/drivers/usb/host/isp1760-hcd.c
*** 2.6.35/drivers/usb/host/isp1760-hcd.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/isp1760-hcd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 33,39 ****
  	struct inter_packet_info atl_ints[32];
  	struct inter_packet_info int_ints[32];
  	struct memory_chunk memory_pool[BLOCKS];
- 	u32 atl_queued;
  
  	/* periodic schedule support */
  #define	DEFAULT_I_TDPS		1024
--- 33,38 ----
***************
*** 851,861 ****
  	skip_map &= ~queue_entry;
  	isp1760_writel(skip_map, hcd->regs + HC_ATL_PTD_SKIPMAP_REG);
  
- 	priv->atl_queued++;
- 	if (priv->atl_queued == 2)
- 		isp1760_writel(INTERRUPT_ENABLE_SOT_MASK,
- 				hcd->regs + HC_INTERRUPT_ENABLE);
- 
  	buffstatus = isp1760_readl(hcd->regs + HC_BUFFER_STATUS_REG);
  	buffstatus |= ATL_BUFFER;
  	isp1760_writel(buffstatus, hcd->regs + HC_BUFFER_STATUS_REG);
--- 850,855 ----
***************
*** 997,1003 ****
  		u32 dw3;
  
  		status = 0;
- 		priv->atl_queued--;
  
  		queue_entry = __ffs(done_map);
  		done_map &= ~(1 << queue_entry);
--- 991,996 ----
***************
*** 1060,1065 ****
--- 1053,1063 ----
  			 * device is not able to send data fast enough.
  			 * This happens mostly on slower hardware.
  			 */
+ 			printk(KERN_NOTICE "Reloading ptd %p/%p... qh %p read: "
+ 					"%d of %zu done: %08x cur: %08x\n", qtd,
+ 					urb, qh, PTD_XFERRED_LENGTH(dw3),
+ 					qtd->length, done_map,
+ 					(1 << queue_entry));
  
  			/* RL counter = ERR counter */
  			dw3 &= ~(0xf << 19);
***************
*** 1087,1097 ****
  			priv_write_copy(priv, (u32 *)&ptd, usb_hcd->regs +
  					atl_regs, sizeof(ptd));
  
- 			priv->atl_queued++;
- 			if (priv->atl_queued == 2)
- 				isp1760_writel(INTERRUPT_ENABLE_SOT_MASK,
- 				    usb_hcd->regs + HC_INTERRUPT_ENABLE);
- 
  			buffstatus = isp1760_readl(usb_hcd->regs +
  					HC_BUFFER_STATUS_REG);
  			buffstatus |= ATL_BUFFER;
--- 1085,1090 ----
***************
*** 1197,1205 ****
  		skip_map = isp1760_readl(usb_hcd->regs +
  				HC_ATL_PTD_SKIPMAP_REG);
  	}
- 	if (priv->atl_queued <= 1)
- 		isp1760_writel(INTERRUPT_ENABLE_MASK,
- 				usb_hcd->regs + HC_INTERRUPT_ENABLE);
  }
  
  static void do_intl_int(struct usb_hcd *usb_hcd)
--- 1190,1195 ----
***************
*** 1779,1785 ****
  		goto leave;
  
  	isp1760_writel(imask, usb_hcd->regs + HC_INTERRUPT_REG);
! 	if (imask & (HC_ATL_INT | HC_SOT_INT))
  		do_atl_int(usb_hcd);
  
  	if (imask & HC_INTL_INT)
--- 1769,1775 ----
  		goto leave;
  
  	isp1760_writel(imask, usb_hcd->regs + HC_INTERRUPT_REG);
! 	if (imask & HC_ATL_INT)
  		do_atl_int(usb_hcd);
  
  	if (imask & HC_INTL_INT)
diff -cBr 2.6.35/drivers/usb/host/isp1760-hcd.h linux-2.6.35.y-512ac85/drivers/usb/host/isp1760-hcd.h
*** 2.6.35/drivers/usb/host/isp1760-hcd.h	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/isp1760-hcd.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 69,75 ****
  
  #define HC_INTERRUPT_ENABLE	0x314
  #define INTERRUPT_ENABLE_MASK	(HC_INTL_INT | HC_ATL_INT | HC_EOT_INT)
- #define INTERRUPT_ENABLE_SOT_MASK	(HC_INTL_INT | HC_SOT_INT | HC_EOT_INT)
  
  #define HC_ISO_INT		(1 << 9)
  #define HC_ATL_INT		(1 << 8)
--- 69,74 ----
diff -cBr 2.6.35/drivers/usb/host/xhci.c linux-2.6.35.y-512ac85/drivers/usb/host/xhci.c
*** 2.6.35/drivers/usb/host/xhci.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/xhci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1224,1238 ****
  		cmd_completion = command->completion;
  		cmd_status = &command->status;
  		command->command_trb = xhci->cmd_ring->enqueue;
- 
- 		/* Enqueue pointer can be left pointing to the link TRB,
- 		 * we must handle that
- 		 */
- 		if ((command->command_trb->link.control & TRB_TYPE_BITMASK)
- 				== TRB_TYPE(TRB_LINK))
- 			command->command_trb =
- 				xhci->cmd_ring->enq_seg->next->trbs;
- 
  		list_add_tail(&command->cmd_list, &virt_dev->cmd_list);
  	} else {
  		in_ctx = virt_dev->in_ctx;
--- 1224,1229 ----
***************
*** 1942,1956 ****
  	/* Attempt to submit the Reset Device command to the command ring */
  	spin_lock_irqsave(&xhci->lock, flags);
  	reset_device_cmd->command_trb = xhci->cmd_ring->enqueue;
- 
- 	/* Enqueue pointer can be left pointing to the link TRB,
- 	 * we must handle that
- 	 */
- 	if ((reset_device_cmd->command_trb->link.control & TRB_TYPE_BITMASK)
- 			== TRB_TYPE(TRB_LINK))
- 		reset_device_cmd->command_trb =
- 			xhci->cmd_ring->enq_seg->next->trbs;
- 
  	list_add_tail(&reset_device_cmd->cmd_list, &virt_dev->cmd_list);
  	ret = xhci_queue_reset_device(xhci, slot_id);
  	if (ret) {
--- 1933,1938 ----
***************
*** 2010,2027 ****
  	/* Everything but endpoint 0 is disabled, so free or cache the rings. */
  	last_freed_endpoint = 1;
  	for (i = 1; i < 31; ++i) {
! 		struct xhci_virt_ep *ep = &virt_dev->eps[i];
! 
! 		if (ep->ep_state & EP_HAS_STREAMS) {
! 			xhci_free_stream_info(xhci, ep->stream_info);
! 			ep->stream_info = NULL;
! 			ep->ep_state &= ~EP_HAS_STREAMS;
! 		}
! 
! 		if (ep->ring) {
! 			xhci_free_or_cache_endpoint_ring(xhci, virt_dev, i);
! 			last_freed_endpoint = i;
! 		}
  	}
  	xhci_dbg(xhci, "Output context after successful reset device cmd:\n");
  	xhci_dbg_ctx(xhci, virt_dev->out_ctx, last_freed_endpoint);
--- 1992,2001 ----
  	/* Everything but endpoint 0 is disabled, so free or cache the rings. */
  	last_freed_endpoint = 1;
  	for (i = 1; i < 31; ++i) {
! 		if (!virt_dev->eps[i].ring)
! 			continue;
! 		xhci_free_or_cache_endpoint_ring(xhci, virt_dev, i);
! 		last_freed_endpoint = i;
  	}
  	xhci_dbg(xhci, "Output context after successful reset device cmd:\n");
  	xhci_dbg_ctx(xhci, virt_dev->out_ctx, last_freed_endpoint);
diff -cBr 2.6.35/drivers/usb/host/xhci.h linux-2.6.35.y-512ac85/drivers/usb/host/xhci.h
*** 2.6.35/drivers/usb/host/xhci.h	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/xhci.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 232,238 ****
   * notification type that matches a bit set in this bit field.
   */
  #define	DEV_NOTE_MASK		(0xffff)
! #define ENABLE_DEV_NOTE(x)	(1 << (x))
  /* Most of the device notification types should only be used for debug.
   * SW does need to pay attention to function wake notifications.
   */
--- 232,238 ----
   * notification type that matches a bit set in this bit field.
   */
  #define	DEV_NOTE_MASK		(0xffff)
! #define ENABLE_DEV_NOTE(x)	(1 << x)
  /* Most of the device notification types should only be used for debug.
   * SW does need to pay attention to function wake notifications.
   */
***************
*** 448,471 ****
  
  
  /**
-  * struct xhci_protocol_caps
-  * @revision:		major revision, minor revision, capability ID,
-  *			and next capability pointer.
-  * @name_string:	Four ASCII characters to say which spec this xHC
-  *			follows, typically "USB ".
-  * @port_info:		Port offset, count, and protocol-defined information.
-  */
- struct xhci_protocol_caps {
- 	u32	revision;
- 	u32	name_string;
- 	u32	port_info;
- };
- 
- #define	XHCI_EXT_PORT_MAJOR(x)	(((x) >> 24) & 0xff)
- #define	XHCI_EXT_PORT_OFF(x)	((x) & 0xff)
- #define	XHCI_EXT_PORT_COUNT(x)	(((x) >> 8) & 0xff)
- 
- /**
   * struct xhci_container_ctx
   * @type: Type of context.  Used to calculated offsets to contained contexts.
   * @size: Size of the context data
--- 448,453 ----
***************
*** 598,608 ****
  #define EP_STATE_STOPPED	3
  #define EP_STATE_ERROR		4
  /* Mult - Max number of burtst within an interval, in EP companion desc. */
! #define EP_MULT(p)		(((p) & 0x3) << 8)
  /* bits 10:14 are Max Primary Streams */
  /* bit 15 is Linear Stream Array */
  /* Interval - period between requests to an endpoint - 125u increments. */
! #define EP_INTERVAL(p)		(((p) & 0xff) << 16)
  #define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
  #define EP_MAXPSTREAMS_MASK	(0x1f << 10)
  #define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
--- 580,590 ----
  #define EP_STATE_STOPPED	3
  #define EP_STATE_ERROR		4
  /* Mult - Max number of burtst within an interval, in EP companion desc. */
! #define EP_MULT(p)		((p & 0x3) << 8)
  /* bits 10:14 are Max Primary Streams */
  /* bit 15 is Linear Stream Array */
  /* Interval - period between requests to an endpoint - 125u increments. */
! #define EP_INTERVAL(p)		((p & 0xff) << 16)
  #define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
  #define EP_MAXPSTREAMS_MASK	(0x1f << 10)
  #define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
***************
*** 632,649 ****
  #define MAX_PACKET_MASK		(0xffff << 16)
  #define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
  
- /* Get max packet size from ep desc. Bit 10..0 specify the max packet size.
-  * USB2.0 spec 9.6.6.
-  */
- #define GET_MAX_PACKET(p)	((p) & 0x7ff)
- 
  /* tx_info bitmasks */
  #define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
  #define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
  
- /* deq bitmasks */
- #define EP_CTX_CYCLE_MASK		(1 << 0)
- 
  
  /**
   * struct xhci_input_control_context
--- 614,623 ----
***************
*** 746,757 ****
  	struct timer_list	stop_cmd_timer;
  	int			stop_cmds_pending;
  	struct xhci_hcd		*xhci;
- 	/* Dequeue pointer and dequeue segment for a submitted Set TR Dequeue
- 	 * command.  We'll need to update the ring's dequeue segment and dequeue
- 	 * pointer after the command completes.
- 	 */
- 	struct xhci_segment	*queued_deq_seg;
- 	union xhci_trb		*queued_deq_ptr;
  };
  
  struct xhci_virt_device {
--- 720,725 ----
***************
*** 1214,1228 ****
  #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
  #define XHCI_RESET_EP_QUIRK	(1 << 1)
  #define XHCI_NEC_HOST		(1 << 2)
- 
- 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
- 	u8			*port_array;
- 	/* Array of pointers to USB 3.0 PORTSC registers */
- 	u32 __iomem		**usb3_ports;
- 	unsigned int		num_usb3_ports;
- 	/* Array of pointers to USB 2.0 PORTSC registers */
- 	u32 __iomem		**usb2_ports;
- 	unsigned int		num_usb2_ports;
  };
  
  /* For testing purposes */
--- 1182,1187 ----
diff -cBr 2.6.35/drivers/usb/host/xhci-hub.c linux-2.6.35.y-512ac85/drivers/usb/host/xhci-hub.c
*** 2.6.35/drivers/usb/host/xhci-hub.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/xhci-hub.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 132,144 ****
  static void xhci_disable_port(struct xhci_hcd *xhci, u16 wIndex,
  		u32 __iomem *addr, u32 port_status)
  {
- 	/* Don't allow the USB core to disable SuperSpeed ports. */
- 	if (xhci->port_array[wIndex] == 0x03) {
- 		xhci_dbg(xhci, "Ignoring request to disable "
- 				"SuperSpeed port.\n");
- 		return;
- 	}
- 
  	/* Write 1 to disable the port */
  	xhci_writel(xhci, port_status | PORT_PE, addr);
  	port_status = xhci_readl(xhci, addr);
--- 132,137 ----
diff -cBr 2.6.35/drivers/usb/host/xhci-mem.c linux-2.6.35.y-512ac85/drivers/usb/host/xhci-mem.c
*** 2.6.35/drivers/usb/host/xhci-mem.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/xhci-mem.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 961,1007 ****
  	return 0;
  }
  
- /*
-  * Convert interval expressed as 2^(bInterval - 1) == interval into
-  * straight exponent value 2^n == interval.
-  *
-  */
- static unsigned int xhci_parse_exponent_interval(struct usb_device *udev,
- 		struct usb_host_endpoint *ep)
- {
- 	unsigned int interval;
- 
- 	interval = clamp_val(ep->desc.bInterval, 1, 16) - 1;
- 	if (interval != ep->desc.bInterval - 1)
- 		dev_warn(&udev->dev,
- 			 "ep %#x - rounding interval to %d microframes\n",
- 			 ep->desc.bEndpointAddress,
- 			 1 << interval);
- 
- 	return interval;
- }
- 
- /*
-  * Convert bInterval expressed in frames (in 1-255 range) to exponent of
-  * microframes, rounded down to nearest power of 2.
-  */
- static unsigned int xhci_parse_frame_interval(struct usb_device *udev,
- 		struct usb_host_endpoint *ep)
- {
- 	unsigned int interval;
- 
- 	interval = fls(8 * ep->desc.bInterval) - 1;
- 	interval = clamp_val(interval, 3, 10);
- 	if ((1 << interval) != 8 * ep->desc.bInterval)
- 		dev_warn(&udev->dev,
- 			 "ep %#x - rounding interval to %d microframes, ep desc says %d microframes\n",
- 			 ep->desc.bEndpointAddress,
- 			 1 << interval,
- 			 8 * ep->desc.bInterval);
- 
- 	return interval;
- }
- 
  /* Return the polling or NAK interval.
   *
   * The polling interval is expressed in "microframes".  If xHCI's Interval field
--- 961,966 ----
***************
*** 1019,1053 ****
  	case USB_SPEED_HIGH:
  		/* Max NAK rate */
  		if (usb_endpoint_xfer_control(&ep->desc) ||
! 		    usb_endpoint_xfer_bulk(&ep->desc)) {
  			interval = ep->desc.bInterval;
- 			break;
- 		}
  		/* Fall through - SS and HS isoc/int have same decoding */
  	case USB_SPEED_SUPER:
  		if (usb_endpoint_xfer_int(&ep->desc) ||
! 		    usb_endpoint_xfer_isoc(&ep->desc)) {
! 			interval = xhci_parse_exponent_interval(udev, ep);
  		}
  		break;
  	/* Convert bInterval (in 1-255 frames) to microframes and round down to
  	 * nearest power of 2.
  	 */
  	case USB_SPEED_FULL:
- 		if (usb_endpoint_xfer_int(&ep->desc)) {
- 			interval = xhci_parse_exponent_interval(udev, ep);
- 			break;
- 		}
- 		/*
- 		 * Fall through for isochronous endpoint interval decoding
- 		 * since it uses the same rules as low speed interrupt
- 		 * endpoints.
- 		 */
  	case USB_SPEED_LOW:
  		if (usb_endpoint_xfer_int(&ep->desc) ||
! 		    usb_endpoint_xfer_isoc(&ep->desc)) {
! 
! 			interval = xhci_parse_frame_interval(udev, ep);
  		}
  		break;
  	default:
--- 978,1020 ----
  	case USB_SPEED_HIGH:
  		/* Max NAK rate */
  		if (usb_endpoint_xfer_control(&ep->desc) ||
! 				usb_endpoint_xfer_bulk(&ep->desc))
  			interval = ep->desc.bInterval;
  		/* Fall through - SS and HS isoc/int have same decoding */
  	case USB_SPEED_SUPER:
  		if (usb_endpoint_xfer_int(&ep->desc) ||
! 				usb_endpoint_xfer_isoc(&ep->desc)) {
! 			if (ep->desc.bInterval == 0)
! 				interval = 0;
! 			else
! 				interval = ep->desc.bInterval - 1;
! 			if (interval > 15)
! 				interval = 15;
! 			if (interval != ep->desc.bInterval + 1)
! 				dev_warn(&udev->dev, "ep %#x - rounding interval to %d microframes\n",
! 						ep->desc.bEndpointAddress, 1 << interval);
  		}
  		break;
  	/* Convert bInterval (in 1-255 frames) to microframes and round down to
  	 * nearest power of 2.
  	 */
  	case USB_SPEED_FULL:
  	case USB_SPEED_LOW:
  		if (usb_endpoint_xfer_int(&ep->desc) ||
! 				usb_endpoint_xfer_isoc(&ep->desc)) {
! 			interval = fls(8*ep->desc.bInterval) - 1;
! 			if (interval > 10)
! 				interval = 10;
! 			if (interval < 3)
! 				interval = 3;
! 			if ((1 << interval) != 8*ep->desc.bInterval)
! 				dev_warn(&udev->dev,
! 						"ep %#x - rounding interval"
! 						" to %d microframes, "
! 						"ep desc says %d microframes\n",
! 						ep->desc.bEndpointAddress,
! 						1 << interval,
! 						8*ep->desc.bInterval);
  		}
  		break;
  	default:
***************
*** 1119,1125 ****
  	if (udev->speed == USB_SPEED_SUPER)
  		return ep->ss_ep_comp.wBytesPerInterval;
  
! 	max_packet = GET_MAX_PACKET(ep->desc.wMaxPacketSize);
  	max_burst = (ep->desc.wMaxPacketSize & 0x1800) >> 11;
  	/* A 0 in max burst means 1 transfer per ESIT */
  	return max_packet * (max_burst + 1);
--- 1086,1092 ----
  	if (udev->speed == USB_SPEED_SUPER)
  		return ep->ss_ep_comp.wBytesPerInterval;
  
! 	max_packet = ep->desc.wMaxPacketSize & 0x3ff;
  	max_burst = (ep->desc.wMaxPacketSize & 0x1800) >> 11;
  	/* A 0 in max burst means 1 transfer per ESIT */
  	return max_packet * (max_burst + 1);
***************
*** 1198,1204 ****
  		/* Fall through */
  	case USB_SPEED_FULL:
  	case USB_SPEED_LOW:
! 		max_packet = GET_MAX_PACKET(ep->desc.wMaxPacketSize);
  		ep_ctx->ep_info2 |= MAX_PACKET(max_packet);
  		break;
  	default:
--- 1165,1171 ----
  		/* Fall through */
  	case USB_SPEED_FULL:
  	case USB_SPEED_LOW:
! 		max_packet = ep->desc.wMaxPacketSize & 0x3ff;
  		ep_ctx->ep_info2 |= MAX_PACKET(max_packet);
  		break;
  	default:
***************
*** 1490,1502 ****
  	xhci->dcbaa = NULL;
  
  	scratchpad_free(xhci);
- 
- 	xhci->num_usb2_ports = 0;
- 	xhci->num_usb3_ports = 0;
- 	kfree(xhci->usb2_ports);
- 	kfree(xhci->usb3_ports);
- 	kfree(xhci->port_array);
- 
  	xhci->page_size = 0;
  	xhci->page_shift = 0;
  }
--- 1457,1462 ----
***************
*** 1657,1822 ****
  	return 0;
  }
  
- static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,
- 		u32 __iomem *addr, u8 major_revision)
- {
- 	u32 temp, port_offset, port_count;
- 	int i;
- 
- 	if (major_revision > 0x03) {
- 		xhci_warn(xhci, "Ignoring unknown port speed, "
- 				"Ext Cap %p, revision = 0x%x\n",
- 				addr, major_revision);
- 		/* Ignoring port protocol we can't understand. FIXME */
- 		return;
- 	}
- 
- 	/* Port offset and count in the third dword, see section 7.2 */
- 	temp = xhci_readl(xhci, addr + 2);
- 	port_offset = XHCI_EXT_PORT_OFF(temp);
- 	port_count = XHCI_EXT_PORT_COUNT(temp);
- 	xhci_dbg(xhci, "Ext Cap %p, port offset = %u, "
- 			"count = %u, revision = 0x%x\n",
- 			addr, port_offset, port_count, major_revision);
- 	/* Port count includes the current port offset */
- 	if (port_offset == 0 || (port_offset + port_count - 1) > num_ports)
- 		/* WTF? "Valid values are 1 to MaxPorts" */
- 		return;
- 	port_offset--;
- 	for (i = port_offset; i < (port_offset + port_count); i++) {
- 		/* Duplicate entry.  Ignore the port if the revisions differ. */
- 		if (xhci->port_array[i] != 0) {
- 			xhci_warn(xhci, "Duplicate port entry, Ext Cap %p,"
- 					" port %u\n", addr, i);
- 			xhci_warn(xhci, "Port was marked as USB %u, "
- 					"duplicated as USB %u\n",
- 					xhci->port_array[i], major_revision);
- 			/* Only adjust the roothub port counts if we haven't
- 			 * found a similar duplicate.
- 			 */
- 			if (xhci->port_array[i] != major_revision &&
- 				xhci->port_array[i] != (u8) -1) {
- 				if (xhci->port_array[i] == 0x03)
- 					xhci->num_usb3_ports--;
- 				else
- 					xhci->num_usb2_ports--;
- 				xhci->port_array[i] = (u8) -1;
- 			}
- 			/* FIXME: Should we disable the port? */
- 			continue;
- 		}
- 		xhci->port_array[i] = major_revision;
- 		if (major_revision == 0x03)
- 			xhci->num_usb3_ports++;
- 		else
- 			xhci->num_usb2_ports++;
- 	}
- 	/* FIXME: Should we disable ports not in the Extended Capabilities? */
- }
- 
- /*
-  * Scan the Extended Capabilities for the "Supported Protocol Capabilities" that
-  * specify what speeds each port is supposed to be.  We can't count on the port
-  * speed bits in the PORTSC register being correct until a device is connected,
-  * but we need to set up the two fake roothubs with the correct number of USB
-  * 3.0 and USB 2.0 ports at host controller initialization time.
-  */
- static int xhci_setup_port_arrays(struct xhci_hcd *xhci, gfp_t flags)
- {
- 	u32 __iomem *addr;
- 	u32 offset;
- 	unsigned int num_ports;
- 	int i, port_index;
- 
- 	addr = &xhci->cap_regs->hcc_params;
- 	offset = XHCI_HCC_EXT_CAPS(xhci_readl(xhci, addr));
- 	if (offset == 0) {
- 		xhci_err(xhci, "No Extended Capability registers, "
- 				"unable to set up roothub.\n");
- 		return -ENODEV;
- 	}
- 
- 	num_ports = HCS_MAX_PORTS(xhci->hcs_params1);
- 	xhci->port_array = kzalloc(sizeof(*xhci->port_array)*num_ports, flags);
- 	if (!xhci->port_array)
- 		return -ENOMEM;
- 
- 	/*
- 	 * For whatever reason, the first capability offset is from the
- 	 * capability register base, not from the HCCPARAMS register.
- 	 * See section 5.3.6 for offset calculation.
- 	 */
- 	addr = &xhci->cap_regs->hc_capbase + offset;
- 	while (1) {
- 		u32 cap_id;
- 
- 		cap_id = xhci_readl(xhci, addr);
- 		if (XHCI_EXT_CAPS_ID(cap_id) == XHCI_EXT_CAPS_PROTOCOL)
- 			xhci_add_in_port(xhci, num_ports, addr,
- 					(u8) XHCI_EXT_PORT_MAJOR(cap_id));
- 		offset = XHCI_EXT_CAPS_NEXT(cap_id);
- 		if (!offset || (xhci->num_usb2_ports + xhci->num_usb3_ports)
- 				== num_ports)
- 			break;
- 		/*
- 		 * Once you're into the Extended Capabilities, the offset is
- 		 * always relative to the register holding the offset.
- 		 */
- 		addr += offset;
- 	}
- 
- 	if (xhci->num_usb2_ports == 0 && xhci->num_usb3_ports == 0) {
- 		xhci_warn(xhci, "No ports on the roothubs?\n");
- 		return -ENODEV;
- 	}
- 	xhci_dbg(xhci, "Found %u USB 2.0 ports and %u USB 3.0 ports.\n",
- 			xhci->num_usb2_ports, xhci->num_usb3_ports);
- 	/*
- 	 * Note we could have all USB 3.0 ports, or all USB 2.0 ports.
- 	 * Not sure how the USB core will handle a hub with no ports...
- 	 */
- 	if (xhci->num_usb2_ports) {
- 		xhci->usb2_ports = kmalloc(sizeof(*xhci->usb2_ports)*
- 				xhci->num_usb2_ports, flags);
- 		if (!xhci->usb2_ports)
- 			return -ENOMEM;
- 
- 		port_index = 0;
- 		for (i = 0; i < num_ports; i++) {
- 			if (xhci->port_array[i] == 0x03 ||
- 					xhci->port_array[i] == 0 ||
- 					xhci->port_array[i] == -1)
- 				continue;
- 
- 			xhci->usb2_ports[port_index] =
- 				&xhci->op_regs->port_status_base +
- 				NUM_PORT_REGS*i;
- 			xhci_dbg(xhci, "USB 2.0 port at index %u, "
- 					"addr = %p\n", i,
- 					xhci->usb2_ports[port_index]);
- 			port_index++;
- 		}
- 	}
- 	if (xhci->num_usb3_ports) {
- 		xhci->usb3_ports = kmalloc(sizeof(*xhci->usb3_ports)*
- 				xhci->num_usb3_ports, flags);
- 		if (!xhci->usb3_ports)
- 			return -ENOMEM;
- 
- 		port_index = 0;
- 		for (i = 0; i < num_ports; i++)
- 			if (xhci->port_array[i] == 0x03) {
- 				xhci->usb3_ports[port_index] =
- 					&xhci->op_regs->port_status_base +
- 					NUM_PORT_REGS*i;
- 				xhci_dbg(xhci, "USB 3.0 port at index %u, "
- 						"addr = %p\n", i,
- 						xhci->usb3_ports[port_index]);
- 				port_index++;
- 			}
- 	}
- 	return 0;
- }
  
  int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)
  {
--- 1617,1622 ----
***************
*** 1997,2004 ****
  
  	if (scratchpad_alloc(xhci, flags))
  		goto fail;
- 	if (xhci_setup_port_arrays(xhci, flags))
- 		goto fail;
  
  	return 0;
  
--- 1797,1802 ----
diff -cBr 2.6.35/drivers/usb/host/xhci-ring.c linux-2.6.35.y-512ac85/drivers/usb/host/xhci-ring.c
*** 2.6.35/drivers/usb/host/xhci-ring.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/host/xhci-ring.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 457,467 ****
  	state->new_deq_seg = find_trb_seg(cur_td->start_seg,
  			dev->eps[ep_index].stopped_trb,
  			&state->new_cycle_state);
! 	if (!state->new_deq_seg) {
! 		WARN_ON(1);
! 		return;
! 	}
! 
  	/* Dig out the cycle state saved by the xHC during the stop ep cmd */
  	xhci_dbg(xhci, "Finding endpoint context\n");
  	ep_ctx = xhci_get_ep_ctx(xhci, dev->out_ctx, ep_index);
--- 457,464 ----
  	state->new_deq_seg = find_trb_seg(cur_td->start_seg,
  			dev->eps[ep_index].stopped_trb,
  			&state->new_cycle_state);
! 	if (!state->new_deq_seg)
! 		BUG();
  	/* Dig out the cycle state saved by the xHC during the stop ep cmd */
  	xhci_dbg(xhci, "Finding endpoint context\n");
  	ep_ctx = xhci_get_ep_ctx(xhci, dev->out_ctx, ep_index);
***************
*** 472,481 ****
  	state->new_deq_seg = find_trb_seg(state->new_deq_seg,
  			state->new_deq_ptr,
  			&state->new_cycle_state);
! 	if (!state->new_deq_seg) {
! 		WARN_ON(1);
! 		return;
! 	}
  
  	trb = &state->new_deq_ptr->generic;
  	if ((trb->field[3] & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK) &&
--- 469,476 ----
  	state->new_deq_seg = find_trb_seg(state->new_deq_seg,
  			state->new_deq_ptr,
  			&state->new_cycle_state);
! 	if (!state->new_deq_seg)
! 		BUG();
  
  	trb = &state->new_deq_ptr->generic;
  	if ((trb->field[3] & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK) &&
***************
*** 483,508 ****
  		state->new_cycle_state = ~(state->new_cycle_state) & 0x1;
  	next_trb(xhci, ep_ring, &state->new_deq_seg, &state->new_deq_ptr);
  
- 	/*
- 	 * If there is only one segment in a ring, find_trb_seg()'s while loop
- 	 * will not run, and it will return before it has a chance to see if it
- 	 * needs to toggle the cycle bit.  It can't tell if the stalled transfer
- 	 * ended just before the link TRB on a one-segment ring, or if the TD
- 	 * wrapped around the top of the ring, because it doesn't have the TD in
- 	 * question.  Look for the one-segment case where stalled TRB's address
- 	 * is greater than the new dequeue pointer address.
- 	 */
- 	if (ep_ring->first_seg == ep_ring->first_seg->next &&
- 			state->new_deq_ptr < dev->eps[ep_index].stopped_trb)
- 		state->new_cycle_state ^= 0x1;
- 	xhci_dbg(xhci, "Cycle state = 0x%x\n", state->new_cycle_state);
- 
  	/* Don't update the ring cycle state for the producer (us). */
  	xhci_dbg(xhci, "New dequeue segment = %p (virtual)\n",
  			state->new_deq_seg);
  	addr = xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr);
  	xhci_dbg(xhci, "New dequeue pointer = 0x%llx (DMA)\n",
  			(unsigned long long) addr);
  }
  
  static void td_to_noop(struct xhci_hcd *xhci, struct xhci_ring *ep_ring,
--- 478,492 ----
  		state->new_cycle_state = ~(state->new_cycle_state) & 0x1;
  	next_trb(xhci, ep_ring, &state->new_deq_seg, &state->new_deq_ptr);
  
  	/* Don't update the ring cycle state for the producer (us). */
  	xhci_dbg(xhci, "New dequeue segment = %p (virtual)\n",
  			state->new_deq_seg);
  	addr = xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr);
  	xhci_dbg(xhci, "New dequeue pointer = 0x%llx (DMA)\n",
  			(unsigned long long) addr);
+ 	xhci_dbg(xhci, "Setting dequeue pointer in internal ring state.\n");
+ 	ep_ring->dequeue = state->new_deq_ptr;
+ 	ep_ring->deq_seg = state->new_deq_seg;
  }
  
  static void td_to_noop(struct xhci_hcd *xhci, struct xhci_ring *ep_ring,
***************
*** 921,946 ****
  	} else {
  		xhci_dbg(xhci, "Successful Set TR Deq Ptr cmd, deq = @%08llx\n",
  				ep_ctx->deq);
- 		if (xhci_trb_virt_to_dma(dev->eps[ep_index].queued_deq_seg,
- 					dev->eps[ep_index].queued_deq_ptr) ==
- 				(ep_ctx->deq & ~(EP_CTX_CYCLE_MASK))) {
- 			/* Update the ring's dequeue segment and dequeue pointer
- 			 * to reflect the new position.
- 			 */
- 			ep_ring->deq_seg = dev->eps[ep_index].queued_deq_seg;
- 			ep_ring->dequeue = dev->eps[ep_index].queued_deq_ptr;
- 		} else {
- 			xhci_warn(xhci, "Mismatch between completed Set TR Deq "
- 					"Ptr command & xHCI internal state.\n");
- 			xhci_warn(xhci, "ep deq seg = %p, deq ptr = %p\n",
- 					dev->eps[ep_index].queued_deq_seg,
- 					dev->eps[ep_index].queued_deq_ptr);
- 		}
  	}
  
  	dev->eps[ep_index].ep_state &= ~SET_DEQ_PENDING;
- 	dev->eps[ep_index].queued_deq_seg = NULL;
- 	dev->eps[ep_index].queued_deq_ptr = NULL;
  	/* Restart any rings with pending URBs */
  	ring_doorbell_for_active_rings(xhci, slot_id, ep_index);
  }
--- 905,913 ----
***************
*** 1918,1930 ****
  
  		/* Scatter gather list entries may cross 64KB boundaries */
  		running_total = TRB_MAX_BUFF_SIZE -
! 			(sg_dma_address(sg) & (TRB_MAX_BUFF_SIZE - 1));
! 		running_total &= TRB_MAX_BUFF_SIZE - 1;
  		if (running_total != 0)
  			num_trbs++;
  
  		/* How many more 64KB chunks to transfer, how many more TRBs? */
! 		while (running_total < sg_dma_len(sg) && running_total < temp) {
  			num_trbs++;
  			running_total += TRB_MAX_BUFF_SIZE;
  		}
--- 1885,1896 ----
  
  		/* Scatter gather list entries may cross 64KB boundaries */
  		running_total = TRB_MAX_BUFF_SIZE -
! 			(sg_dma_address(sg) & ((1 << TRB_MAX_BUFF_SHIFT) - 1));
  		if (running_total != 0)
  			num_trbs++;
  
  		/* How many more 64KB chunks to transfer, how many more TRBs? */
! 		while (running_total < sg_dma_len(sg)) {
  			num_trbs++;
  			running_total += TRB_MAX_BUFF_SIZE;
  		}
***************
*** 1949,1959 ****
  static void check_trb_math(struct urb *urb, int num_trbs, int running_total)
  {
  	if (num_trbs != 0)
! 		dev_err(&urb->dev->dev, "%s - ep %#x - Miscalculated number of "
  				"TRBs, %d left\n", __func__,
  				urb->ep->desc.bEndpointAddress, num_trbs);
  	if (running_total != urb->transfer_buffer_length)
! 		dev_err(&urb->dev->dev, "%s - ep %#x - Miscalculated tx length, "
  				"queued %#x (%d), asked for %#x (%d)\n",
  				__func__,
  				urb->ep->desc.bEndpointAddress,
--- 1915,1925 ----
  static void check_trb_math(struct urb *urb, int num_trbs, int running_total)
  {
  	if (num_trbs != 0)
! 		dev_dbg(&urb->dev->dev, "%s - ep %#x - Miscalculated number of "
  				"TRBs, %d left\n", __func__,
  				urb->ep->desc.bEndpointAddress, num_trbs);
  	if (running_total != urb->transfer_buffer_length)
! 		dev_dbg(&urb->dev->dev, "%s - ep %#x - Miscalculated tx length, "
  				"queued %#x (%d), asked for %#x (%d)\n",
  				__func__,
  				urb->ep->desc.bEndpointAddress,
***************
*** 2080,2086 ****
  	sg = urb->sg;
  	addr = (u64) sg_dma_address(sg);
  	this_sg_len = sg_dma_len(sg);
! 	trb_buff_len = TRB_MAX_BUFF_SIZE - (addr & (TRB_MAX_BUFF_SIZE - 1));
  	trb_buff_len = min_t(int, trb_buff_len, this_sg_len);
  	if (trb_buff_len > urb->transfer_buffer_length)
  		trb_buff_len = urb->transfer_buffer_length;
--- 2046,2053 ----
  	sg = urb->sg;
  	addr = (u64) sg_dma_address(sg);
  	this_sg_len = sg_dma_len(sg);
! 	trb_buff_len = TRB_MAX_BUFF_SIZE -
! 		(addr & ((1 << TRB_MAX_BUFF_SHIFT) - 1));
  	trb_buff_len = min_t(int, trb_buff_len, this_sg_len);
  	if (trb_buff_len > urb->transfer_buffer_length)
  		trb_buff_len = urb->transfer_buffer_length;
***************
*** 2116,2122 ****
  				(unsigned int) (addr + TRB_MAX_BUFF_SIZE) & ~(TRB_MAX_BUFF_SIZE - 1),
  				(unsigned int) addr + trb_buff_len);
  		if (TRB_MAX_BUFF_SIZE -
! 				(addr & (TRB_MAX_BUFF_SIZE - 1)) < trb_buff_len) {
  			xhci_warn(xhci, "WARN: sg dma xfer crosses 64KB boundaries!\n");
  			xhci_dbg(xhci, "Next boundary at %#x, end dma = %#x\n",
  					(unsigned int) (addr + TRB_MAX_BUFF_SIZE) & ~(TRB_MAX_BUFF_SIZE - 1),
--- 2083,2089 ----
  				(unsigned int) (addr + TRB_MAX_BUFF_SIZE) & ~(TRB_MAX_BUFF_SIZE - 1),
  				(unsigned int) addr + trb_buff_len);
  		if (TRB_MAX_BUFF_SIZE -
! 				(addr & ((1 << TRB_MAX_BUFF_SHIFT) - 1)) < trb_buff_len) {
  			xhci_warn(xhci, "WARN: sg dma xfer crosses 64KB boundaries!\n");
  			xhci_dbg(xhci, "Next boundary at %#x, end dma = %#x\n",
  					(unsigned int) (addr + TRB_MAX_BUFF_SIZE) & ~(TRB_MAX_BUFF_SIZE - 1),
***************
*** 2160,2166 ****
  		}
  
  		trb_buff_len = TRB_MAX_BUFF_SIZE -
! 			(addr & (TRB_MAX_BUFF_SIZE - 1));
  		trb_buff_len = min_t(int, trb_buff_len, this_sg_len);
  		if (running_total + trb_buff_len > urb->transfer_buffer_length)
  			trb_buff_len =
--- 2127,2133 ----
  		}
  
  		trb_buff_len = TRB_MAX_BUFF_SIZE -
! 			(addr & ((1 << TRB_MAX_BUFF_SHIFT) - 1));
  		trb_buff_len = min_t(int, trb_buff_len, this_sg_len);
  		if (running_total + trb_buff_len > urb->transfer_buffer_length)
  			trb_buff_len =
***************
*** 2199,2206 ****
  	num_trbs = 0;
  	/* How much data is (potentially) left before the 64KB boundary? */
  	running_total = TRB_MAX_BUFF_SIZE -
! 		(urb->transfer_dma & (TRB_MAX_BUFF_SIZE - 1));
! 	running_total &= TRB_MAX_BUFF_SIZE - 1;
  
  	/* If there's some data on this 64KB chunk, or we have to send a
  	 * zero-length transfer, we need at least one TRB
--- 2166,2172 ----
  	num_trbs = 0;
  	/* How much data is (potentially) left before the 64KB boundary? */
  	running_total = TRB_MAX_BUFF_SIZE -
! 		(urb->transfer_dma & ((1 << TRB_MAX_BUFF_SHIFT) - 1));
  
  	/* If there's some data on this 64KB chunk, or we have to send a
  	 * zero-length transfer, we need at least one TRB
***************
*** 2240,2247 ****
  	/* How much data is in the first TRB? */
  	addr = (u64) urb->transfer_dma;
  	trb_buff_len = TRB_MAX_BUFF_SIZE -
! 		(urb->transfer_dma & (TRB_MAX_BUFF_SIZE - 1));
! 	if (trb_buff_len > urb->transfer_buffer_length)
  		trb_buff_len = urb->transfer_buffer_length;
  
  	first_trb = true;
--- 2206,2213 ----
  	/* How much data is in the first TRB? */
  	addr = (u64) urb->transfer_dma;
  	trb_buff_len = TRB_MAX_BUFF_SIZE -
! 		(urb->transfer_dma & ((1 << TRB_MAX_BUFF_SHIFT) - 1));
! 	if (urb->transfer_buffer_length < trb_buff_len)
  		trb_buff_len = urb->transfer_buffer_length;
  
  	first_trb = true;
***************
*** 2526,2532 ****
  	u32 trb_ep_index = EP_ID_FOR_TRB(ep_index);
  	u32 trb_stream_id = STREAM_ID_FOR_TRB(stream_id);
  	u32 type = TRB_TYPE(TRB_SET_DEQ);
- 	struct xhci_virt_ep *ep;
  
  	addr = xhci_trb_virt_to_dma(deq_seg, deq_ptr);
  	if (addr == 0) {
--- 2492,2497 ----
***************
*** 2535,2548 ****
  				deq_seg, deq_ptr);
  		return 0;
  	}
- 	ep = &xhci->devs[slot_id]->eps[ep_index];
- 	if ((ep->ep_state & SET_DEQ_PENDING)) {
- 		xhci_warn(xhci, "WARN Cannot submit Set TR Deq Ptr\n");
- 		xhci_warn(xhci, "A Set TR Deq Ptr command is pending.\n");
- 		return 0;
- 	}
- 	ep->queued_deq_seg = deq_seg;
- 	ep->queued_deq_ptr = deq_ptr;
  	return queue_command(xhci, lower_32_bits(addr) | cycle_state,
  			upper_32_bits(addr), trb_stream_id,
  			trb_slot_id | trb_ep_index | type, false);
--- 2500,2505 ----
diff -cBr 2.6.35/drivers/usb/misc/cypress_cy7c63.c linux-2.6.35.y-512ac85/drivers/usb/misc/cypress_cy7c63.c
*** 2.6.35/drivers/usb/misc/cypress_cy7c63.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/cypress_cy7c63.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 196,204 ****
  	return read_port(dev, attr, buf, 1, CYPRESS_READ_PORT_ID1);
  }
  
! static DEVICE_ATTR(port0, S_IRUGO | S_IWUSR, get_port0_handler, set_port0_handler);
  
! static DEVICE_ATTR(port1, S_IRUGO | S_IWUSR, get_port1_handler, set_port1_handler);
  
  
  static int cypress_probe(struct usb_interface *interface,
--- 196,206 ----
  	return read_port(dev, attr, buf, 1, CYPRESS_READ_PORT_ID1);
  }
  
! static DEVICE_ATTR(port0, S_IWUGO | S_IRUGO,
! 		   get_port0_handler, set_port0_handler);
  
! static DEVICE_ATTR(port1, S_IWUGO | S_IRUGO,
! 		   get_port1_handler, set_port1_handler);
  
  
  static int cypress_probe(struct usb_interface *interface,
diff -cBr 2.6.35/drivers/usb/misc/iowarrior.c linux-2.6.35.y-512ac85/drivers/usb/misc/iowarrior.c
*** 2.6.35/drivers/usb/misc/iowarrior.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/iowarrior.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 373,379 ****
  	case USB_DEVICE_ID_CODEMERCS_IOWPV2:
  	case USB_DEVICE_ID_CODEMERCS_IOW40:
  		/* IOW24 and IOW40 use a synchronous call */
! 		buf = kmalloc(count, GFP_KERNEL);
  		if (!buf) {
  			retval = -ENOMEM;
  			goto exit;
--- 373,379 ----
  	case USB_DEVICE_ID_CODEMERCS_IOWPV2:
  	case USB_DEVICE_ID_CODEMERCS_IOW40:
  		/* IOW24 and IOW40 use a synchronous call */
! 		buf = kmalloc(8, GFP_KERNEL);	/* 8 bytes are enough for both products */
  		if (!buf) {
  			retval = -ENOMEM;
  			goto exit;
***************
*** 552,558 ****
  			/* needed for power consumption */
  			struct usb_config_descriptor *cfg_descriptor = &dev->udev->actconfig->desc;
  
- 			memset(&info, 0, sizeof(info));
  			/* directly from the descriptor */
  			info.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);
  			info.product = dev->product_id;
--- 552,557 ----
diff -cBr 2.6.35/drivers/usb/misc/sisusbvga/sisusb.c linux-2.6.35.y-512ac85/drivers/usb/misc/sisusbvga/sisusb.c
*** 2.6.35/drivers/usb/misc/sisusbvga/sisusb.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/sisusbvga/sisusb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3008,3014 ****
  #else
  			x.sisusb_conactive  = 0;
  #endif
- 			memset(x.sisusb_reserved, 0, sizeof(x.sisusb_reserved));
  
  			if (copy_to_user((void __user *)arg, &x, sizeof(x)))
  				retval = -EFAULT;
--- 3008,3013 ----
diff -cBr 2.6.35/drivers/usb/misc/trancevibrator.c linux-2.6.35.y-512ac85/drivers/usb/misc/trancevibrator.c
*** 2.6.35/drivers/usb/misc/trancevibrator.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/trancevibrator.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 86,92 ****
  	return count;
  }
  
! static DEVICE_ATTR(speed, S_IRUGO | S_IWUSR, show_speed, set_speed);
  
  static int tv_probe(struct usb_interface *interface,
  		    const struct usb_device_id *id)
--- 86,92 ----
  	return count;
  }
  
! static DEVICE_ATTR(speed, S_IWUGO | S_IRUGO, show_speed, set_speed);
  
  static int tv_probe(struct usb_interface *interface,
  		    const struct usb_device_id *id)
diff -cBr 2.6.35/drivers/usb/misc/usbled.c linux-2.6.35.y-512ac85/drivers/usb/misc/usbled.c
*** 2.6.35/drivers/usb/misc/usbled.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/usbled.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 94,100 ****
  	change_color(led);						\
  	return count;							\
  }									\
! static DEVICE_ATTR(value, S_IRUGO | S_IWUSR, show_##value, set_##value);
  show_set(blue);
  show_set(red);
  show_set(green);
--- 94,100 ----
  	change_color(led);						\
  	return count;							\
  }									\
! static DEVICE_ATTR(value, S_IWUGO | S_IRUGO, show_##value, set_##value);
  show_set(blue);
  show_set(red);
  show_set(green);
diff -cBr 2.6.35/drivers/usb/misc/usbsevseg.c linux-2.6.35.y-512ac85/drivers/usb/misc/usbsevseg.c
*** 2.6.35/drivers/usb/misc/usbsevseg.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/usbsevseg.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 192,198 ****
  								\
  	return count;						\
  }								\
! static DEVICE_ATTR(name, S_IRUGO | S_IWUSR, show_attr_##name, set_attr_##name);
  
  static ssize_t show_attr_text(struct device *dev,
  	struct device_attribute *attr, char *buf)
--- 192,198 ----
  								\
  	return count;						\
  }								\
! static DEVICE_ATTR(name, S_IWUGO | S_IRUGO, show_attr_##name, set_attr_##name);
  
  static ssize_t show_attr_text(struct device *dev,
  	struct device_attribute *attr, char *buf)
***************
*** 223,229 ****
  	return count;
  }
  
! static DEVICE_ATTR(text, S_IRUGO | S_IWUSR, show_attr_text, set_attr_text);
  
  static ssize_t show_attr_decimals(struct device *dev,
  	struct device_attribute *attr, char *buf)
--- 223,229 ----
  	return count;
  }
  
! static DEVICE_ATTR(text, S_IWUGO | S_IRUGO, show_attr_text, set_attr_text);
  
  static ssize_t show_attr_decimals(struct device *dev,
  	struct device_attribute *attr, char *buf)
***************
*** 272,278 ****
  	return count;
  }
  
! static DEVICE_ATTR(decimals, S_IRUGO | S_IWUSR, show_attr_decimals, set_attr_decimals);
  
  static ssize_t show_attr_textmode(struct device *dev,
  	struct device_attribute *attr, char *buf)
--- 272,279 ----
  	return count;
  }
  
! static DEVICE_ATTR(decimals, S_IWUGO | S_IRUGO,
! 	show_attr_decimals, set_attr_decimals);
  
  static ssize_t show_attr_textmode(struct device *dev,
  	struct device_attribute *attr, char *buf)
***************
*** 318,324 ****
  	return -EINVAL;
  }
  
! static DEVICE_ATTR(textmode, S_IRUGO | S_IWUSR, show_attr_textmode, set_attr_textmode);
  
  
  MYDEV_ATTR_SIMPLE_UNSIGNED(powered, update_display_powered);
--- 319,326 ----
  	return -EINVAL;
  }
  
! static DEVICE_ATTR(textmode, S_IWUGO | S_IRUGO,
! 	show_attr_textmode, set_attr_textmode);
  
  
  MYDEV_ATTR_SIMPLE_UNSIGNED(powered, update_display_powered);
diff -cBr 2.6.35/drivers/usb/misc/uss720.c linux-2.6.35.y-512ac85/drivers/usb/misc/uss720.c
*** 2.6.35/drivers/usb/misc/uss720.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/misc/uss720.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 177,187 ****
  	spin_lock_irqsave(&priv->asynclock, flags);
  	list_add_tail(&rq->asynclist, &priv->asynclist);
  	spin_unlock_irqrestore(&priv->asynclock, flags);
- 	kref_get(&rq->ref_count);
  	ret = usb_submit_urb(rq->urb, mem_flags);
! 	if (!ret)
  		return rq;
! 	destroy_async(&rq->ref_count);
  	err("submit_async_request submit_urb failed with %d", ret);
  	return NULL;
  }
--- 177,188 ----
  	spin_lock_irqsave(&priv->asynclock, flags);
  	list_add_tail(&rq->asynclist, &priv->asynclist);
  	spin_unlock_irqrestore(&priv->asynclock, flags);
  	ret = usb_submit_urb(rq->urb, mem_flags);
! 	if (!ret) {
! 		kref_get(&rq->ref_count);
  		return rq;
! 	}
! 	kref_put(&rq->ref_count, destroy_async);
  	err("submit_async_request submit_urb failed with %d", ret);
  	return NULL;
  }
diff -cBr 2.6.35/drivers/usb/musb/musb_core.c linux-2.6.35.y-512ac85/drivers/usb/musb/musb_core.c
*** 2.6.35/drivers/usb/musb/musb_core.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/musb/musb_core.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2244,2249 ****
--- 2244,2250 ----
  #endif
  	musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
  	musb_platform_exit(musb);
+ 	musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
  
  	musb_free(musb);
  	iounmap(ctrl_base);
diff -cBr 2.6.35/drivers/usb/musb/omap2430.c linux-2.6.35.y-512ac85/drivers/usb/musb/omap2430.c
*** 2.6.35/drivers/usb/musb/omap2430.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/musb/omap2430.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 323,329 ****
  
  int musb_platform_exit(struct musb *musb)
  {
- 	del_timer_sync(&musb_idle_timer);
  
  	musb_platform_suspend(musb);
  
--- 323,328 ----
diff -cBr 2.6.35/drivers/usb/serial/ch341.c linux-2.6.35.y-512ac85/drivers/usb/serial/ch341.c
*** 2.6.35/drivers/usb/serial/ch341.c	2011-05-07 19:57:18.466750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/ch341.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 75,81 ****
  static const struct usb_device_id id_table[] = {
  	{ USB_DEVICE(0x4348, 0x5523) },
  	{ USB_DEVICE(0x1a86, 0x7523) },
- 	{ USB_DEVICE(0x1a86, 0x5523) },
  	{ },
  };
  MODULE_DEVICE_TABLE(usb, id_table);
--- 75,80 ----
***************
*** 487,508 ****
  	if (actual_length >= 4) {
  		struct ch341_private *priv = usb_get_serial_port_data(port);
  		unsigned long flags;
- 		u8 prev_line_status = priv->line_status;
  
  		spin_lock_irqsave(&priv->lock, flags);
  		priv->line_status = (~(data[2])) & CH341_BITS_MODEM_STAT;
  		if ((data[1] & CH341_MULT_STAT))
  			priv->multi_status_change = 1;
  		spin_unlock_irqrestore(&priv->lock, flags);
- 
- 		if ((priv->line_status ^ prev_line_status) & CH341_BIT_DCD) {
- 			struct tty_struct *tty = tty_port_tty_get(&port->port);
- 			if (tty)
- 				usb_serial_handle_dcd_change(port, tty,
- 					    priv->line_status & CH341_BIT_DCD);
- 			tty_kref_put(tty);
- 		}
- 
  		wake_up_interruptible(&priv->delta_msr_wait);
  	}
  
--- 486,497 ----
diff -cBr 2.6.35/drivers/usb/serial/cp210x.c linux-2.6.35.y-512ac85/drivers/usb/serial/cp210x.c
*** 2.6.35/drivers/usb/serial/cp210x.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/cp210x.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 49,54 ****
--- 49,55 ----
  static void cp210x_break_ctl(struct tty_struct *, int);
  static int cp210x_startup(struct usb_serial *);
  static void cp210x_dtr_rts(struct usb_serial_port *p, int on);
+ static int cp210x_carrier_raised(struct usb_serial_port *p);
  
  static int debug;
  
***************
*** 85,90 ****
--- 86,92 ----
  	{ USB_DEVICE(0x10C4, 0x8115) }, /* Arygon NFC/Mifare Reader */
  	{ USB_DEVICE(0x10C4, 0x813D) }, /* Burnside Telecom Deskmobile */
  	{ USB_DEVICE(0x10C4, 0x813F) }, /* Tams Master Easy Control */
+ 	{ USB_DEVICE(0x10C4, 0x8149) }, /* West Mountain Radio Computerized Battery Analyzer */
  	{ USB_DEVICE(0x10C4, 0x814A) }, /* West Mountain Radio RIGblaster P&P */
  	{ USB_DEVICE(0x10C4, 0x814B) }, /* West Mountain Radio RIGtalk */
  	{ USB_DEVICE(0x10C4, 0x8156) }, /* B&G H3000 link cable */
***************
*** 107,115 ****
  	{ USB_DEVICE(0x10C4, 0x8341) }, /* Siemens MC35PU GPRS Modem */
  	{ USB_DEVICE(0x10C4, 0x8382) }, /* Cygnal Integrated Products, Inc. */
  	{ USB_DEVICE(0x10C4, 0x83A8) }, /* Amber Wireless AMB2560 */
- 	{ USB_DEVICE(0x10C4, 0x83D8) }, /* DekTec DTA Plus VHF/UHF Booster/Attenuator */
  	{ USB_DEVICE(0x10C4, 0x8411) }, /* Kyocera GPS Module */
- 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
  	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
  	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
  	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
--- 109,115 ----
***************
*** 165,170 ****
--- 165,171 ----
  	.tiocmset		= cp210x_tiocmset,
  	.attach			= cp210x_startup,
  	.dtr_rts		= cp210x_dtr_rts,
+ 	.carrier_raised		= cp210x_carrier_raised
  };
  
  /* Config request types */
***************
*** 763,768 ****
--- 764,778 ----
  	return result;
  }
  
+ static int cp210x_carrier_raised(struct usb_serial_port *p)
+ {
+ 	unsigned int control;
+ 	cp210x_get_config(p, CP210X_GET_MDMSTS, &control, 1);
+ 	if (control & CONTROL_DCD)
+ 		return 1;
+ 	return 0;
+ }
+ 
  static void cp210x_break_ctl (struct tty_struct *tty, int break_state)
  {
  	struct usb_serial_port *port = tty->driver_data;
diff -cBr 2.6.35/drivers/usb/serial/digi_acceleport.c linux-2.6.35.y-512ac85/drivers/usb/serial/digi_acceleport.c
*** 2.6.35/drivers/usb/serial/digi_acceleport.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/digi_acceleport.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 455,460 ****
--- 455,461 ----
  static int digi_chars_in_buffer(struct tty_struct *tty);
  static int digi_open(struct tty_struct *tty, struct usb_serial_port *port);
  static void digi_close(struct usb_serial_port *port);
+ static int digi_carrier_raised(struct usb_serial_port *port);
  static void digi_dtr_rts(struct usb_serial_port *port, int on);
  static int digi_startup_device(struct usb_serial *serial);
  static int digi_startup(struct usb_serial *serial);
***************
*** 510,515 ****
--- 511,517 ----
  	.open =				digi_open,
  	.close =			digi_close,
  	.dtr_rts =			digi_dtr_rts,
+ 	.carrier_raised =		digi_carrier_raised,
  	.write =			digi_write,
  	.write_room =			digi_write_room,
  	.write_bulk_callback = 		digi_write_bulk_callback,
***************
*** 1335,1340 ****
--- 1337,1350 ----
  	digi_set_modem_signals(port, on * (TIOCM_DTR|TIOCM_RTS), 1);
  }
  
+ static int digi_carrier_raised(struct usb_serial_port *port)
+ {
+ 	struct digi_port *priv = usb_get_serial_port_data(port);
+ 	if (priv->dp_modem_signals & TIOCM_CD)
+ 		return 1;
+ 	return 0;
+ }
+ 
  static int digi_open(struct tty_struct *tty, struct usb_serial_port *port)
  {
  	int ret;
diff -cBr 2.6.35/drivers/usb/serial/ftdi_sio.c linux-2.6.35.y-512ac85/drivers/usb/serial/ftdi_sio.c
*** 2.6.35/drivers/usb/serial/ftdi_sio.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/ftdi_sio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 99,105 ****
  static int   ftdi_jtag_probe(struct usb_serial *serial);
  static int   ftdi_mtxorb_hack_setup(struct usb_serial *serial);
  static int   ftdi_NDI_device_setup(struct usb_serial *serial);
- static int   ftdi_stmclite_probe(struct usb_serial *serial);
  static void  ftdi_USB_UIRT_setup(struct ftdi_private *priv);
  static void  ftdi_HE_TIRA1_setup(struct ftdi_private *priv);
  
--- 99,104 ----
***************
*** 123,132 ****
  	.port_probe = ftdi_HE_TIRA1_setup,
  };
  
- static struct ftdi_sio_quirk ftdi_stmclite_quirk = {
- 	.probe	= ftdi_stmclite_probe,
- };
- 
  /*
   * The 8U232AM has the same API as the sio except for:
   * - it can support MUCH higher baudrates; up to:
--- 122,127 ----
***************
*** 150,157 ****
   * /sys/bus/usb/ftdi_sio/new_id, then send patch/report!
   */
  static struct usb_device_id id_table_combined [] = {
- 	{ USB_DEVICE(FTDI_VID, FTDI_CTI_MINI_PID) },
- 	{ USB_DEVICE(FTDI_VID, FTDI_CTI_NANO_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_AMC232_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_CANUSB_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_CANDAPTER_PID) },
--- 145,150 ----
***************
*** 208,214 ****
  	{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_5_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_6_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_R2000KU_TRUE_RNG) },
- 	{ USB_DEVICE(FTDI_VID, FTDI_VARDAAN_PID) },
  	{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0100_PID) },
  	{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0101_PID) },
  	{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0102_PID) },
--- 201,206 ----
***************
*** 526,532 ****
  	{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_8_PID) },
  	{ USB_DEVICE(IDTECH_VID, IDTECH_IDT1221U_PID) },
  	{ USB_DEVICE(OCT_VID, OCT_US101_PID) },
- 	{ USB_DEVICE(OCT_VID, OCT_DK201_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_HE_TIRA1_PID),
  		.driver_info = (kernel_ulong_t)&ftdi_HE_TIRA1_quirk },
  	{ USB_DEVICE(FTDI_VID, FTDI_USB_UIRT_PID),
--- 518,523 ----
***************
*** 623,629 ****
  	{ USB_DEVICE(FTDI_VID, FTDI_OCEANIC_PID) },
  	{ USB_DEVICE(TTI_VID, TTI_QL355P_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_RM_CANVIEW_PID) },
- 	{ USB_DEVICE(ACTON_VID, ACTON_SPECTRAPRO_PID) },
  	{ USB_DEVICE(CONTEC_VID, CONTEC_COM1USBH_PID) },
  	{ USB_DEVICE(BANDB_VID, BANDB_USOTL4_PID) },
  	{ USB_DEVICE(BANDB_VID, BANDB_USTL4_PID) },
--- 614,619 ----
***************
*** 684,700 ****
  	{ USB_DEVICE(FTDI_VID, FTDI_PCDJ_DAC2_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_RRCIRKITS_LOCOBUFFER_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_ASK_RDR400_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_1_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_OPC_U_UC_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2C1_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2C2_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2D_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2VT_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2VR_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP4KVT_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP4KVR_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2KVT_PID) },
! 	{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2KVR_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_ACG_HFDUAL_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_YEI_SERVOCENTER31_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_THORLABS_PID) },
--- 674,680 ----
  	{ USB_DEVICE(FTDI_VID, FTDI_PCDJ_DAC2_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_RRCIRKITS_LOCOBUFFER_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_ASK_RDR400_PID) },
! 	{ USB_DEVICE(ICOM_ID1_VID, ICOM_ID1_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_ACG_HFDUAL_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_YEI_SERVOCENTER31_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_THORLABS_PID) },
***************
*** 716,722 ****
  		.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },
  	{ USB_DEVICE(TELLDUS_VID, TELLDUS_TELLSTICK_PID) },
  	{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_SERIAL_VX7_PID) },
- 	{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_CT29B_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_MAXSTREAM_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_PHI_FISCO_PID) },
  	{ USB_DEVICE(TML_VID, TML_USB_SERIAL_PID) },
--- 696,701 ----
***************
*** 787,794 ****
  	{ USB_DEVICE(FTDI_VID, MARVELL_OPENRD_PID),
  		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
  	{ USB_DEVICE(FTDI_VID, HAMEG_HO820_PID) },
- 	{ USB_DEVICE(FTDI_VID, HAMEG_HO720_PID) },
- 	{ USB_DEVICE(FTDI_VID, HAMEG_HO730_PID) },
  	{ USB_DEVICE(FTDI_VID, HAMEG_HO870_PID) },
  	{ USB_DEVICE(FTDI_VID, MJSG_GENERIC_PID) },
  	{ USB_DEVICE(FTDI_VID, MJSG_SR_RADIO_PID) },
--- 766,771 ----
***************
*** 817,827 ****
  	{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_LOGBOOKML_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_LS_LOGBOOK_PID) },
  	{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_HS_LOGBOOK_PID) },
- 	{ USB_DEVICE(FTDI_VID, FTDI_DOTEC_PID) },
- 	{ USB_DEVICE(QIHARDWARE_VID, MILKYMISTONE_JTAGSERIAL_PID),
- 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
- 	{ USB_DEVICE(ST_VID, ST_STMCLT1030_PID),
- 		.driver_info = (kernel_ulong_t)&ftdi_stmclite_quirk },
  	{ },					/* Optional parameter entry */
  	{ }					/* Terminating entry */
  };
--- 794,799 ----
***************
*** 1703,1727 ****
  }
  
  /*
-  * First and second port on STMCLiteadaptors is reserved for JTAG interface
-  * and the forth port for pio
-  */
- static int ftdi_stmclite_probe(struct usb_serial *serial)
- {
- 	struct usb_device *udev = serial->dev;
- 	struct usb_interface *interface = serial->interface;
- 
- 	dbg("%s", __func__);
- 
- 	if (interface == udev->actconfig->interface[2])
- 		return 0;
- 
- 	dev_info(&udev->dev, "Ignoring serial port reserved for JTAG\n");
- 
- 	return -ENODEV;
- }
- 
- /*
   * The Matrix Orbital VK204-25-USB has an invalid IN endpoint.
   * We have to correct it if we want to read from it.
   */
--- 1675,1680 ----
diff -cBr 2.6.35/drivers/usb/serial/ftdi_sio_ids.h linux-2.6.35.y-512ac85/drivers/usb/serial/ftdi_sio_ids.h
*** 2.6.35/drivers/usb/serial/ftdi_sio_ids.h	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/ftdi_sio_ids.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 114,122 ****
  /* Lenz LI-USB Computer Interface. */
  #define FTDI_LENZ_LIUSB_PID	0xD780
  
- /* Vardaan Enterprises Serial Interface VEUSB422R3 */
- #define FTDI_VARDAAN_PID	0xF070
- 
  /*
   * Xsens Technologies BV products (http://www.xsens.com).
   */
--- 114,119 ----
***************
*** 300,307 ****
   * Hameg HO820 and HO870 interface (using VID 0x0403)
   */
  #define HAMEG_HO820_PID			0xed74
- #define HAMEG_HO730_PID			0xed73
- #define HAMEG_HO720_PID			0xed72
  #define HAMEG_HO870_PID			0xed71
  
  /*
--- 297,302 ----
***************
*** 520,531 ****
  #define RATOC_PRODUCT_ID_USB60F	0xb020
  
  /*
-  * Acton Research Corp.
-  */
- #define ACTON_VID		0x0647	/* Vendor ID */
- #define ACTON_SPECTRAPRO_PID	0x0100
- 
- /*
   * Contec products (http://www.contec.com)
   * Submitted by Daniel Sangorrin
   */
--- 515,520 ----
***************
*** 574,600 ****
  /* Note: OCT US101 is also rebadged as Dick Smith Electronics (NZ) XH6381 */
  /* Also rebadged as Dick Smith Electronics (Aus) XH6451 */
  /* Also rebadged as SIIG Inc. model US2308 hardware version 1 */
- #define OCT_DK201_PID		0x0103	/* OCT DK201 USB docking station */
  #define OCT_US101_PID		0x0421	/* OCT US101 USB to RS-232 */
  
  /*
!  * Definitions for Icom Inc. devices
   */
! #define ICOM_VID		0x0C26 /* Icom vendor ID */
! /* Note: ID-1 is a communications tranceiver for HAM-radio operators */
! #define ICOM_ID_1_PID		0x0004 /* ID-1 USB to RS-232 */
! /* Note: OPC is an Optional cable to connect an Icom Tranceiver */
! #define ICOM_OPC_U_UC_PID	0x0018 /* OPC-478UC, OPC-1122U cloning cable */
! /* Note: ID-RP* devices are Icom Repeater Devices for HAM-radio */
! #define ICOM_ID_RP2C1_PID	0x0009 /* ID-RP2C Asset 1 to RS-232 */
! #define ICOM_ID_RP2C2_PID	0x000A /* ID-RP2C Asset 2 to RS-232 */
! #define ICOM_ID_RP2D_PID	0x000B /* ID-RP2D configuration port*/
! #define ICOM_ID_RP2VT_PID	0x000C /* ID-RP2V Transmit config port */
! #define ICOM_ID_RP2VR_PID	0x000D /* ID-RP2V Receive config port */
! #define ICOM_ID_RP4KVT_PID	0x0010 /* ID-RP4000V Transmit config port */
! #define ICOM_ID_RP4KVR_PID	0x0011 /* ID-RP4000V Receive config port */
! #define ICOM_ID_RP2KVT_PID	0x0012 /* ID-RP2000V Transmit config port */
! #define ICOM_ID_RP2KVR_PID	0x0013 /* ID-RP2000V Receive config port */
  
  /*
   * GN Otometrics (http://www.otometrics.com)
--- 563,576 ----
  /* Note: OCT US101 is also rebadged as Dick Smith Electronics (NZ) XH6381 */
  /* Also rebadged as Dick Smith Electronics (Aus) XH6451 */
  /* Also rebadged as SIIG Inc. model US2308 hardware version 1 */
  #define OCT_US101_PID		0x0421	/* OCT US101 USB to RS-232 */
  
  /*
!  * Icom ID-1 digital transceiver
   */
! 
! #define ICOM_ID1_VID            0x0C26
! #define ICOM_ID1_PID            0x0004
  
  /*
   * GN Otometrics (http://www.otometrics.com)
***************
*** 745,751 ****
   */
  #define RTSYSTEMS_VID			0x2100	/* Vendor ID */
  #define RTSYSTEMS_SERIAL_VX7_PID	0x9e52	/* Serial converter for VX-7 Radios using FT232RL */
- #define RTSYSTEMS_CT29B_PID		0x9e54	/* CT29B Radio Cable */
  
  /*
   * Bayer Ascensia Contour blood glucose meter USB-converter cable.
--- 721,726 ----
***************
*** 1043,1054 ****
  #define WHT_PID			0x0004 /* Wireless Handheld Terminal */
  
  /*
-  * STMicroelectonics
-  */
- #define ST_VID			0x0483
- #define ST_STMCLT1030_PID	0x3747 /* ST Micro Connect Lite STMCLT1030 */
- 
- /*
   * Papouch products (http://www.papouch.com/)
   * Submitted by Folkert van Heusden
   */
--- 1018,1023 ----
***************
*** 1108,1118 ****
  #define MJSG_HD_RADIO_PID	0x937C
  
  /*
-  * D.O.Tec products (http://www.directout.eu)
-  */
- #define FTDI_DOTEC_PID 0x9868
- 
- /*
   * Xverve Signalyzer tools (http://www.signalyzer.com/)
   */
  #define XVERVE_SIGNALYZER_ST_PID	0xBCA0
--- 1077,1082 ----
***************
*** 1136,1154 ****
  #define FTDI_SCIENCESCOPE_LOGBOOKML_PID		0xFF18
  #define FTDI_SCIENCESCOPE_LS_LOGBOOK_PID	0xFF1C
  #define FTDI_SCIENCESCOPE_HS_LOGBOOK_PID	0xFF1D
- 
- /*
-  * Milkymist One JTAG/Serial
-  */
- #define QIHARDWARE_VID			0x20B7
- #define MILKYMISTONE_JTAGSERIAL_PID	0x0713
- 
- /*
-  * CTI GmbH RS485 Converter http://www.cti-lean.com/
-  */
- /* USB-485-Mini*/
- #define FTDI_CTI_MINI_PID	0xF608
- /* USB-Nano-485*/
- #define FTDI_CTI_NANO_PID	0xF60B
- 
- 
--- 1100,1102 ----
diff -cBr 2.6.35/drivers/usb/serial/generic.c linux-2.6.35.y-512ac85/drivers/usb/serial/generic.c
*** 2.6.35/drivers/usb/serial/generic.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/generic.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 481,506 ****
  }
  EXPORT_SYMBOL_GPL(usb_serial_handle_break);
  
- /**
-  *	usb_serial_handle_dcd_change - handle a change of carrier detect state
-  *	@port: usb_serial_port structure for the open port
-  *	@tty: tty_struct structure for the port
-  *	@status: new carrier detect status, nonzero if active
-  */
- void usb_serial_handle_dcd_change(struct usb_serial_port *usb_port,
- 				struct tty_struct *tty, unsigned int status)
- {
- 	struct tty_port *port = &usb_port->port;
- 
- 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
- 
- 	if (status)
- 		wake_up_interruptible(&port->open_wait);
- 	else if (tty && !C_CLOCAL(tty))
- 		tty_hangup(tty);
- }
- EXPORT_SYMBOL_GPL(usb_serial_handle_dcd_change);
- 
  int usb_serial_generic_resume(struct usb_serial *serial)
  {
  	struct usb_serial_port *port;
--- 481,486 ----
diff -cBr 2.6.35/drivers/usb/serial/io_edgeport.c linux-2.6.35.y-512ac85/drivers/usb/serial/io_edgeport.c
*** 2.6.35/drivers/usb/serial/io_edgeport.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/io_edgeport.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2894,2901 ****
  
  	dbg("%s %d.%d.%d", fw_info, rec->data[0], rec->data[1], build);
  
! 	edge_serial->product_info.FirmwareMajorVersion = rec->data[0];
! 	edge_serial->product_info.FirmwareMinorVersion = rec->data[1];
  	edge_serial->product_info.FirmwareBuildNumber = cpu_to_le16(build);
  
  	for (rec = ihex_next_binrec(rec); rec;
--- 2894,2901 ----
  
  	dbg("%s %d.%d.%d", fw_info, rec->data[0], rec->data[1], build);
  
! 	edge_serial->product_info.FirmwareMajorVersion = fw->data[0];
! 	edge_serial->product_info.FirmwareMinorVersion = fw->data[1];
  	edge_serial->product_info.FirmwareBuildNumber = cpu_to_le16(build);
  
  	for (rec = ihex_next_binrec(rec); rec;
diff -cBr 2.6.35/drivers/usb/serial/keyspan_pda.c linux-2.6.35.y-512ac85/drivers/usb/serial/keyspan_pda.c
*** 2.6.35/drivers/usb/serial/keyspan_pda.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/keyspan_pda.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 680,685 ****
--- 680,701 ----
  	}
  }
  
+ static int keyspan_pda_carrier_raised(struct usb_serial_port *port)
+ {
+ 	struct usb_serial *serial = port->serial;
+ 	unsigned char modembits;
+ 
+ 	/* If we can read the modem status and the DCD is low then
+ 	   carrier is not raised yet */
+ 	if (keyspan_pda_get_modem_info(serial, &modembits) >= 0) {
+ 		if (!(modembits & (1>>6)))
+ 			return 0;
+ 	}
+ 	/* Carrier raised, or we failed (eg disconnected) so
+ 	   progress accordingly */
+ 	return 1;
+ }
+ 
  
  static int keyspan_pda_open(struct tty_struct *tty,
  					struct usb_serial_port *port)
***************
*** 866,871 ****
--- 882,888 ----
  	.id_table =		id_table_std,
  	.num_ports =		1,
  	.dtr_rts =		keyspan_pda_dtr_rts,
+ 	.carrier_raised	=	keyspan_pda_carrier_raised,
  	.open =			keyspan_pda_open,
  	.close =		keyspan_pda_close,
  	.write =		keyspan_pda_write,
diff -cBr 2.6.35/drivers/usb/serial/kobil_sct.c linux-2.6.35.y-512ac85/drivers/usb/serial/kobil_sct.c
*** 2.6.35/drivers/usb/serial/kobil_sct.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/kobil_sct.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 372,378 ****
  	}
  
  	tty = tty_port_tty_get(&port->port);
! 	if (tty && urb->actual_length) {
  
  		/* BEGIN DEBUG */
  		/*
--- 372,378 ----
  	}
  
  	tty = tty_port_tty_get(&port->port);
! 	if (urb->actual_length) {
  
  		/* BEGIN DEBUG */
  		/*
diff -cBr 2.6.35/drivers/usb/serial/option.c linux-2.6.35.y-512ac85/drivers/usb/serial/option.c
*** 2.6.35/drivers/usb/serial/option.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/option.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 362,377 ****
  #define HAIER_VENDOR_ID				0x201e
  #define HAIER_PRODUCT_CE100			0x2009
  
! /* Cinterion (formerly Siemens) products */
! #define SIEMENS_VENDOR_ID				0x0681
! #define CINTERION_VENDOR_ID				0x1e2d
! #define CINTERION_PRODUCT_HC25_MDM		0x0047
! #define CINTERION_PRODUCT_HC25_MDMNET	0x0040
! #define CINTERION_PRODUCT_HC28_MDM		0x004C
! #define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */
! #define CINTERION_PRODUCT_EU3_E			0x0051
! #define CINTERION_PRODUCT_EU3_P			0x0052
! #define CINTERION_PRODUCT_PH8			0x0053
  
  /* Olivetti products */
  #define OLIVETTI_VENDOR_ID			0x0b3c
--- 362,368 ----
  #define HAIER_VENDOR_ID				0x201e
  #define HAIER_PRODUCT_CE100			0x2009
  
! #define CINTERION_VENDOR_ID			0x0681
  
  /* Olivetti products */
  #define OLIVETTI_VENDOR_ID			0x0b3c
***************
*** 511,517 ****
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4505, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3765, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ETS1220, 0xff, 0xff, 0xff) },
! 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E14AC, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_9508) },
  	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) }, /* Novatel Merlin V640/XV620 */
  	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V620) }, /* Novatel Merlin V620/S620 */
--- 492,498 ----
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4505, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3765, 0xff, 0xff, 0xff) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ETS1220, 0xff, 0xff, 0xff) },
! 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E14AC) },
  	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_9508) },
  	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) }, /* Novatel Merlin V640/XV620 */
  	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V620) }, /* Novatel Merlin V620/S620 */
***************
*** 931,951 ****
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_100F) },
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_1011)},
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_1012)},
! 	/* Cinterion */
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_EU3_E) },
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_EU3_P) },
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8) },
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
! 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
! 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDMNET) },
! 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, /* HC28 enumerates with Siemens or Cinterion VID depending on FW revision */
! 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
! 
  	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
  	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
- 	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_MT825UP) }, /* ONDA MT825UP modem */
- 	{ USB_DEVICE_AND_INTERFACE_INFO(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_GT_B3730, USB_CLASS_CDC_DATA, 0x00, 0x00) }, /* Samsung GT-B3730/GT-B3710 LTE USB modem.*/
  	{ } /* Terminating entry */
  };
  MODULE_DEVICE_TABLE(usb, option_ids);
--- 912,920 ----
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_100F) },
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_1011)},
  	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_1012)},
! 	{ USB_DEVICE(CINTERION_VENDOR_ID, 0x0047) },
  	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
  	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
  	{ } /* Terminating entry */
  };
  MODULE_DEVICE_TABLE(usb, option_ids);
diff -cBr 2.6.35/drivers/usb/serial/pl2303.c linux-2.6.35.y-512ac85/drivers/usb/serial/pl2303.c
*** 2.6.35/drivers/usb/serial/pl2303.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/pl2303.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 50,56 ****
  	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },
  	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },
  	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },
- 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },
  	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
  	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
  	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
--- 50,55 ----
***************
*** 678,688 ****
  {
  
  	struct pl2303_private *priv = usb_get_serial_port_data(port);
- 	struct tty_struct *tty;
  	unsigned long flags;
  	u8 status_idx = UART_STATE;
  	u8 length = UART_STATE + 1;
- 	u8 prev_line_status;
  	u16 idv, idp;
  
  	idv = le16_to_cpu(port->serial->dev->descriptor.idVendor);
--- 677,685 ----
***************
*** 704,723 ****
  
  	/* Save off the uart status for others to look at */
  	spin_lock_irqsave(&priv->lock, flags);
- 	prev_line_status = priv->line_status;
  	priv->line_status = data[status_idx];
  	spin_unlock_irqrestore(&priv->lock, flags);
  	if (priv->line_status & UART_BREAK_ERROR)
  		usb_serial_handle_break(port);
  	wake_up_interruptible(&priv->delta_msr_wait);
- 
- 	tty = tty_port_tty_get(&port->port);
- 	if (!tty)
- 		return;
- 	if ((priv->line_status ^ prev_line_status) & UART_DCD)
- 		usb_serial_handle_dcd_change(port, tty,
- 				priv->line_status & UART_DCD);
- 	tty_kref_put(tty);
  }
  
  static void pl2303_read_int_callback(struct urb *urb)
--- 701,711 ----
diff -cBr 2.6.35/drivers/usb/serial/pl2303.h linux-2.6.35.y-512ac85/drivers/usb/serial/pl2303.h
*** 2.6.35/drivers/usb/serial/pl2303.h	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/pl2303.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 21,27 ****
  #define PL2303_PRODUCT_ID_MMX		0x0612
  #define PL2303_PRODUCT_ID_GPRS		0x0609
  #define PL2303_PRODUCT_ID_HCR331	0x331a
- #define PL2303_PRODUCT_ID_MOTOROLA	0x0307
  
  #define ATEN_VENDOR_ID		0x0557
  #define ATEN_VENDOR_ID2		0x0547
--- 21,26 ----
diff -cBr 2.6.35/drivers/usb/serial/sierra.c linux-2.6.35.y-512ac85/drivers/usb/serial/sierra.c
*** 2.6.35/drivers/usb/serial/sierra.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/sierra.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 302,310 ****
  	  .driver_info = (kernel_ulong_t)&direct_ip_interface_blacklist
  	},
         { USB_DEVICE(0x413C, 0x08133) }, /* Dell Computer Corp. Wireless 5720 VZW Mobile Broadband (EVDO Rev-A) Minicard GPS Port */
! 	{ USB_DEVICE(0x0f3d, 0x68A3), 	/* Airprime/Sierra Wireless Direct IP modems */
! 	  .driver_info = (kernel_ulong_t)&direct_ip_interface_blacklist
! 	},
  	{ }
  };
  MODULE_DEVICE_TABLE(usb, id_table);
--- 302,308 ----
  	  .driver_info = (kernel_ulong_t)&direct_ip_interface_blacklist
  	},
         { USB_DEVICE(0x413C, 0x08133) }, /* Dell Computer Corp. Wireless 5720 VZW Mobile Broadband (EVDO Rev-A) Minicard GPS Port */
! 
  	{ }
  };
  MODULE_DEVICE_TABLE(usb, id_table);
diff -cBr 2.6.35/drivers/usb/serial/spcp8x5.c linux-2.6.35.y-512ac85/drivers/usb/serial/spcp8x5.c
*** 2.6.35/drivers/usb/serial/spcp8x5.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/spcp8x5.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 133,139 ****
  
  /* how come ??? */
  #define UART_STATE			0x08
! #define UART_STATE_TRANSIENT_MASK	0x75
  #define UART_DCD			0x01
  #define UART_DSR			0x02
  #define UART_BREAK_ERROR		0x04
--- 133,139 ----
  
  /* how come ??? */
  #define UART_STATE			0x08
! #define UART_STATE_TRANSIENT_MASK	0x74
  #define UART_DCD			0x01
  #define UART_DSR			0x02
  #define UART_BREAK_ERROR		0x04
***************
*** 531,539 ****
  	tty_insert_flip_string_fixed_flag(tty, data, tty_flag,
  							urb->actual_length);
  	tty_flip_buffer_push(tty);
- 	if (status & UART_DCD)
- 		usb_serial_handle_dcd_change(port, tty,
- 			   priv->line_status & MSR_STATUS_LINE_DCD);
  	tty_kref_put(tty);
  }
  
--- 531,536 ----
diff -cBr 2.6.35/drivers/usb/serial/ti_usb_3410_5052.c linux-2.6.35.y-512ac85/drivers/usb/serial/ti_usb_3410_5052.c
*** 2.6.35/drivers/usb/serial/ti_usb_3410_5052.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/ti_usb_3410_5052.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 365,373 ****
  
  static void __exit ti_exit(void)
  {
- 	usb_deregister(&ti_usb_driver);
  	usb_serial_deregister(&ti_1port_device);
  	usb_serial_deregister(&ti_2port_device);
  }
  
  
--- 365,373 ----
  
  static void __exit ti_exit(void)
  {
  	usb_serial_deregister(&ti_1port_device);
  	usb_serial_deregister(&ti_2port_device);
+ 	usb_deregister(&ti_usb_driver);
  }
  
  
diff -cBr 2.6.35/drivers/usb/serial/usb-serial.c linux-2.6.35.y-512ac85/drivers/usb/serial/usb-serial.c
*** 2.6.35/drivers/usb/serial/usb-serial.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/usb-serial.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 52,58 ****
  	.suspend =	usb_serial_suspend,
  	.resume =	usb_serial_resume,
  	.no_dynamic_id = 	1,
- 	.supports_autosuspend =	1,
  };
  
  /* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
--- 52,57 ----
***************
*** 1345,1352 ****
  		return -ENODEV;
  
  	fixup_generic(driver);
- 	if (driver->usb_driver)
- 		driver->usb_driver->supports_autosuspend = 1;
  
  	if (!driver->description)
  		driver->description = driver->driver.name;
--- 1344,1349 ----
diff -cBr 2.6.35/drivers/usb/serial/visor.c linux-2.6.35.y-512ac85/drivers/usb/serial/visor.c
*** 2.6.35/drivers/usb/serial/visor.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/serial/visor.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 27,33 ****
  #include <linux/uaccess.h>
  #include <linux/usb.h>
  #include <linux/usb/serial.h>
- #include <linux/usb/cdc.h>
  #include "visor.h"
  
  /*
--- 27,32 ----
***************
*** 480,496 ****
  
  	dbg("%s", __func__);
  
- 	/*
- 	 * some Samsung Android phones in modem mode have the same ID
- 	 * as SPH-I500, but they are ACM devices, so dont bind to them
- 	 */
- 	if (id->idVendor == SAMSUNG_VENDOR_ID &&
- 		id->idProduct == SAMSUNG_SPH_I500_ID &&
- 		serial->dev->descriptor.bDeviceClass == USB_CLASS_COMM &&
- 		serial->dev->descriptor.bDeviceSubClass ==
- 			USB_CDC_SUBCLASS_ACM)
- 		return -ENODEV;
- 
  	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
  		dev_err(&serial->dev->dev, "active config #%d != 1 ??\n",
  			serial->dev->actconfig->desc.bConfigurationValue);
--- 479,484 ----
diff -cBr 2.6.35/drivers/usb/storage/sierra_ms.c linux-2.6.35.y-512ac85/drivers/usb/storage/sierra_ms.c
*** 2.6.35/drivers/usb/storage/sierra_ms.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/storage/sierra_ms.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 121,127 ****
  	}
  	return result;
  }
! static DEVICE_ATTR(truinst, S_IRUGO, show_truinst, NULL);
  
  int sierra_ms_init(struct us_data *us)
  {
--- 121,127 ----
  	}
  	return result;
  }
! static DEVICE_ATTR(truinst, S_IWUGO | S_IRUGO, show_truinst, NULL);
  
  int sierra_ms_init(struct us_data *us)
  {
diff -cBr 2.6.35/drivers/usb/storage/unusual_cypress.h linux-2.6.35.y-512ac85/drivers/usb/storage/unusual_cypress.h
*** 2.6.35/drivers/usb/storage/unusual_cypress.h	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/storage/unusual_cypress.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 31,39 ****
  		"Cypress ISD-300LP",
  		US_SC_CYP_ATACB, US_PR_DEVICE, NULL, 0),
  
- UNUSUAL_DEV( 0x14cd, 0x6116, 0x0000, 0x9999,
- 		"Super Top",
- 		"USB 2.0  SATA BRIDGE",
- 		US_SC_CYP_ATACB, US_PR_DEVICE, NULL, 0),
- 
  #endif /* defined(CONFIG_USB_STORAGE_CYPRESS_ATACB) || ... */
--- 31,34 ----
diff -cBr 2.6.35/drivers/usb/storage/unusual_devs.h linux-2.6.35.y-512ac85/drivers/usb/storage/unusual_devs.h
*** 2.6.35/drivers/usb/storage/unusual_devs.h	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/usb/storage/unusual_devs.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 481,493 ****
  		US_SC_DEVICE, US_PR_DEVICE, NULL,
  		US_FL_MAX_SECTORS_64),
  
- /* Reported by Vitaly Kuznetsov <vitty@altlinux.ru> */
- UNUSUAL_DEV(  0x04e8, 0x5122, 0x0000, 0x9999,
- 		"Samsung",
- 		"YP-CP3",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL,
- 		US_FL_MAX_SECTORS_64 | US_FL_BULK_IGNORE_TAG),
- 
  /* Entry and supporting patch by Theodore Kilgore <kilgota@auburn.edu>.
   * Device uses standards-violating 32-byte Bulk Command Block Wrappers and
   * reports itself as "Proprietary SCSI Bulk." Cf. device entry 0x084d:0x0011.
--- 481,486 ----
***************
*** 1043,1057 ****
  		US_SC_DEVICE, US_PR_DEVICE, NULL,
  		US_FL_BULK32),
  
- /* Reported by <ttkspam@free.fr>
-  * The device reports a vendor-specific device class, requiring an
-  * explicit vendor/product match.
-  */
- UNUSUAL_DEV(  0x0851, 0x1542, 0x0002, 0x0002,
- 		"MagicPixel",
- 		"FW_Omega2",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL, 0),
- 
  /* Andrew Lunn <andrew@lunn.ch>
   * PanDigital Digital Picture Frame. Does not like ALLOW_MEDIUM_REMOVAL
   * on LUN 4.
--- 1036,1041 ----
***************
*** 1396,1408 ****
  		US_SC_DEVICE, US_PR_DEVICE, NULL,
  		US_FL_IGNORE_RESIDUE ),
  
- /* Submitted by Nick Holloway */
- UNUSUAL_DEV( 0x0f88, 0x042e, 0x0100, 0x0100,
- 		"VTech",
- 		"Kidizoom",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL,
- 		US_FL_FIX_CAPACITY ),
- 
  /* Reported by Michael Stattmann <michael@stattmann.com> */
  UNUSUAL_DEV(  0x0fce, 0xd008, 0x0000, 0x0000,
  		"Sony Ericsson",
--- 1380,1385 ----
***************
*** 1882,1903 ****
  		US_SC_DEVICE, US_PR_DEVICE, NULL,
  		US_FL_BAD_SENSE ),
  
- /* Patch by Richard Schtz <r.schtz@t-online.de>
-  * This external hard drive enclosure uses a JMicron chip which
-  * needs the US_FL_IGNORE_RESIDUE flag to work properly. */
- UNUSUAL_DEV(  0x1e68, 0x001b, 0x0000, 0x0000,
- 		"TrekStor GmbH & Co. KG",
- 		"DataStation maxi g.u",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL,
- 		US_FL_IGNORE_RESIDUE | US_FL_SANE_SENSE ),
- 
- /* Reported by Jasper Mackenzie <scarletpimpernal@hotmail.com> */
- UNUSUAL_DEV( 0x1e74, 0x4621, 0x0000, 0x0000,
- 		"Coby Electronics",
- 		"MP3 Player",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL,
- 		US_FL_BULK_IGNORE_TAG | US_FL_MAX_SECTORS_64 ),
- 
  UNUSUAL_DEV( 0x2116, 0x0320, 0x0001, 0x0001,
  		"ST",
  		"2A",
--- 1859,1864 ----
diff -cBr 2.6.35/drivers/video/backlight/backlight.c linux-2.6.35.y-512ac85/drivers/video/backlight/backlight.c
*** 2.6.35/drivers/video/backlight/backlight.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/video/backlight/backlight.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 197,208 ****
  {
  	struct backlight_device *bd = to_backlight_device(dev);
  
! 	mutex_lock(&bd->ops_lock);
! 	if (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {
  		bd->props.state |= BL_CORE_SUSPENDED;
  		backlight_update_status(bd);
  	}
- 	mutex_unlock(&bd->ops_lock);
  
  	return 0;
  }
--- 197,208 ----
  {
  	struct backlight_device *bd = to_backlight_device(dev);
  
! 	if (bd->ops->options & BL_CORE_SUSPENDRESUME) {
! 		mutex_lock(&bd->ops_lock);
  		bd->props.state |= BL_CORE_SUSPENDED;
  		backlight_update_status(bd);
+ 		mutex_unlock(&bd->ops_lock);
  	}
  
  	return 0;
  }
***************
*** 211,222 ****
  {
  	struct backlight_device *bd = to_backlight_device(dev);
  
! 	mutex_lock(&bd->ops_lock);
! 	if (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {
  		bd->props.state &= ~BL_CORE_SUSPENDED;
  		backlight_update_status(bd);
  	}
- 	mutex_unlock(&bd->ops_lock);
  
  	return 0;
  }
--- 211,222 ----
  {
  	struct backlight_device *bd = to_backlight_device(dev);
  
! 	if (bd->ops->options & BL_CORE_SUSPENDRESUME) {
! 		mutex_lock(&bd->ops_lock);
  		bd->props.state &= ~BL_CORE_SUSPENDED;
  		backlight_update_status(bd);
+ 		mutex_unlock(&bd->ops_lock);
  	}
  
  	return 0;
  }
diff -cBr 2.6.35/drivers/video/console/tileblit.c linux-2.6.35.y-512ac85/drivers/video/console/tileblit.c
*** 2.6.35/drivers/video/console/tileblit.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/video/console/tileblit.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 83,89 ****
  			int softback_lines, int fg, int bg)
  {
  	struct fb_tilecursor cursor;
! 	int use_sw = (vc->vc_cursor_type & 0x10);
  
  	cursor.sx = vc->vc_x;
  	cursor.sy = vc->vc_y;
--- 83,89 ----
  			int softback_lines, int fg, int bg)
  {
  	struct fb_tilecursor cursor;
! 	int use_sw = (vc->vc_cursor_type & 0x01);
  
  	cursor.sx = vc->vc_x;
  	cursor.sy = vc->vc_y;
Only in 2.6.35/drivers/video: samsung
diff -cBr 2.6.35/drivers/video/via/accel.c linux-2.6.35.y-512ac85/drivers/video/via/accel.c
*** 2.6.35/drivers/video/via/accel.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/video/via/accel.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 283,294 ****
  		writel(tmp, engine + 0x1C);
  	}
  
! 	if (op == VIA_BITBLT_FILL) {
! 		writel(fg_color, engine + 0x58);
! 	} else if (op == VIA_BITBLT_MONO) {
  		writel(fg_color, engine + 0x4C);
  		writel(bg_color, engine + 0x50);
- 	}
  
  	if (op == VIA_BITBLT_FILL)
  		ge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;
--- 283,293 ----
  		writel(tmp, engine + 0x1C);
  	}
  
! 	if (op != VIA_BITBLT_COLOR)
  		writel(fg_color, engine + 0x4C);
+ 
+ 	if (op == VIA_BITBLT_MONO)
  		writel(bg_color, engine + 0x50);
  
  	if (op == VIA_BITBLT_FILL)
  		ge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;
diff -cBr 2.6.35/drivers/video/via/via_i2c.c linux-2.6.35.y-512ac85/drivers/video/via/via_i2c.c
*** 2.6.35/drivers/video/via/via_i2c.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/video/via/via_i2c.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 114,120 ****
  
  int viafb_i2c_readbyte(u8 adap, u8 slave_addr, u8 index, u8 *pdata)
  {
- 	int ret;
  	u8 mm1[] = {0x00};
  	struct i2c_msg msgs[2];
  
--- 114,119 ----
***************
*** 127,144 ****
  	mm1[0] = index;
  	msgs[0].len = 1; msgs[1].len = 1;
  	msgs[0].buf = mm1; msgs[1].buf = pdata;
! 	ret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);
! 	if (ret == 2)
! 		ret = 0;
! 	else if (ret >= 0)
! 		ret = -EIO;
! 
! 	return ret;
  }
  
  int viafb_i2c_writebyte(u8 adap, u8 slave_addr, u8 index, u8 data)
  {
- 	int ret;
  	u8 msg[2] = { index, data };
  	struct i2c_msg msgs;
  
--- 126,136 ----
  	mm1[0] = index;
  	msgs[0].len = 1; msgs[1].len = 1;
  	msgs[0].buf = mm1; msgs[1].buf = pdata;
! 	return i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);
  }
  
  int viafb_i2c_writebyte(u8 adap, u8 slave_addr, u8 index, u8 data)
  {
  	u8 msg[2] = { index, data };
  	struct i2c_msg msgs;
  
***************
*** 148,165 ****
  	msgs.addr = slave_addr / 2;
  	msgs.len = 2;
  	msgs.buf = msg;
! 	ret = i2c_transfer(&via_i2c_par[adap].adapter, &msgs, 1);
! 	if (ret == 1)
! 		ret = 0;
! 	else if (ret >= 0)
! 		ret = -EIO;
! 
! 	return ret;
  }
  
  int viafb_i2c_readbytes(u8 adap, u8 slave_addr, u8 index, u8 *buff, int buff_len)
  {
- 	int ret;
  	u8 mm1[] = {0x00};
  	struct i2c_msg msgs[2];
  
--- 140,150 ----
  	msgs.addr = slave_addr / 2;
  	msgs.len = 2;
  	msgs.buf = msg;
! 	return i2c_transfer(&via_i2c_par[adap].adapter, &msgs, 1);
  }
  
  int viafb_i2c_readbytes(u8 adap, u8 slave_addr, u8 index, u8 *buff, int buff_len)
  {
  	u8 mm1[] = {0x00};
  	struct i2c_msg msgs[2];
  
***************
*** 171,183 ****
  	mm1[0] = index;
  	msgs[0].len = 1; msgs[1].len = buff_len;
  	msgs[0].buf = mm1; msgs[1].buf = buff;
! 	ret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);
! 	if (ret == 2)
! 		ret = 0;
! 	else if (ret >= 0)
! 		ret = -EIO;
! 
! 	return ret;
  }
  
  /*
--- 156,162 ----
  	mm1[0] = index;
  	msgs[0].len = 1; msgs[1].len = buff_len;
  	msgs[0].buf = mm1; msgs[1].buf = buff;
! 	return i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);
  }
  
  /*
diff -cBr 2.6.35/drivers/virtio/virtio_pci.c linux-2.6.35.y-512ac85/drivers/virtio/virtio_pci.c
*** 2.6.35/drivers/virtio/virtio_pci.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/virtio/virtio_pci.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 96,101 ****
--- 96,106 ----
  
  MODULE_DEVICE_TABLE(pci, virtio_pci_id_table);
  
+ /* A PCI device has it's own struct device and so does a virtio device so
+  * we create a place for the virtio devices to show up in sysfs.  I think it
+  * would make more sense for virtio to not insist on having it's own device. */
+ static struct device *virtio_pci_root;
+ 
  /* Convert a generic virtio device to our structure */
  static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
  {
***************
*** 624,630 ****
  	if (vp_dev == NULL)
  		return -ENOMEM;
  
! 	vp_dev->vdev.dev.parent = &pci_dev->dev;
  	vp_dev->vdev.dev.release = virtio_pci_release_dev;
  	vp_dev->vdev.config = &virtio_pci_config_ops;
  	vp_dev->pci_dev = pci_dev;
--- 629,635 ----
  	if (vp_dev == NULL)
  		return -ENOMEM;
  
! 	vp_dev->vdev.dev.parent = virtio_pci_root;
  	vp_dev->vdev.dev.release = virtio_pci_release_dev;
  	vp_dev->vdev.config = &virtio_pci_config_ops;
  	vp_dev->pci_dev = pci_dev;
***************
*** 712,718 ****
  
  static int __init virtio_pci_init(void)
  {
! 	return pci_register_driver(&virtio_pci_driver);
  }
  
  module_init(virtio_pci_init);
--- 717,733 ----
  
  static int __init virtio_pci_init(void)
  {
! 	int err;
! 
! 	virtio_pci_root = root_device_register("virtio-pci");
! 	if (IS_ERR(virtio_pci_root))
! 		return PTR_ERR(virtio_pci_root);
! 
! 	err = pci_register_driver(&virtio_pci_driver);
! 	if (err)
! 		root_device_unregister(virtio_pci_root);
! 
! 	return err;
  }
  
  module_init(virtio_pci_init);
***************
*** 720,725 ****
--- 735,741 ----
  static void __exit virtio_pci_exit(void)
  {
  	pci_unregister_driver(&virtio_pci_driver);
+ 	root_device_unregister(virtio_pci_root);
  }
  
  module_exit(virtio_pci_exit);
diff -cBr 2.6.35/drivers/watchdog/rdc321x_wdt.c linux-2.6.35.y-512ac85/drivers/watchdog/rdc321x_wdt.c
*** 2.6.35/drivers/watchdog/rdc321x_wdt.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/watchdog/rdc321x_wdt.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 231,237 ****
  	struct resource *r;
  	struct rdc321x_wdt_pdata *pdata;
  
! 	pdata = platform_get_drvdata(pdev);
  	if (!pdata) {
  		dev_err(&pdev->dev, "no platform data supplied\n");
  		return -ENODEV;
--- 231,237 ----
  	struct resource *r;
  	struct rdc321x_wdt_pdata *pdata;
  
! 	pdata = pdev->dev.platform_data;
  	if (!pdata) {
  		dev_err(&pdev->dev, "no platform data supplied\n");
  		return -ENODEV;
diff -cBr 2.6.35/drivers/xen/events.c linux-2.6.35.y-512ac85/drivers/xen/events.c
*** 2.6.35/drivers/xen/events.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/drivers/xen/events.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 256,262 ****
  	}
  #endif
  
! 	memset(cpu_evtchn_mask(0), ~0, sizeof(struct cpu_evtchn_s));
  }
  
  static inline void clear_evtchn(int port)
--- 256,262 ----
  	}
  #endif
  
! 	memset(cpu_evtchn_mask(0), ~0, sizeof(cpu_evtchn_mask(0)));
  }
  
  static inline void clear_evtchn(int port)
Only in 2.6.35/firmware: samsung_mfc_fw.bin.ihex
diff -cBr 2.6.35/fs/aio.c linux-2.6.35.y-512ac85/fs/aio.c
*** 2.6.35/fs/aio.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/fs/aio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 512,518 ****
  	ctx->reqs_active--;
  
  	if (unlikely(!ctx->reqs_active && ctx->dead))
! 		wake_up_all(&ctx->wait);
  }
  
  static void aio_fput_routine(struct work_struct *data)
--- 512,518 ----
  	ctx->reqs_active--;
  
  	if (unlikely(!ctx->reqs_active && ctx->dead))
! 		wake_up(&ctx->wait);
  }
  
  static void aio_fput_routine(struct work_struct *data)
***************
*** 1233,1239 ****
  	 * by other CPUs at this point.  Right now, we rely on the
  	 * locking done by the above calls to ensure this consistency.
  	 */
! 	wake_up_all(&ioctx->wait);
  	put_ioctx(ioctx);	/* once for the lookup */
  }
  
--- 1233,1239 ----
  	 * by other CPUs at this point.  Right now, we rely on the
  	 * locking done by the above calls to ensure this consistency.
  	 */
! 	wake_up(&ioctx->wait);
  	put_ioctx(ioctx);	/* once for the lookup */
  }
  
diff -cBr 2.6.35/fs/bio.c linux-2.6.35.y-512ac85/fs/bio.c
*** 2.6.35/fs/bio.c	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/fs/bio.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 370,378 ****
  {
  	struct bio *bio;
  
- 	if (nr_iovecs > UIO_MAXIOV)
- 		return NULL;
- 
  	bio = kmalloc(sizeof(struct bio) + nr_iovecs * sizeof(struct bio_vec),
  		      gfp_mask);
  	if (unlikely(!bio))
--- 370,375 ----
***************
*** 700,711 ****
  static struct bio_map_data *bio_alloc_map_data(int nr_segs, int iov_count,
  					       gfp_t gfp_mask)
  {
! 	struct bio_map_data *bmd;
  
- 	if (iov_count > UIO_MAXIOV)
- 		return NULL;
- 
- 	bmd = kmalloc(sizeof(*bmd), gfp_mask);
  	if (!bmd)
  		return NULL;
  
--- 697,704 ----
  static struct bio_map_data *bio_alloc_map_data(int nr_segs, int iov_count,
  					       gfp_t gfp_mask)
  {
! 	struct bio_map_data *bmd = kmalloc(sizeof(*bmd), gfp_mask);
  
  	if (!bmd)
  		return NULL;
  
***************
*** 834,845 ****
  		end = (uaddr + iov[i].iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;
  		start = uaddr >> PAGE_SHIFT;
  
- 		/*
- 		 * Overflow, abort
- 		 */
- 		if (end < start)
- 			return ERR_PTR(-EINVAL);
- 
  		nr_pages += end - start;
  		len += iov[i].iov_len;
  	}
--- 827,832 ----
***************
*** 967,978 ****
  		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
  		unsigned long start = uaddr >> PAGE_SHIFT;
  
- 		/*
- 		 * Overflow, abort
- 		 */
- 		if (end < start)
- 			return ERR_PTR(-EINVAL);
- 
  		nr_pages += end - start;
  		/*
  		 * buffer must be aligned to at least hardsector size for now
--- 954,959 ----
***************
*** 1000,1006 ****
  		unsigned long start = uaddr >> PAGE_SHIFT;
  		const int local_nr_pages = end - start;
  		const int page_limit = cur_page + local_nr_pages;
! 
  		ret = get_user_pages_fast(uaddr, local_nr_pages,
  				write_to_vm, &pages[cur_page]);
  		if (ret < local_nr_pages) {
--- 981,987 ----
  		unsigned long start = uaddr >> PAGE_SHIFT;
  		const int local_nr_pages = end - start;
  		const int page_limit = cur_page + local_nr_pages;
! 		
  		ret = get_user_pages_fast(uaddr, local_nr_pages,
  				write_to_vm, &pages[cur_page]);
  		if (ret < local_nr_pages) {
diff -cBr 2.6.35/fs/btrfs/ctree.h linux-2.6.35.y-512ac85/fs/btrfs/ctree.h
*** 2.6.35/fs/btrfs/ctree.h	2011-05-07 19:57:18.476750002 -0400
--- linux-2.6.35.y-512ac85/fs/btrfs/ctree.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 1212,1219 ****
  #define BTRFS_INODE_NOATIME		(1 << 9)
  #define BTRFS_INODE_DIRSYNC		(1 << 10)
  
- #define BTRFS_INODE_ROOT_ITEM_INIT	(1 << 31)
- 
  /* some macros to generate set/get funcs for the struct fields.  This
   * assumes there is a lefoo_to_cpu for every type, so lets make a simple
   * one for u8:
--- 1212,1217 ----
***************
*** 2241,2248 ****
  int btrfs_find_orphan_roots(struct btrfs_root *tree_root);
  int btrfs_set_root_node(struct btrfs_root_item *item,
  			struct extent_buffer *node);
- void btrfs_check_and_init_root_item(struct btrfs_root_item *item);
- 
  /* dir-item.c */
  int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,
  			  struct btrfs_root *root, const char *name,
--- 2239,2244 ----
diff -cBr 2.6.35/fs/btrfs/disk-io.c linux-2.6.35.y-512ac85/fs/btrfs/disk-io.c
*** 2.6.35/fs/btrfs/disk-io.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/btrfs/disk-io.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1127,1136 ****
  	root->commit_root = btrfs_root_node(root);
  	BUG_ON(!root->node);
  out:
! 	if (location->objectid != BTRFS_TREE_LOG_OBJECTID) {
  		root->ref_cows = 1;
- 		btrfs_check_and_init_root_item(&root->root_item);
- 	}
  
  	return root;
  }
--- 1127,1134 ----
  	root->commit_root = btrfs_root_node(root);
  	BUG_ON(!root->node);
  out:
! 	if (location->objectid != BTRFS_TREE_LOG_OBJECTID)
  		root->ref_cows = 1;
  
  	return root;
  }
diff -cBr 2.6.35/fs/btrfs/ioctl.c linux-2.6.35.y-512ac85/fs/btrfs/ioctl.c
*** 2.6.35/fs/btrfs/ioctl.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/btrfs/ioctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 282,291 ****
  	inode_item->nbytes = cpu_to_le64(root->leafsize);
  	inode_item->mode = cpu_to_le32(S_IFDIR | 0755);
  
- 	root_item.flags = 0;
- 	root_item.byte_limit = 0;
- 	inode_item->flags = cpu_to_le64(BTRFS_INODE_ROOT_ITEM_INIT);
- 
  	btrfs_set_root_bytenr(&root_item, leaf->start);
  	btrfs_set_root_generation(&root_item, trans->transid);
  	btrfs_set_root_level(&root_item, 0);
--- 282,287 ----
diff -cBr 2.6.35/fs/btrfs/root-tree.c linux-2.6.35.y-512ac85/fs/btrfs/root-tree.c
*** 2.6.35/fs/btrfs/root-tree.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/btrfs/root-tree.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 473,493 ****
  	btrfs_free_path(path);
  	return 0;
  }
- 
- /*
-  * Old btrfs forgets to init root_item->flags and root_item->byte_limit
-  * for subvolumes. To work around this problem, we steal a bit from
-  * root_item->inode_item->flags, and use it to indicate if those fields
-  * have been properly initialized.
-  */
- void btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)
- {
- 	u64 inode_flags = le64_to_cpu(root_item->inode.flags);
- 
- 	if (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {
- 		inode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;
- 		root_item->inode.flags = cpu_to_le64(inode_flags);
- 		root_item->flags = 0;
- 		root_item->byte_limit = 0;
- 	}
- }
--- 473,475 ----
diff -cBr 2.6.35/fs/btrfs/transaction.c linux-2.6.35.y-512ac85/fs/btrfs/transaction.c
*** 2.6.35/fs/btrfs/transaction.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/btrfs/transaction.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 895,901 ****
  	record_root_in_trans(trans, root);
  	btrfs_set_root_last_snapshot(&root->root_item, trans->transid);
  	memcpy(new_root_item, &root->root_item, sizeof(*new_root_item));
- 	btrfs_check_and_init_root_item(new_root_item);
  
  	old = btrfs_lock_root_node(root);
  	btrfs_cow_block(trans, root, old, NULL, 0, &old);
--- 895,900 ----
diff -cBr 2.6.35/fs/cifs/cifsproto.h linux-2.6.35.y-512ac85/fs/cifs/cifsproto.h
*** 2.6.35/fs/cifs/cifsproto.h	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/cifs/cifsproto.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 343,349 ****
  			const __u16 netfid, const __u64 len,
  			const __u64 offset, const __u32 numUnlock,
  			const __u32 numLock, const __u8 lockType,
! 			const bool waitFlag, const __u8 oplock_level);
  extern int CIFSSMBPosixLock(const int xid, struct cifsTconInfo *tcon,
  			const __u16 smb_file_id, const int get_flag,
  			const __u64 len, struct file_lock *,
--- 343,349 ----
  			const __u16 netfid, const __u64 len,
  			const __u64 offset, const __u32 numUnlock,
  			const __u32 numLock, const __u8 lockType,
! 			const bool waitFlag);
  extern int CIFSSMBPosixLock(const int xid, struct cifsTconInfo *tcon,
  			const __u16 smb_file_id, const int get_flag,
  			const __u64 len, struct file_lock *,
diff -cBr 2.6.35/fs/cifs/cifssmb.c linux-2.6.35.y-512ac85/fs/cifs/cifssmb.c
*** 2.6.35/fs/cifs/cifssmb.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/cifs/cifssmb.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1647,1654 ****
  CIFSSMBLock(const int xid, struct cifsTconInfo *tcon,
  	    const __u16 smb_file_id, const __u64 len,
  	    const __u64 offset, const __u32 numUnlock,
! 	    const __u32 numLock, const __u8 lockType,
! 	    const bool waitFlag, const __u8 oplock_level)
  {
  	int rc = 0;
  	LOCK_REQ *pSMB = NULL;
--- 1647,1653 ----
  CIFSSMBLock(const int xid, struct cifsTconInfo *tcon,
  	    const __u16 smb_file_id, const __u64 len,
  	    const __u64 offset, const __u32 numUnlock,
! 	    const __u32 numLock, const __u8 lockType, const bool waitFlag)
  {
  	int rc = 0;
  	LOCK_REQ *pSMB = NULL;
***************
*** 1676,1682 ****
  	pSMB->NumberOfLocks = cpu_to_le16(numLock);
  	pSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);
  	pSMB->LockType = lockType;
- 	pSMB->OplockLevel = oplock_level;
  	pSMB->AndXCommand = 0xFF;	/* none */
  	pSMB->Fid = smb_file_id; /* netfid stays le */
  
--- 1675,1680 ----
diff -cBr 2.6.35/fs/cifs/connect.c linux-2.6.35.y-512ac85/fs/cifs/connect.c
*** 2.6.35/fs/cifs/connect.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/cifs/connect.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2606,2612 ****
  
  remote_path_check:
  	/* check if a whole path (including prepath) is not remote */
! 	if (!rc && tcon) {
  		/* build_path_to_root works only when we have a valid tcon */
  		full_path = cifs_build_path_to_root(cifs_sb);
  		if (full_path == NULL) {
--- 2606,2612 ----
  
  remote_path_check:
  	/* check if a whole path (including prepath) is not remote */
! 	if (!rc && cifs_sb->prepathlen && tcon) {
  		/* build_path_to_root works only when we have a valid tcon */
  		full_path = cifs_build_path_to_root(cifs_sb);
  		if (full_path == NULL) {
diff -cBr 2.6.35/fs/cifs/file.c linux-2.6.35.y-512ac85/fs/cifs/file.c
*** 2.6.35/fs/cifs/file.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/cifs/file.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 796,807 ****
  
  		/* BB we could chain these into one lock request BB */
  		rc = CIFSSMBLock(xid, tcon, netfid, length, pfLock->fl_start,
! 				 0, 1, lockType, 0 /* wait flag */, 0);
  		if (rc == 0) {
  			rc = CIFSSMBLock(xid, tcon, netfid, length,
  					 pfLock->fl_start, 1 /* numUnlock */ ,
  					 0 /* numLock */ , lockType,
! 					 0 /* wait flag */, 0);
  			pfLock->fl_type = F_UNLCK;
  			if (rc != 0)
  				cERROR(1, "Error unlocking previously locked "
--- 796,807 ----
  
  		/* BB we could chain these into one lock request BB */
  		rc = CIFSSMBLock(xid, tcon, netfid, length, pfLock->fl_start,
! 				 0, 1, lockType, 0 /* wait flag */ );
  		if (rc == 0) {
  			rc = CIFSSMBLock(xid, tcon, netfid, length,
  					 pfLock->fl_start, 1 /* numUnlock */ ,
  					 0 /* numLock */ , lockType,
! 					 0 /* wait flag */ );
  			pfLock->fl_type = F_UNLCK;
  			if (rc != 0)
  				cERROR(1, "Error unlocking previously locked "
***************
*** 818,830 ****
  				rc = CIFSSMBLock(xid, tcon, netfid, length,
  					pfLock->fl_start, 0, 1,
  					lockType | LOCKING_ANDX_SHARED_LOCK,
! 					0 /* wait flag */, 0);
  				if (rc == 0) {
  					rc = CIFSSMBLock(xid, tcon, netfid,
  						length, pfLock->fl_start, 1, 0,
  						lockType |
  						LOCKING_ANDX_SHARED_LOCK,
! 						0 /* wait flag */, 0);
  					pfLock->fl_type = F_RDLCK;
  					if (rc != 0)
  						cERROR(1, "Error unlocking "
--- 818,830 ----
  				rc = CIFSSMBLock(xid, tcon, netfid, length,
  					pfLock->fl_start, 0, 1,
  					lockType | LOCKING_ANDX_SHARED_LOCK,
! 					0 /* wait flag */);
  				if (rc == 0) {
  					rc = CIFSSMBLock(xid, tcon, netfid,
  						length, pfLock->fl_start, 1, 0,
  						lockType |
  						LOCKING_ANDX_SHARED_LOCK,
! 						0 /* wait flag */);
  					pfLock->fl_type = F_RDLCK;
  					if (rc != 0)
  						cERROR(1, "Error unlocking "
***************
*** 868,875 ****
  
  		if (numLock) {
  			rc = CIFSSMBLock(xid, tcon, netfid, length,
! 					 pfLock->fl_start, 0, numLock, lockType,
! 					 wait_flag, 0);
  
  			if (rc == 0) {
  				/* For Windows locks we must store them. */
--- 868,875 ----
  
  		if (numLock) {
  			rc = CIFSSMBLock(xid, tcon, netfid, length,
! 					pfLock->fl_start,
! 					0, numLock, lockType, wait_flag);
  
  			if (rc == 0) {
  				/* For Windows locks we must store them. */
***************
*** 889,897 ****
  						(pfLock->fl_start + length) >=
  						(li->offset + li->length)) {
  					stored_rc = CIFSSMBLock(xid, tcon,
! 							netfid, li->length,
! 							li->offset, 1, 0,
! 							li->type, false, 0);
  					if (stored_rc)
  						rc = stored_rc;
  					else {
--- 889,897 ----
  						(pfLock->fl_start + length) >=
  						(li->offset + li->length)) {
  					stored_rc = CIFSSMBLock(xid, tcon,
! 							netfid,
! 							li->length, li->offset,
! 							1, 0, li->type, false);
  					if (stored_rc)
  						rc = stored_rc;
  					else {
***************
*** 2300,2307 ****
  	 */
  	if (!cfile->closePend && !cfile->oplock_break_cancelled) {
  		rc = CIFSSMBLock(0, cifs_sb->tcon, cfile->netfid, 0, 0, 0, 0,
! 				 LOCKING_ANDX_OPLOCK_RELEASE, false,
! 				 cinode->clientCanCacheRead ? 1 : 0);
  		cFYI(1, "Oplock release rc = %d", rc);
  	}
  }
--- 2300,2306 ----
  	 */
  	if (!cfile->closePend && !cfile->oplock_break_cancelled) {
  		rc = CIFSSMBLock(0, cifs_sb->tcon, cfile->netfid, 0, 0, 0, 0,
! 				 LOCKING_ANDX_OPLOCK_RELEASE, false);
  		cFYI(1, "Oplock release rc = %d", rc);
  	}
  }
diff -cBr 2.6.35/fs/cifs/inode.c linux-2.6.35.y-512ac85/fs/cifs/inode.c
*** 2.6.35/fs/cifs/inode.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/cifs/inode.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 804,813 ****
  		rc = cifs_get_inode_info(&inode, full_path, NULL, sb,
  						xid, NULL);
  
! 	if (!inode) {
! 		inode = ERR_PTR(rc);
! 		goto out;
! 	}
  
  	if (rc && cifs_sb->tcon->ipc) {
  		cFYI(1, "ipc connection - fake read inode");
--- 804,811 ----
  		rc = cifs_get_inode_info(&inode, full_path, NULL, sb,
  						xid, NULL);
  
! 	if (!inode)
! 		return ERR_PTR(-ENOMEM);
  
  	if (rc && cifs_sb->tcon->ipc) {
  		cFYI(1, "ipc connection - fake read inode");
***************
*** 818,828 ****
  		inode->i_uid = cifs_sb->mnt_uid;
  		inode->i_gid = cifs_sb->mnt_gid;
  	} else if (rc) {
  		iget_failed(inode);
! 		inode = ERR_PTR(rc);
  	}
  
! out:
  	kfree(full_path);
  	/* can not call macro FreeXid here since in a void func
  	 * TODO: This is no longer true
--- 816,828 ----
  		inode->i_uid = cifs_sb->mnt_uid;
  		inode->i_gid = cifs_sb->mnt_gid;
  	} else if (rc) {
+ 		kfree(full_path);
+ 		_FreeXid(xid);
  		iget_failed(inode);
! 		return ERR_PTR(rc);
  	}
  
! 
  	kfree(full_path);
  	/* can not call macro FreeXid here since in a void func
  	 * TODO: This is no longer true
diff -cBr 2.6.35/fs/compat.c linux-2.6.35.y-512ac85/fs/compat.c
*** 2.6.35/fs/compat.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/compat.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1376,1385 ****
  			argv++;
  			if (i++ >= max)
  				return -E2BIG;
- 
- 			if (fatal_signal_pending(current))
- 				return -ERESTARTNOHAND;
- 			cond_resched();
  		}
  	}
  	return i;
--- 1376,1381 ----
***************
*** 1421,1432 ****
  		while (len > 0) {
  			int offset, bytes_to_copy;
  
- 			if (fatal_signal_pending(current)) {
- 				ret = -ERESTARTNOHAND;
- 				goto out;
- 			}
- 			cond_resched();
- 
  			offset = pos % PAGE_SIZE;
  			if (offset == 0)
  				offset = PAGE_SIZE;
--- 1417,1422 ----
***************
*** 1443,1450 ****
  			if (!kmapped_page || kpos != (pos & PAGE_MASK)) {
  				struct page *page;
  
! 				page = get_arg_page(bprm, pos, 1);
! 				if (!page) {
  					ret = -E2BIG;
  					goto out;
  				}
--- 1433,1450 ----
  			if (!kmapped_page || kpos != (pos & PAGE_MASK)) {
  				struct page *page;
  
! #ifdef CONFIG_STACK_GROWSUP
! 				ret = expand_stack_downwards(bprm->vma, pos);
! 				if (ret < 0) {
! 					/* We've exceed the stack rlimit. */
! 					ret = -E2BIG;
! 					goto out;
! 				}
! #endif
! 				ret = get_user_pages(current, bprm->mm, pos,
! 						     1, 1, 1, &page, NULL);
! 				if (ret <= 0) {
! 					/* We've exceed the stack rlimit. */
  					ret = -E2BIG;
  					goto out;
  				}
***************
*** 1565,1574 ****
  	return retval;
  
  out:
! 	if (bprm->mm) {
! 		acct_arg_size(bprm, 0);
  		mmput(bprm->mm);
- 	}
  
  out_file:
  	if (bprm->file) {
--- 1565,1572 ----
  	return retval;
  
  out:
! 	if (bprm->mm)
  		mmput(bprm->mm);
  
  out_file:
  	if (bprm->file) {
diff -cBr 2.6.35/fs/dcache.c linux-2.6.35.y-512ac85/fs/dcache.c
*** 2.6.35/fs/dcache.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/dcache.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1186,1197 ****
  	spin_unlock(&tmp->d_lock);
  
  	spin_unlock(&dcache_lock);
- 	security_d_instantiate(tmp, inode);
  	return tmp;
  
   out_iput:
- 	if (res && !IS_ERR(res))
- 		security_d_instantiate(res, inode);
  	iput(inode);
  	return res;
  }
--- 1186,1194 ----
diff -cBr 2.6.35/fs/ecryptfs/inode.c linux-2.6.35.y-512ac85/fs/ecryptfs/inode.c
*** 2.6.35/fs/ecryptfs/inode.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ecryptfs/inode.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 32,38 ****
  #include <linux/crypto.h>
  #include <linux/fs_stack.h>
  #include <linux/slab.h>
- #include <linux/xattr.h>
  #include <asm/unaligned.h>
  #include "ecryptfs_kernel.h"
  
--- 32,37 ----
***************
*** 71,89 ****
  	struct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
  	struct dentry *dentry_save;
  	struct vfsmount *vfsmount_save;
- 	unsigned int flags_save;
  	int rc;
  
  	dentry_save = nd->path.dentry;
  	vfsmount_save = nd->path.mnt;
- 	flags_save = nd->flags;
  	nd->path.dentry = lower_dentry;
  	nd->path.mnt = lower_mnt;
- 	nd->flags &= ~LOOKUP_OPEN;
  	rc = vfs_create(lower_dir_inode, lower_dentry, mode, nd);
  	nd->path.dentry = dentry_save;
  	nd->path.mnt = vfsmount_save;
- 	nd->flags = flags_save;
  	return rc;
  }
  
--- 70,84 ----
***************
*** 1003,1010 ****
  	rc = vfs_getattr(ecryptfs_dentry_to_lower_mnt(dentry),
  			 ecryptfs_dentry_to_lower(dentry), &lower_stat);
  	if (!rc) {
- 		fsstack_copy_attr_all(dentry->d_inode,
- 				      ecryptfs_inode_to_lower(dentry->d_inode));
  		generic_fillattr(dentry->d_inode, stat);
  		stat->blocks = lower_stat.blocks;
  	}
--- 998,1003 ----
***************
*** 1023,1030 ****
  		rc = -EOPNOTSUPP;
  		goto out;
  	}
! 
! 	rc = vfs_setxattr(lower_dentry, name, value, size, flags);
  out:
  	return rc;
  }
--- 1016,1025 ----
  		rc = -EOPNOTSUPP;
  		goto out;
  	}
! 	mutex_lock(&lower_dentry->d_inode->i_mutex);
! 	rc = lower_dentry->d_inode->i_op->setxattr(lower_dentry, name, value,
! 						   size, flags);
! 	mutex_unlock(&lower_dentry->d_inode->i_mutex);
  out:
  	return rc;
  }
diff -cBr 2.6.35/fs/ecryptfs/keystore.c linux-2.6.35.y-512ac85/fs/ecryptfs/keystore.c
*** 2.6.35/fs/ecryptfs/keystore.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ecryptfs/keystore.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1543,1549 ****
  		printk(KERN_ERR "Could not find key with description: [%s]\n",
  		       sig);
  		rc = process_request_key_err(PTR_ERR(*auth_tok_key));
- 		(*auth_tok_key) = NULL;
  		goto out;
  	}
  	(*auth_tok) = ecryptfs_get_key_payload_data(*auth_tok_key);
--- 1543,1548 ----
diff -cBr 2.6.35/fs/ecryptfs/mmap.c linux-2.6.35.y-512ac85/fs/ecryptfs/mmap.c
*** 2.6.35/fs/ecryptfs/mmap.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ecryptfs/mmap.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 368,378 ****
  	    && (pos != 0))
  		zero_user(page, 0, PAGE_CACHE_SIZE);
  out:
- 	if (unlikely(rc)) {
- 		unlock_page(page);
- 		page_cache_release(page);
- 		*pagep = NULL;
- 	}
  	return rc;
  }
  
--- 368,373 ----
diff -cBr 2.6.35/fs/eventpoll.c linux-2.6.35.y-512ac85/fs/eventpoll.c
*** 2.6.35/fs/eventpoll.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/eventpoll.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 63,75 ****
   * cleanup path and it is also acquired by eventpoll_release_file()
   * if a file has been pushed inside an epoll set and it is then
   * close()d without a previous call toepoll_ctl(EPOLL_CTL_DEL).
-  * It is also acquired when inserting an epoll fd onto another epoll
-  * fd. We do this so that we walk the epoll tree and ensure that this
-  * insertion does not create a cycle of epoll file descriptors, which
-  * could lead to deadlock. We need a global mutex to prevent two
-  * simultaneous inserts (A into B and B into A) from racing and
-  * constructing a cycle without either insert observing that it is
-  * going to.
   * It is possible to drop the "ep->mtx" and to use the global
   * mutex "epmutex" (together with "ep->lock") to have it working,
   * but having "ep->mtx" will make the interface more scalable.
--- 63,68 ----
***************
*** 234,242 ****
   */
  static DEFINE_MUTEX(epmutex);
  
- /* Used to check for epoll file descriptor inclusion loops */
- static struct nested_calls poll_loop_ncalls;
- 
  /* Used for safe wake up implementation */
  static struct nested_calls poll_safewake_ncalls;
  
--- 227,232 ----
***************
*** 1191,1252 ****
  	return res;
  }
  
- /**
-  * ep_loop_check_proc - Callback function to be passed to the @ep_call_nested()
-  *                      API, to verify that adding an epoll file inside another
-  *                      epoll structure, does not violate the constraints, in
-  *                      terms of closed loops, or too deep chains (which can
-  *                      result in excessive stack usage).
-  *
-  * @priv: Pointer to the epoll file to be currently checked.
-  * @cookie: Original cookie for this call. This is the top-of-the-chain epoll
-  *          data structure pointer.
-  * @call_nests: Current dept of the @ep_call_nested() call stack.
-  *
-  * Returns: Returns zero if adding the epoll @file inside current epoll
-  *          structure @ep does not violate the constraints, or -1 otherwise.
-  */
- static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)
- {
- 	int error = 0;
- 	struct file *file = priv;
- 	struct eventpoll *ep = file->private_data;
- 	struct rb_node *rbp;
- 	struct epitem *epi;
- 
- 	mutex_lock(&ep->mtx);
- 	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
- 		epi = rb_entry(rbp, struct epitem, rbn);
- 		if (unlikely(is_file_epoll(epi->ffd.file))) {
- 			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
- 					       ep_loop_check_proc, epi->ffd.file,
- 					       epi->ffd.file->private_data, current);
- 			if (error != 0)
- 				break;
- 		}
- 	}
- 	mutex_unlock(&ep->mtx);
- 
- 	return error;
- }
- 
- /**
-  * ep_loop_check - Performs a check to verify that adding an epoll file (@file)
-  *                 another epoll file (represented by @ep) does not create
-  *                 closed loops or too deep chains.
-  *
-  * @ep: Pointer to the epoll private data structure.
-  * @file: Pointer to the epoll file to be checked.
-  *
-  * Returns: Returns zero if adding the epoll @file inside current epoll
-  *          structure @ep does not violate the constraints, or -1 otherwise.
-  */
- static int ep_loop_check(struct eventpoll *ep, struct file *file)
- {
- 	return ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
- 			      ep_loop_check_proc, file, ep, current);
- }
- 
  /*
   * Open an eventpoll file descriptor.
   */
--- 1181,1186 ----
***************
*** 1295,1301 ****
  		struct epoll_event __user *, event)
  {
  	int error;
- 	int did_lock_epmutex = 0;
  	struct file *file, *tfile;
  	struct eventpoll *ep;
  	struct epitem *epi;
--- 1229,1234 ----
***************
*** 1337,1361 ****
  	 */
  	ep = file->private_data;
  
- 	/*
- 	 * When we insert an epoll file descriptor, inside another epoll file
- 	 * descriptor, there is the change of creating closed loops, which are
- 	 * better be handled here, than in more critical paths.
- 	 *
- 	 * We hold epmutex across the loop check and the insert in this case, in
- 	 * order to prevent two separate inserts from racing and each doing the
- 	 * insert "at the same time" such that ep_loop_check passes on both
- 	 * before either one does the insert, thereby creating a cycle.
- 	 */
- 	if (unlikely(is_file_epoll(tfile) && op == EPOLL_CTL_ADD)) {
- 		mutex_lock(&epmutex);
- 		did_lock_epmutex = 1;
- 		error = -ELOOP;
- 		if (ep_loop_check(ep, tfile) != 0)
- 			goto error_tgt_fput;
- 	}
- 
- 
  	mutex_lock(&ep->mtx);
  
  	/*
--- 1270,1275 ----
***************
*** 1391,1399 ****
  	mutex_unlock(&ep->mtx);
  
  error_tgt_fput:
- 	if (unlikely(did_lock_epmutex))
- 		mutex_unlock(&epmutex);
- 
  	fput(tfile);
  error_fput:
  	fput(file);
--- 1305,1310 ----
***************
*** 1512,1523 ****
  	max_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /
  		EP_ITEM_COST;
  
- 	/*
- 	 * Initialize the structure used to perform epoll file descriptor
- 	 * inclusion loops checks.
- 	 */
- 	ep_nested_calls_init(&poll_loop_ncalls);
- 
  	/* Initialize the structure used to perform safe poll wait head wake ups */
  	ep_nested_calls_init(&poll_safewake_ncalls);
  
--- 1423,1428 ----
diff -cBr 2.6.35/fs/exec.c linux-2.6.35.y-512ac85/fs/exec.c
*** 2.6.35/fs/exec.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/exec.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 158,179 ****
  
  #ifdef CONFIG_MMU
  
! void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
! {
! 	struct mm_struct *mm = current->mm;
! 	long diff = (long)(pages - bprm->vma_pages);
! 
! 	if (!mm || !diff)
! 		return;
! 
! 	bprm->vma_pages = pages;
! 
! 	down_write(&mm->mmap_sem);
! 	mm->total_vm += diff;
! 	up_write(&mm->mmap_sem);
! }
! 
! struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
  		int write)
  {
  	struct page *page;
--- 158,164 ----
  
  #ifdef CONFIG_MMU
  
! static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
  		int write)
  {
  	struct page *page;
***************
*** 195,202 ****
  		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;
  		struct rlimit *rlim;
  
- 		acct_arg_size(bprm, size / PAGE_SIZE);
- 
  		/*
  		 * We've historically supported up to 32 pages (ARG_MAX)
  		 * of argument strings even with small stacks
--- 180,185 ----
***************
*** 265,275 ****
  	vma->vm_flags = VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;
  	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
  	INIT_LIST_HEAD(&vma->anon_vma_chain);
- 
- 	err = security_file_mmap(NULL, 0, 0, 0, vma->vm_start, 1);
- 	if (err)
- 		goto err;
- 
  	err = insert_vm_struct(mm, vma);
  	if (err)
  		goto err;
--- 248,253 ----
***************
*** 292,302 ****
  
  #else
  
! void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
! {
! }
! 
! struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
  		int write)
  {
  	struct page *page;
--- 270,276 ----
  
  #else
  
! static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
  		int write)
  {
  	struct page *page;
***************
*** 1017,1023 ****
  	/*
  	 * Release all of the old mmap stuff
  	 */
- 	acct_arg_size(bprm, 0);
  	retval = exec_mmap(bprm->mm);
  	if (retval)
  		goto out;
--- 991,996 ----
***************
*** 1442,1451 ****
  	return retval;
  
  out:
! 	if (bprm->mm) {
! 		acct_arg_size(bprm, 0);
! 		mmput(bprm->mm);
! 	}
  
  out_file:
  	if (bprm->file) {
--- 1415,1422 ----
  	return retval;
  
  out:
! 	if (bprm->mm)
! 		mmput (bprm->mm);
  
  out_file:
  	if (bprm->file) {
diff -cBr 2.6.35/fs/ext2/namei.c linux-2.6.35.y-512ac85/fs/ext2/namei.c
*** 2.6.35/fs/ext2/namei.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ext2/namei.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 344,349 ****
--- 344,350 ----
  		new_de = ext2_find_entry (new_dir, &new_dentry->d_name, &new_page);
  		if (!new_de)
  			goto out_dir;
+ 		inode_inc_link_count(old_inode);
  		ext2_set_link(new_dir, new_de, new_page, old_inode, 1);
  		new_inode->i_ctime = CURRENT_TIME_SEC;
  		if (dir_de)
***************
*** 355,363 ****
  			if (new_dir->i_nlink >= EXT2_LINK_MAX)
  				goto out_dir;
  		}
  		err = ext2_add_link(new_dentry, old_inode);
! 		if (err)
  			goto out_dir;
  		if (dir_de)
  			inode_inc_link_count(new_dir);
  	}
--- 356,367 ----
  			if (new_dir->i_nlink >= EXT2_LINK_MAX)
  				goto out_dir;
  		}
+ 		inode_inc_link_count(old_inode);
  		err = ext2_add_link(new_dentry, old_inode);
! 		if (err) {
! 			inode_dec_link_count(old_inode);
  			goto out_dir;
+ 		}
  		if (dir_de)
  			inode_inc_link_count(new_dir);
  	}
***************
*** 365,375 ****
  	/*
  	 * Like most other Unix systems, set the ctime for inodes on a
   	 * rename.
  	 */
  	old_inode->i_ctime = CURRENT_TIME_SEC;
- 	mark_inode_dirty(old_inode);
  
  	ext2_delete_entry (old_de, old_page);
  
  	if (dir_de) {
  		if (old_dir != new_dir)
--- 369,380 ----
  	/*
  	 * Like most other Unix systems, set the ctime for inodes on a
   	 * rename.
+ 	 * inode_dec_link_count() will mark the inode dirty.
  	 */
  	old_inode->i_ctime = CURRENT_TIME_SEC;
  
  	ext2_delete_entry (old_de, old_page);
+ 	inode_dec_link_count(old_inode);
  
  	if (dir_de) {
  		if (old_dir != new_dir)
diff -cBr 2.6.35/fs/ext3/namei.c linux-2.6.35.y-512ac85/fs/ext3/namei.c
*** 2.6.35/fs/ext3/namei.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ext3/namei.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1550,1557 ****
  			goto cleanup;
  		node2 = (struct dx_node *)(bh2->b_data);
  		entries2 = node2->entries;
- 		memset(&node2->fake, 0, sizeof(struct fake_dirent));
  		node2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);
  		BUFFER_TRACE(frame->bh, "get_write_access");
  		err = ext3_journal_get_write_access(handle, frame->bh);
  		if (err)
--- 1550,1557 ----
  			goto cleanup;
  		node2 = (struct dx_node *)(bh2->b_data);
  		entries2 = node2->entries;
  		node2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);
+ 		node2->fake.inode = 0;
  		BUFFER_TRACE(frame->bh, "get_write_access");
  		err = ext3_journal_get_write_access(handle, frame->bh);
  		if (err)
diff -cBr 2.6.35/fs/ext3/super.c linux-2.6.35.y-512ac85/fs/ext3/super.c
*** 2.6.35/fs/ext3/super.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ext3/super.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1459,1471 ****
  		return;
  	}
  
- 	/* Check if feature set allows readwrite operations */
- 	if (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {
- 		printk(KERN_INFO "EXT3-fs: %s: Skipping orphan cleanup due to "
- 			 "unknown ROCOMPAT features\n", sb->s_id);
- 		return;
- 	}
- 
  	if (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {
  		if (es->s_last_orphan)
  			jbd_debug(1, "Errors on filesystem, "
--- 1459,1464 ----
diff -cBr 2.6.35/fs/ext4/inode.c linux-2.6.35.y-512ac85/fs/ext4/inode.c
*** 2.6.35/fs/ext4/inode.c	2011-05-07 19:57:18.486750002 -0400
--- linux-2.6.35.y-512ac85/fs/ext4/inode.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 5593,5604 ****
  	/* if nrblocks are contiguous */
  	if (chunk) {
  		/*
! 		 * With N contiguous data blocks, we need at most
! 		 * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,
! 		 * 2 dindirect blocks, and 1 tindirect block
  		 */
! 		return DIV_ROUND_UP(nrblocks,
! 				    EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;
  	}
  	/*
  	 * if nrblocks are not contiguous, worse case, each block touch
--- 5593,5605 ----
  	/* if nrblocks are contiguous */
  	if (chunk) {
  		/*
! 		 * With N contiguous data blocks, it need at most
! 		 * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) indirect blocks
! 		 * 2 dindirect blocks
! 		 * 1 tindirect block
  		 */
! 		indirects = nrblocks / EXT4_ADDR_PER_BLOCK(inode->i_sb);
! 		return indirects + 3;
  	}
  	/*
  	 * if nrblocks are not contiguous, worse case, each block touch
diff -cBr 2.6.35/fs/file_table.c linux-2.6.35.y-512ac85/fs/file_table.c
*** 2.6.35/fs/file_table.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/file_table.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 123,135 ****
  		goto fail;
  
  	percpu_counter_inc(&nr_files);
- 	f->f_cred = get_cred(cred);
  	if (security_file_alloc(f))
  		goto fail_sec;
  
  	INIT_LIST_HEAD(&f->f_u.fu_list);
  	atomic_long_set(&f->f_count, 1);
  	rwlock_init(&f->f_owner.lock);
  	spin_lock_init(&f->f_lock);
  	eventpoll_init_file(f);
  	/* f->f_version: 0 */
--- 123,135 ----
  		goto fail;
  
  	percpu_counter_inc(&nr_files);
  	if (security_file_alloc(f))
  		goto fail_sec;
  
  	INIT_LIST_HEAD(&f->f_u.fu_list);
  	atomic_long_set(&f->f_count, 1);
  	rwlock_init(&f->f_owner.lock);
+ 	f->f_cred = get_cred(cred);
  	spin_lock_init(&f->f_lock);
  	eventpoll_init_file(f);
  	/* f->f_version: 0 */
diff -cBr 2.6.35/fs/fuse/file.c linux-2.6.35.y-512ac85/fs/fuse/file.c
*** 2.6.35/fs/fuse/file.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/fuse/file.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 13,19 ****
  #include <linux/kernel.h>
  #include <linux/sched.h>
  #include <linux/module.h>
- #include <linux/compat.h>
  
  static const struct file_operations fuse_direct_io_file_operations;
  
--- 13,18 ----
***************
*** 86,137 ****
  	return ff;
  }
  
- static void fuse_release_async(struct work_struct *work)
- {
- 	struct fuse_req *req;
- 	struct fuse_conn *fc;
- 	struct path path;
- 
- 	req = container_of(work, struct fuse_req, misc.release.work);
- 	path = req->misc.release.path;
- 	fc = get_fuse_conn(path.dentry->d_inode);
- 
- 	fuse_put_request(fc, req);
- 	path_put(&path);
- }
- 
  static void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)
  {
! 	if (fc->destroy_req) {
! 		/*
! 		 * If this is a fuseblk mount, then it's possible that
! 		 * releasing the path will result in releasing the
! 		 * super block and sending the DESTROY request.  If
! 		 * the server is single threaded, this would hang.
! 		 * For this reason do the path_put() in a separate
! 		 * thread.
! 		 */
! 		atomic_inc(&req->count);
! 		INIT_WORK(&req->misc.release.work, fuse_release_async);
! 		schedule_work(&req->misc.release.work);
! 	} else {
! 		path_put(&req->misc.release.path);
! 	}
  }
  
! static void fuse_file_put(struct fuse_file *ff, bool sync)
  {
  	if (atomic_dec_and_test(&ff->count)) {
  		struct fuse_req *req = ff->reserved_req;
  
! 		if (sync) {
! 			fuse_request_send(ff->fc, req);
! 			path_put(&req->misc.release.path);
! 			fuse_put_request(ff->fc, req);
! 		} else {
! 			req->end = fuse_release_end;
! 			fuse_request_send_background(ff->fc, req);
! 		}
  		kfree(ff);
  	}
  }
--- 85,102 ----
  	return ff;
  }
  
  static void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)
  {
! 	path_put(&req->misc.release.path);
  }
  
! static void fuse_file_put(struct fuse_file *ff)
  {
  	if (atomic_dec_and_test(&ff->count)) {
  		struct fuse_req *req = ff->reserved_req;
  
! 		req->end = fuse_release_end;
! 		fuse_request_send_background(ff->fc, req);
  		kfree(ff);
  	}
  }
***************
*** 169,175 ****
  void fuse_finish_open(struct inode *inode, struct file *file)
  {
  	struct fuse_file *ff = file->private_data;
- 	struct fuse_conn *fc = get_fuse_conn(inode);
  
  	if (ff->open_flags & FOPEN_DIRECT_IO)
  		file->f_op = &fuse_direct_io_file_operations;
--- 134,139 ----
***************
*** 177,191 ****
  		invalidate_inode_pages2(inode->i_mapping);
  	if (ff->open_flags & FOPEN_NONSEEKABLE)
  		nonseekable_open(inode, file);
- 	if (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {
- 		struct fuse_inode *fi = get_fuse_inode(inode);
- 
- 		spin_lock(&fc->lock);
- 		fi->attr_version = ++fc->attr_version;
- 		i_size_write(inode, 0);
- 		spin_unlock(&fc->lock);
- 		fuse_invalidate_attr(inode);
- 	}
  }
  
  int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
--- 141,146 ----
***************
*** 253,264 ****
  	 * Normally this will send the RELEASE request, however if
  	 * some asynchronous READ or WRITE requests are outstanding,
  	 * the sending will be delayed.
- 	 *
- 	 * Make the release synchronous if this is a fuseblk mount,
- 	 * synchronous RELEASE is allowed (and desirable) in this case
- 	 * because the server can be trusted not to screw up.
  	 */
! 	fuse_file_put(ff, ff->fc->destroy_req != NULL);
  }
  
  static int fuse_open(struct inode *inode, struct file *file)
--- 208,215 ----
  	 * Normally this will send the RELEASE request, however if
  	 * some asynchronous READ or WRITE requests are outstanding,
  	 * the sending will be delayed.
  	 */
! 	fuse_file_put(ff);
  }
  
  static int fuse_open(struct inode *inode, struct file *file)
***************
*** 596,602 ****
  		page_cache_release(page);
  	}
  	if (req->ff)
! 		fuse_file_put(req->ff, false);
  }
  
  static void fuse_send_readpages(struct fuse_req *req, struct file *file)
--- 547,553 ----
  		page_cache_release(page);
  	}
  	if (req->ff)
! 		fuse_file_put(req->ff);
  }
  
  static void fuse_send_readpages(struct fuse_req *req, struct file *file)
***************
*** 1175,1181 ****
  static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)
  {
  	__free_page(req->pages[0]);
! 	fuse_file_put(req->ff, false);
  }
  
  static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)
--- 1126,1132 ----
  static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)
  {
  	__free_page(req->pages[0]);
! 	fuse_file_put(req->ff);
  }
  
  static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)
***************
*** 1666,1723 ****
  	return 0;
  }
  
- /* Make sure iov_length() won't overflow */
- static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)
- {
- 	size_t n;
- 	u32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;
- 
- 	for (n = 0; n < count; n++) {
- 		if (iov->iov_len > (size_t) max)
- 			return -ENOMEM;
- 		max -= iov->iov_len;
- 	}
- 	return 0;
- }
- 
- /*
-  * CUSE servers compiled on 32bit broke on 64bit kernels because the
-  * ABI was defined to be 'struct iovec' which is different on 32bit
-  * and 64bit.  Fortunately we can determine which structure the server
-  * used from the size of the reply.
-  */
- static int fuse_copy_ioctl_iovec(struct iovec *dst, void *src,
- 				 size_t transferred, unsigned count,
- 				 bool is_compat)
- {
- #ifdef CONFIG_COMPAT
- 	if (count * sizeof(struct compat_iovec) == transferred) {
- 		struct compat_iovec *ciov = src;
- 		unsigned i;
- 
- 		/*
- 		 * With this interface a 32bit server cannot support
- 		 * non-compat (i.e. ones coming from 64bit apps) ioctl
- 		 * requests
- 		 */
- 		if (!is_compat)
- 			return -EINVAL;
- 
- 		for (i = 0; i < count; i++) {
- 			dst[i].iov_base = compat_ptr(ciov[i].iov_base);
- 			dst[i].iov_len = ciov[i].iov_len;
- 		}
- 		return 0;
- 	}
- #endif
- 
- 	if (count * sizeof(struct iovec) != transferred)
- 		return -EIO;
- 
- 	memcpy(dst, src, transferred);
- 	return 0;
- }
- 
  /*
   * For ioctls, there is no generic way to determine how much memory
   * needs to be read and/or written.  Furthermore, ioctls are allowed
--- 1617,1622 ----
***************
*** 1899,1923 ****
  		    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)
  			goto out;
  
  		vaddr = kmap_atomic(pages[0], KM_USER0);
! 		err = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,
! 					    transferred, in_iovs + out_iovs,
! 					    (flags & FUSE_IOCTL_COMPAT) != 0);
  		kunmap_atomic(vaddr, KM_USER0);
- 		if (err)
- 			goto out;
  
  		in_iov = page_address(iov_page);
  		out_iov = in_iov + in_iovs;
  
- 		err = fuse_verify_ioctl_iov(in_iov, in_iovs);
- 		if (err)
- 			goto out;
- 
- 		err = fuse_verify_ioctl_iov(out_iov, out_iovs);
- 		if (err)
- 			goto out;
- 
  		goto retry;
  	}
  
--- 1798,1815 ----
  		    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)
  			goto out;
  
+ 		err = -EIO;
+ 		if ((in_iovs + out_iovs) * sizeof(struct iovec) != transferred)
+ 			goto out;
+ 
+ 		/* okay, copy in iovs and retry */
  		vaddr = kmap_atomic(pages[0], KM_USER0);
! 		memcpy(page_address(iov_page), vaddr, transferred);
  		kunmap_atomic(vaddr, KM_USER0);
  
  		in_iov = page_address(iov_page);
  		out_iov = in_iov + in_iovs;
  
  		goto retry;
  	}
  
diff -cBr 2.6.35/fs/fuse/fuse_i.h linux-2.6.35.y-512ac85/fs/fuse/fuse_i.h
*** 2.6.35/fs/fuse/fuse_i.h	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/fuse/fuse_i.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 21,27 ****
  #include <linux/rwsem.h>
  #include <linux/rbtree.h>
  #include <linux/poll.h>
- #include <linux/workqueue.h>
  
  /** Max number of pages that can be used in a single read request */
  #define FUSE_MAX_PAGES_PER_REQ 32
--- 21,26 ----
***************
*** 258,267 ****
  	union {
  		struct fuse_forget_in forget_in;
  		struct {
! 			union {
! 				struct fuse_release_in in;
! 				struct work_struct work;
! 			};
  			struct path path;
  		} release;
  		struct fuse_init_in init_in;
--- 257,263 ----
  	union {
  		struct fuse_forget_in forget_in;
  		struct {
! 			struct fuse_release_in in;
  			struct path path;
  		} release;
  		struct fuse_init_in init_in;
diff -cBr 2.6.35/fs/nfs/direct.c linux-2.6.35.y-512ac85/fs/nfs/direct.c
*** 2.6.35/fs/nfs/direct.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/direct.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 402,419 ****
  		pos += vec->iov_len;
  	}
  
- 	/*
- 	 * If no bytes were started, return the error, and let the
- 	 * generic layer handle the completion.
- 	 */
- 	if (requested_bytes == 0) {
- 		nfs_direct_req_release(dreq);
- 		return result < 0 ? result : -EIO;
- 	}
- 
  	if (put_dreq(dreq))
  		nfs_direct_complete(dreq);
! 	return 0;
  }
  
  static ssize_t nfs_direct_read(struct kiocb *iocb, const struct iovec *iov,
--- 402,416 ----
  		pos += vec->iov_len;
  	}
  
  	if (put_dreq(dreq))
  		nfs_direct_complete(dreq);
! 
! 	if (requested_bytes != 0)
! 		return 0;
! 
! 	if (result < 0)
! 		return result;
! 	return -EIO;
  }
  
  static ssize_t nfs_direct_read(struct kiocb *iocb, const struct iovec *iov,
***************
*** 833,850 ****
  		pos += vec->iov_len;
  	}
  
- 	/*
- 	 * If no bytes were started, return the error, and let the
- 	 * generic layer handle the completion.
- 	 */
- 	if (requested_bytes == 0) {
- 		nfs_direct_req_release(dreq);
- 		return result < 0 ? result : -EIO;
- 	}
- 
  	if (put_dreq(dreq))
  		nfs_direct_write_complete(dreq, dreq->inode);
! 	return 0;
  }
  
  static ssize_t nfs_direct_write(struct kiocb *iocb, const struct iovec *iov,
--- 830,844 ----
  		pos += vec->iov_len;
  	}
  
  	if (put_dreq(dreq))
  		nfs_direct_write_complete(dreq, dreq->inode);
! 
! 	if (requested_bytes != 0)
! 		return 0;
! 
! 	if (result < 0)
! 		return result;
! 	return -EIO;
  }
  
  static ssize_t nfs_direct_write(struct kiocb *iocb, const struct iovec *iov,
diff -cBr 2.6.35/fs/nfs/file.c linux-2.6.35.y-512ac85/fs/nfs/file.c
*** 2.6.35/fs/nfs/file.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/file.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 222,228 ****
  	have_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);
  	if (have_error)
  		ret = xchg(&ctx->error, 0);
! 	if (!ret && status < 0)
  		ret = status;
  	return ret;
  }
--- 222,228 ----
  	have_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);
  	if (have_error)
  		ret = xchg(&ctx->error, 0);
! 	if (!ret)
  		ret = status;
  	return ret;
  }
***************
*** 560,566 ****
  	struct file *filp = vma->vm_file;
  	struct dentry *dentry = filp->f_path.dentry;
  	unsigned pagelen;
! 	int ret = VM_FAULT_NOPAGE;
  	struct address_space *mapping;
  
  	dfprintk(PAGECACHE, "NFS: vm_page_mkwrite(%s/%s(%ld), offset %lld)\n",
--- 560,566 ----
  	struct file *filp = vma->vm_file;
  	struct dentry *dentry = filp->f_path.dentry;
  	unsigned pagelen;
! 	int ret = -EINVAL;
  	struct address_space *mapping;
  
  	dfprintk(PAGECACHE, "NFS: vm_page_mkwrite(%s/%s(%ld), offset %lld)\n",
***************
*** 576,595 ****
  	if (mapping != dentry->d_inode->i_mapping)
  		goto out_unlock;
  
  	pagelen = nfs_page_length(page);
  	if (pagelen == 0)
  		goto out_unlock;
  
! 	ret = VM_FAULT_LOCKED;
! 	if (nfs_flush_incompatible(filp, page) == 0 &&
! 	    nfs_updatepage(filp, page, 0, pagelen) == 0)
! 		goto out;
  
! 	ret = VM_FAULT_SIGBUS;
  out_unlock:
  	unlock_page(page);
! out:
! 	return ret;
  }
  
  static const struct vm_operations_struct nfs_file_vm_ops = {
--- 576,596 ----
  	if (mapping != dentry->d_inode->i_mapping)
  		goto out_unlock;
  
+ 	ret = 0;
  	pagelen = nfs_page_length(page);
  	if (pagelen == 0)
  		goto out_unlock;
  
! 	ret = nfs_flush_incompatible(filp, page);
! 	if (ret != 0)
! 		goto out_unlock;
  
! 	ret = nfs_updatepage(filp, page, 0, pagelen);
  out_unlock:
+ 	if (!ret)
+ 		return VM_FAULT_LOCKED;
  	unlock_page(page);
! 	return VM_FAULT_SIGBUS;
  }
  
  static const struct vm_operations_struct nfs_file_vm_ops = {
***************
*** 696,702 ****
  {
  	struct inode *inode = filp->f_mapping->host;
  	int status = 0;
- 	unsigned int saved_type = fl->fl_type;
  
  	/* Try local locking first */
  	posix_test_lock(filp, fl);
--- 697,702 ----
***************
*** 704,710 ****
  		/* found a conflict */
  		goto out;
  	}
- 	fl->fl_type = saved_type;
  
  	if (nfs_have_delegation(inode, FMODE_READ))
  		goto out_noconflict;
--- 704,709 ----
diff -cBr 2.6.35/fs/nfs/inode.c linux-2.6.35.y-512ac85/fs/nfs/inode.c
*** 2.6.35/fs/nfs/inode.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/inode.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 811,820 ****
  	return ret;
  }
  
! static unsigned long nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)
  {
  	struct nfs_inode *nfsi = NFS_I(inode);
- 	unsigned long ret = 0;
  
  	if ((fattr->valid & NFS_ATTR_FATTR_PRECHANGE)
  			&& (fattr->valid & NFS_ATTR_FATTR_CHANGE)
--- 811,819 ----
  	return ret;
  }
  
! static void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)
  {
  	struct nfs_inode *nfsi = NFS_I(inode);
  
  	if ((fattr->valid & NFS_ATTR_FATTR_PRECHANGE)
  			&& (fattr->valid & NFS_ATTR_FATTR_CHANGE)
***************
*** 822,853 ****
  		nfsi->change_attr = fattr->change_attr;
  		if (S_ISDIR(inode->i_mode))
  			nfsi->cache_validity |= NFS_INO_INVALID_DATA;
- 		ret |= NFS_INO_INVALID_ATTR;
  	}
  	/* If we have atomic WCC data, we may update some attributes */
  	if ((fattr->valid & NFS_ATTR_FATTR_PRECTIME)
  			&& (fattr->valid & NFS_ATTR_FATTR_CTIME)
! 			&& timespec_equal(&inode->i_ctime, &fattr->pre_ctime)) {
! 		memcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));
! 		ret |= NFS_INO_INVALID_ATTR;
! 	}
  
  	if ((fattr->valid & NFS_ATTR_FATTR_PREMTIME)
  			&& (fattr->valid & NFS_ATTR_FATTR_MTIME)
  			&& timespec_equal(&inode->i_mtime, &fattr->pre_mtime)) {
! 		memcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));
! 		if (S_ISDIR(inode->i_mode))
! 			nfsi->cache_validity |= NFS_INO_INVALID_DATA;
! 		ret |= NFS_INO_INVALID_ATTR;
  	}
  	if ((fattr->valid & NFS_ATTR_FATTR_PRESIZE)
  			&& (fattr->valid & NFS_ATTR_FATTR_SIZE)
  			&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)
! 			&& nfsi->npages == 0) {
! 		i_size_write(inode, nfs_size_to_loff_t(fattr->size));
! 		ret |= NFS_INO_INVALID_ATTR;
! 	}
! 	return ret;
  }
  
  /**
--- 821,845 ----
  		nfsi->change_attr = fattr->change_attr;
  		if (S_ISDIR(inode->i_mode))
  			nfsi->cache_validity |= NFS_INO_INVALID_DATA;
  	}
  	/* If we have atomic WCC data, we may update some attributes */
  	if ((fattr->valid & NFS_ATTR_FATTR_PRECTIME)
  			&& (fattr->valid & NFS_ATTR_FATTR_CTIME)
! 			&& timespec_equal(&inode->i_ctime, &fattr->pre_ctime))
! 			memcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));
  
  	if ((fattr->valid & NFS_ATTR_FATTR_PREMTIME)
  			&& (fattr->valid & NFS_ATTR_FATTR_MTIME)
  			&& timespec_equal(&inode->i_mtime, &fattr->pre_mtime)) {
! 			memcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));
! 			if (S_ISDIR(inode->i_mode))
! 				nfsi->cache_validity |= NFS_INO_INVALID_DATA;
  	}
  	if ((fattr->valid & NFS_ATTR_FATTR_PRESIZE)
  			&& (fattr->valid & NFS_ATTR_FATTR_SIZE)
  			&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)
! 			&& nfsi->npages == 0)
! 			i_size_write(inode, nfs_size_to_loff_t(fattr->size));
  }
  
  /**
***************
*** 1161,1167 ****
  			| NFS_INO_REVAL_PAGECACHE);
  
  	/* Do atomic weak cache consistency updates */
! 	invalid |= nfs_wcc_update_inode(inode, fattr);
  
  	/* More cache consistency checks */
  	if (fattr->valid & NFS_ATTR_FATTR_CHANGE) {
--- 1153,1159 ----
  			| NFS_INO_REVAL_PAGECACHE);
  
  	/* Do atomic weak cache consistency updates */
! 	nfs_wcc_update_inode(inode, fattr);
  
  	/* More cache consistency checks */
  	if (fattr->valid & NFS_ATTR_FATTR_CHANGE) {
diff -cBr 2.6.35/fs/nfs/mount_clnt.c linux-2.6.35.y-512ac85/fs/nfs/mount_clnt.c
*** 2.6.35/fs/nfs/mount_clnt.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/mount_clnt.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 503,515 ****
  
  static struct rpc_version mnt_version1 = {
  	.number		= 1,
! 	.nrprocs	= ARRAY_SIZE(mnt_procedures),
  	.procs		= mnt_procedures,
  };
  
  static struct rpc_version mnt_version3 = {
  	.number		= 3,
! 	.nrprocs	= ARRAY_SIZE(mnt3_procedures),
  	.procs		= mnt3_procedures,
  };
  
--- 503,515 ----
  
  static struct rpc_version mnt_version1 = {
  	.number		= 1,
! 	.nrprocs	= 2,
  	.procs		= mnt_procedures,
  };
  
  static struct rpc_version mnt_version3 = {
  	.number		= 3,
! 	.nrprocs	= 2,
  	.procs		= mnt3_procedures,
  };
  
diff -cBr 2.6.35/fs/nfs/nfs4proc.c linux-2.6.35.y-512ac85/fs/nfs/nfs4proc.c
*** 2.6.35/fs/nfs/nfs4proc.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/nfs4proc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 255,260 ****
--- 255,263 ----
  			nfs4_state_mark_reclaim_nograce(clp, state);
  			goto do_state_recovery;
  		case -NFS4ERR_STALE_STATEID:
+ 			if (state == NULL)
+ 				break;
+ 			nfs4_state_mark_reclaim_reboot(clp, state);
  		case -NFS4ERR_STALE_CLIENTID:
  		case -NFS4ERR_EXPIRED:
  			goto do_state_recovery;
***************
*** 1099,1105 ****
  	clear_bit(NFS_DELEGATED_STATE, &state->flags);
  	smp_rmb();
  	if (state->n_rdwr != 0) {
- 		clear_bit(NFS_O_RDWR_STATE, &state->flags);
  		ret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);
  		if (ret != 0)
  			return ret;
--- 1102,1107 ----
***************
*** 1107,1113 ****
  			return -ESTALE;
  	}
  	if (state->n_wronly != 0) {
- 		clear_bit(NFS_O_WRONLY_STATE, &state->flags);
  		ret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);
  		if (ret != 0)
  			return ret;
--- 1109,1114 ----
***************
*** 1115,1121 ****
  			return -ESTALE;
  	}
  	if (state->n_rdonly != 0) {
- 		clear_bit(NFS_O_RDONLY_STATE, &state->flags);
  		ret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);
  		if (ret != 0)
  			return ret;
--- 1116,1121 ----
***************
*** 3479,3484 ****
--- 3479,3487 ----
  			nfs4_state_mark_reclaim_nograce(clp, state);
  			goto do_state_recovery;
  		case -NFS4ERR_STALE_STATEID:
+ 			if (state == NULL)
+ 				break;
+ 			nfs4_state_mark_reclaim_reboot(clp, state);
  		case -NFS4ERR_STALE_CLIENTID:
  		case -NFS4ERR_EXPIRED:
  			goto do_state_recovery;
diff -cBr 2.6.35/fs/nfs/nfs4state.c linux-2.6.35.y-512ac85/fs/nfs/nfs4state.c
*** 2.6.35/fs/nfs/nfs4state.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfs/nfs4state.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1111,1124 ****
  		(void)ops->reclaim_complete(clp);
  }
  
! static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)
  {
  	struct nfs4_state_owner *sp;
  	struct rb_node *pos;
  	struct nfs4_state *state;
  
  	if (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))
! 		return 0;
  
  	for (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {
  		sp = rb_entry(pos, struct nfs4_state_owner, so_client_node);
--- 1111,1127 ----
  		(void)ops->reclaim_complete(clp);
  }
  
! static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)
  {
  	struct nfs4_state_owner *sp;
  	struct rb_node *pos;
  	struct nfs4_state *state;
  
  	if (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))
! 		return;
! 
! 	nfs4_reclaim_complete(clp,
! 		nfs4_reboot_recovery_ops[clp->cl_minorversion]);
  
  	for (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {
  		sp = rb_entry(pos, struct nfs4_state_owner, so_client_node);
***************
*** 1132,1145 ****
  	}
  
  	nfs_delegation_reap_unclaimed(clp);
- 	return 1;
- }
- 
- static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)
- {
- 	if (!nfs4_state_clear_reclaim_reboot(clp))
- 		return;
- 	nfs4_reclaim_complete(clp, nfs4_reboot_recovery_ops[clp->cl_minorversion]);
  }
  
  static void nfs_delegation_clear_all(struct nfs_client *clp)
--- 1135,1140 ----
***************
*** 1166,1172 ****
  		case -NFS4ERR_STALE_CLIENTID:
  		case -NFS4ERR_LEASE_MOVED:
  			set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);
! 			nfs4_state_clear_reclaim_reboot(clp);
  			nfs4_state_start_reclaim_reboot(clp);
  			break;
  		case -NFS4ERR_EXPIRED:
--- 1161,1167 ----
  		case -NFS4ERR_STALE_CLIENTID:
  		case -NFS4ERR_LEASE_MOVED:
  			set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);
! 			nfs4_state_end_reclaim_reboot(clp);
  			nfs4_state_start_reclaim_reboot(clp);
  			break;
  		case -NFS4ERR_EXPIRED:
diff -cBr 2.6.35/fs/nfsd/lockd.c linux-2.6.35.y-512ac85/fs/nfsd/lockd.c
*** 2.6.35/fs/nfsd/lockd.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/lockd.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 38,43 ****
--- 38,44 ----
  	exp_readlock();
  	nfserr = nfsd_open(rqstp, &fh, S_IFREG, NFSD_MAY_LOCK, filp);
  	fh_put(&fh);
+ 	rqstp->rq_client = NULL;
  	exp_readunlock();
   	/* We return nlm error codes as nlm doesn't know
  	 * about nfsd, but nfsd does know about nlm..
diff -cBr 2.6.35/fs/nfsd/nfs3xdr.c linux-2.6.35.y-512ac85/fs/nfsd/nfs3xdr.c
*** 2.6.35/fs/nfsd/nfs3xdr.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/nfs3xdr.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 260,270 ****
  	err = vfs_getattr(fhp->fh_export->ex_path.mnt, fhp->fh_dentry,
  			&fhp->fh_post_attr);
  	fhp->fh_post_change = fhp->fh_dentry->d_inode->i_version;
! 	if (err) {
  		fhp->fh_post_saved = 0;
! 		/* Grab the ctime anyway - set_change_info might use it */
! 		fhp->fh_post_attr.ctime = fhp->fh_dentry->d_inode->i_ctime;
! 	} else
  		fhp->fh_post_saved = 1;
  }
  
--- 260,268 ----
  	err = vfs_getattr(fhp->fh_export->ex_path.mnt, fhp->fh_dentry,
  			&fhp->fh_post_attr);
  	fhp->fh_post_change = fhp->fh_dentry->d_inode->i_version;
! 	if (err)
  		fhp->fh_post_saved = 0;
! 	else
  		fhp->fh_post_saved = 1;
  }
  
diff -cBr 2.6.35/fs/nfsd/nfs4proc.c linux-2.6.35.y-512ac85/fs/nfsd/nfs4proc.c
*** 2.6.35/fs/nfsd/nfs4proc.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/nfs4proc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 954,961 ****
  			      void *);
  enum nfsd4_op_flags {
  	ALLOWED_WITHOUT_FH = 1 << 0,	/* No current filehandle required */
! 	ALLOWED_ON_ABSENT_FS = 1 << 1,	/* ops processed on absent fs */
! 	ALLOWED_AS_FIRST_OP = 1 << 2,	/* ops reqired first in compound */
  };
  
  struct nfsd4_operation {
--- 954,961 ----
  			      void *);
  enum nfsd4_op_flags {
  	ALLOWED_WITHOUT_FH = 1 << 0,	/* No current filehandle required */
! 	ALLOWED_ON_ABSENT_FS = 2 << 0,	/* ops processed on absent fs */
! 	ALLOWED_AS_FIRST_OP = 3 << 0,	/* ops reqired first in compound */
  };
  
  struct nfsd4_operation {
diff -cBr 2.6.35/fs/nfsd/nfs4xdr.c linux-2.6.35.y-512ac85/fs/nfsd/nfs4xdr.c
*** 2.6.35/fs/nfsd/nfs4xdr.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/nfs4xdr.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 316,323 ****
  		READ_BUF(dummy32);
  		len += (XDR_QUADLEN(dummy32) << 2);
  		READMEM(buf, dummy32);
! 		if ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))
! 			return status;
  		iattr->ia_valid |= ATTR_UID;
  	}
  	if (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {
--- 316,323 ----
  		READ_BUF(dummy32);
  		len += (XDR_QUADLEN(dummy32) << 2);
  		READMEM(buf, dummy32);
! 		if ((host_err = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))
! 			goto out_nfserr;
  		iattr->ia_valid |= ATTR_UID;
  	}
  	if (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {
***************
*** 327,334 ****
  		READ_BUF(dummy32);
  		len += (XDR_QUADLEN(dummy32) << 2);
  		READMEM(buf, dummy32);
! 		if ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))
! 			return status;
  		iattr->ia_valid |= ATTR_GID;
  	}
  	if (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {
--- 327,334 ----
  		READ_BUF(dummy32);
  		len += (XDR_QUADLEN(dummy32) << 2);
  		READMEM(buf, dummy32);
! 		if ((host_err = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))
! 			goto out_nfserr;
  		iattr->ia_valid |= ATTR_GID;
  	}
  	if (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {
***************
*** 1180,1185 ****
--- 1180,1187 ----
  			READ_BUF(4);
  			READ32(dummy);
  			READ_BUF(dummy * 4);
+ 			for (i = 0; i < dummy; ++i)
+ 				READ32(dummy);
  			break;
  		case RPC_AUTH_GSS:
  			dprintk("RPC_AUTH_GSS callback secflavor "
***************
*** 1195,1200 ****
--- 1197,1203 ----
  			READ_BUF(4);
  			READ32(dummy);
  			READ_BUF(dummy);
+ 			p += XDR_QUADLEN(dummy);
  			break;
  		default:
  			dprintk("Illegal callback secflavor\n");
diff -cBr 2.6.35/fs/nfsd/vfs.c linux-2.6.35.y-512ac85/fs/nfsd/vfs.c
*** 2.6.35/fs/nfsd/vfs.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/vfs.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 819,825 ****
  		if (ra->p_count == 0)
  			frap = rap;
  	}
! 	depth = nfsdstats.ra_size;
  	if (!frap) {	
  		spin_unlock(&rab->pb_lock);
  		return NULL;
--- 819,825 ----
  		if (ra->p_count == 0)
  			frap = rap;
  	}
! 	depth = nfsdstats.ra_size*11/10;
  	if (!frap) {	
  		spin_unlock(&rab->pb_lock);
  		return NULL;
diff -cBr 2.6.35/fs/nfsd/xdr4.h linux-2.6.35.y-512ac85/fs/nfsd/xdr4.h
*** 2.6.35/fs/nfsd/xdr4.h	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nfsd/xdr4.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 484,500 ****
  static inline void
  set_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)
  {
! 	BUG_ON(!fhp->fh_pre_saved);
! 	cinfo->atomic = fhp->fh_post_saved;
  	cinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);
! 
! 	cinfo->before_change = fhp->fh_pre_change;
! 	cinfo->after_change = fhp->fh_post_change;
! 	cinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;
! 	cinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;
! 	cinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;
! 	cinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;
! 
  }
  
  int nfs4svc_encode_voidres(struct svc_rqst *, __be32 *, void *);
--- 484,501 ----
  static inline void
  set_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)
  {
! 	BUG_ON(!fhp->fh_pre_saved || !fhp->fh_post_saved);
! 	cinfo->atomic = 1;
  	cinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);
! 	if (cinfo->change_supported) {
! 		cinfo->before_change = fhp->fh_pre_change;
! 		cinfo->after_change = fhp->fh_post_change;
! 	} else {
! 		cinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;
! 		cinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;
! 		cinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;
! 		cinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;
! 	}
  }
  
  int nfs4svc_encode_voidres(struct svc_rqst *, __be32 *, void *);
diff -cBr 2.6.35/fs/nilfs2/file.c linux-2.6.35.y-512ac85/fs/nilfs2/file.c
*** 2.6.35/fs/nilfs2/file.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/nilfs2/file.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 72,80 ****
  	/*
  	 * check to see if the page is mapped already (no holes)
  	 */
! 	if (PageMappedToDisk(page))
  		goto mapped;
! 
  	if (page_has_buffers(page)) {
  		struct buffer_head *bh, *head;
  		int fully_mapped = 1;
--- 72,81 ----
  	/*
  	 * check to see if the page is mapped already (no holes)
  	 */
! 	if (PageMappedToDisk(page)) {
! 		unlock_page(page);
  		goto mapped;
! 	}
  	if (page_has_buffers(page)) {
  		struct buffer_head *bh, *head;
  		int fully_mapped = 1;
***************
*** 89,94 ****
--- 90,96 ----
  
  		if (fully_mapped) {
  			SetPageMappedToDisk(page);
+ 			unlock_page(page);
  			goto mapped;
  		}
  	}
***************
*** 103,120 ****
  		return VM_FAULT_SIGBUS;
  
  	ret = block_page_mkwrite(vma, vmf, nilfs_get_block);
! 	if (ret != VM_FAULT_LOCKED) {
  		nilfs_transaction_abort(inode->i_sb);
  		return ret;
  	}
- 	nilfs_set_file_dirty(NILFS_SB(inode->i_sb), inode,
- 			     1 << (PAGE_SHIFT - inode->i_blkbits));
  	nilfs_transaction_commit(inode->i_sb);
  
   mapped:
  	SetPageChecked(page);
  	wait_on_page_writeback(page);
! 	return VM_FAULT_LOCKED;
  }
  
  static const struct vm_operations_struct nilfs_file_vm_ops = {
--- 105,120 ----
  		return VM_FAULT_SIGBUS;
  
  	ret = block_page_mkwrite(vma, vmf, nilfs_get_block);
! 	if (unlikely(ret)) {
  		nilfs_transaction_abort(inode->i_sb);
  		return ret;
  	}
  	nilfs_transaction_commit(inode->i_sb);
  
   mapped:
  	SetPageChecked(page);
  	wait_on_page_writeback(page);
! 	return 0;
  }
  
  static const struct vm_operations_struct nilfs_file_vm_ops = {
diff -cBr 2.6.35/fs/notify/inotify/inotify_user.c linux-2.6.35.y-512ac85/fs/notify/inotify/inotify_user.c
*** 2.6.35/fs/notify/inotify/inotify_user.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/notify/inotify/inotify_user.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 674,680 ****
  	if (ret >= 0)
  		return ret;
  
- 	fsnotify_put_group(group);
  	atomic_dec(&user->inotify_devs);
  out_free_uid:
  	free_uid(user);
--- 674,679 ----
diff -cBr 2.6.35/fs/ocfs2/aops.c linux-2.6.35.y-512ac85/fs/ocfs2/aops.c
*** 2.6.35/fs/ocfs2/aops.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/ocfs2/aops.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1039,1050 ****
  	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,
  					&cluster_start, &cluster_end);
  
- 	/* treat the write as new if the a hole/lseek spanned across
- 	 * the page boundary.
- 	 */
- 	new = new | ((i_size_read(inode) <= page_offset(page)) &&
- 			(page_offset(page) <= user_pos));
- 
  	if (page == wc->w_target_page) {
  		map_from = user_pos & (PAGE_CACHE_SIZE - 1);
  		map_to = map_from + user_len;
--- 1039,1044 ----
diff -cBr 2.6.35/fs/ocfs2/refcounttree.c linux-2.6.35.y-512ac85/fs/ocfs2/refcounttree.c
*** 2.6.35/fs/ocfs2/refcounttree.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/ocfs2/refcounttree.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3215,3221 ****
  					u32 num_clusters, unsigned int e_flags)
  {
  	int ret, delete, index, credits =  0;
! 	u32 new_bit, new_len, orig_num_clusters;
  	unsigned int set_len;
  	struct ocfs2_super *osb = OCFS2_SB(sb);
  	handle_t *handle;
--- 3215,3221 ----
  					u32 num_clusters, unsigned int e_flags)
  {
  	int ret, delete, index, credits =  0;
! 	u32 new_bit, new_len;
  	unsigned int set_len;
  	struct ocfs2_super *osb = OCFS2_SB(sb);
  	handle_t *handle;
***************
*** 3248,3255 ****
  		goto out;
  	}
  
- 	orig_num_clusters = num_clusters;
- 
  	while (num_clusters) {
  		ret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,
  					     p_cluster, num_clusters,
--- 3248,3253 ----
***************
*** 3337,3344 ****
  	 * in write-back mode.
  	 */
  	if (context->get_clusters == ocfs2_di_get_clusters) {
! 		ret = ocfs2_cow_sync_writeback(sb, context, cpos,
! 					       orig_num_clusters);
  		if (ret)
  			mlog_errno(ret);
  	}
--- 3335,3341 ----
  	 * in write-back mode.
  	 */
  	if (context->get_clusters == ocfs2_di_get_clusters) {
! 		ret = ocfs2_cow_sync_writeback(sb, context, cpos, num_clusters);
  		if (ret)
  			mlog_errno(ret);
  	}
diff -cBr 2.6.35/fs/ocfs2/stack_user.c linux-2.6.35.y-512ac85/fs/ocfs2/stack_user.c
*** 2.6.35/fs/ocfs2/stack_user.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/ocfs2/stack_user.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 191,197 ****
  			return c;
  	}
  
! 	return NULL;
  }
  
  /*
--- 191,197 ----
  			return c;
  	}
  
! 	return c;
  }
  
  /*
diff -cBr 2.6.35/fs/partitions/ldm.c linux-2.6.35.y-512ac85/fs/partitions/ldm.c
*** 2.6.35/fs/partitions/ldm.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/partitions/ldm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 251,261 ****
  	}
  
  	vm->vblk_size     = get_unaligned_be32(data + 0x08);
- 	if (vm->vblk_size == 0) {
- 		ldm_error ("Illegal VBLK size");
- 		return false;
- 	}
- 
  	vm->vblk_offset   = get_unaligned_be32(data + 0x0C);
  	vm->last_vblk_seq = get_unaligned_be32(data + 0x04);
  
--- 251,256 ----
diff -cBr 2.6.35/fs/partitions/mac.c linux-2.6.35.y-512ac85/fs/partitions/mac.c
*** 2.6.35/fs/partitions/mac.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/partitions/mac.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 29,37 ****
  
  int mac_partition(struct parsed_partitions *state)
  {
  	Sector sect;
  	unsigned char *data;
! 	int slot, blocks_in_map;
  	unsigned secsize;
  #ifdef CONFIG_PPC_PMAC
  	int found_root = 0;
--- 29,38 ----
  
  int mac_partition(struct parsed_partitions *state)
  {
+ 	int slot = 1;
  	Sector sect;
  	unsigned char *data;
! 	int blk, blocks_in_map;
  	unsigned secsize;
  #ifdef CONFIG_PPC_PMAC
  	int found_root = 0;
***************
*** 58,71 ****
  		put_dev_sector(sect);
  		return 0;		/* not a MacOS disk */
  	}
- 	blocks_in_map = be32_to_cpu(part->map_count);
- 	if (blocks_in_map < 0 || blocks_in_map >= DISK_MAX_PARTS) {
- 		put_dev_sector(sect);
- 		return 0;
- 	}
  	printk(" [mac]");
! 	for (slot = 1; slot <= blocks_in_map; ++slot) {
! 		int pos = slot * secsize;
  		put_dev_sector(sect);
  		data = read_part_sector(state, pos/512, &sect);
  		if (!data)
--- 59,68 ----
  		put_dev_sector(sect);
  		return 0;		/* not a MacOS disk */
  	}
  	printk(" [mac]");
! 	blocks_in_map = be32_to_cpu(part->map_count);
! 	for (blk = 1; blk <= blocks_in_map; ++blk) {
! 		int pos = blk * secsize;
  		put_dev_sector(sect);
  		data = read_part_sector(state, pos/512, &sect);
  		if (!data)
***************
*** 116,126 ****
  			}
  
  			if (goodness > found_root_goodness) {
! 				found_root = slot;
  				found_root_goodness = goodness;
  			}
  		}
  #endif /* CONFIG_PPC_PMAC */
  	}
  #ifdef CONFIG_PPC_PMAC
  	if (found_root_goodness)
--- 113,125 ----
  			}
  
  			if (goodness > found_root_goodness) {
! 				found_root = blk;
  				found_root_goodness = goodness;
  			}
  		}
  #endif /* CONFIG_PPC_PMAC */
+ 
+ 		++slot;
  	}
  #ifdef CONFIG_PPC_PMAC
  	if (found_root_goodness)
diff -cBr 2.6.35/fs/pipe.c linux-2.6.35.y-512ac85/fs/pipe.c
*** 2.6.35/fs/pipe.c	2011-05-07 19:57:18.496750002 -0400
--- linux-2.6.35.y-512ac85/fs/pipe.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1197,1220 ****
  	return ret;
  }
  
- /*
-  * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
-  * location, so checking ->i_pipe is not enough to verify that this is a
-  * pipe.
-  */
- struct pipe_inode_info *get_pipe_info(struct file *file)
- {
- 	struct inode *i = file->f_path.dentry->d_inode;
- 
- 	return S_ISFIFO(i->i_mode) ? i->i_pipe : NULL;
- }
- 
  long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
  {
  	struct pipe_inode_info *pipe;
  	long ret;
  
! 	pipe = get_pipe_info(file);
  	if (!pipe)
  		return -EBADF;
  
--- 1197,1208 ----
  	return ret;
  }
  
  long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
  {
  	struct pipe_inode_info *pipe;
  	long ret;
  
! 	pipe = file->f_path.dentry->d_inode->i_pipe;
  	if (!pipe)
  		return -EBADF;
  
diff -cBr 2.6.35/fs/proc/array.c linux-2.6.35.y-512ac85/fs/proc/array.c
*** 2.6.35/fs/proc/array.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/proc/array.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 353,358 ****
--- 353,361 ----
  	task_cap(m, task);
  	task_cpus_allowed(m, task);
  	cpuset_task_status_allowed(m, task);
+ #if defined(CONFIG_S390)
+ 	task_show_regs(m, task);
+ #endif
  	task_context_switch_counts(m, task);
  	return 0;
  }
***************
*** 489,496 ****
  		vsize,
  		mm ? get_mm_rss(mm) : 0,
  		rsslim,
! 		mm ? (permitted ? mm->start_code : 1) : 0,
! 		mm ? (permitted ? mm->end_code : 1) : 0,
  		(permitted && mm) ? mm->start_stack : 0,
  		esp,
  		eip,
--- 492,499 ----
  		vsize,
  		mm ? get_mm_rss(mm) : 0,
  		rsslim,
! 		mm ? mm->start_code : 0,
! 		mm ? mm->end_code : 0,
  		(permitted && mm) ? mm->start_stack : 0,
  		esp,
  		eip,
diff -cBr 2.6.35/fs/proc/base.c linux-2.6.35.y-512ac85/fs/proc/base.c
*** 2.6.35/fs/proc/base.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/proc/base.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2867,2882 ****
  /* for the /proc/ directory itself, after non-process stuff has been done */
  int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
! 	unsigned int nr;
! 	struct task_struct *reaper;
  	struct tgid_iter iter;
  	struct pid_namespace *ns;
  
- 	if (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)
- 		goto out_no_task;
- 	nr = filp->f_pos - FIRST_PROCESS_ENTRY;
- 
- 	reaper = get_proc_task(filp->f_path.dentry->d_inode);
  	if (!reaper)
  		goto out_no_task;
  
--- 2867,2877 ----
  /* for the /proc/ directory itself, after non-process stuff has been done */
  int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
! 	unsigned int nr = filp->f_pos - FIRST_PROCESS_ENTRY;
! 	struct task_struct *reaper = get_proc_task(filp->f_path.dentry->d_inode);
  	struct tgid_iter iter;
  	struct pid_namespace *ns;
  
  	if (!reaper)
  		goto out_no_task;
  
diff -cBr 2.6.35/fs/proc/task_mmu.c linux-2.6.35.y-512ac85/fs/proc/task_mmu.c
*** 2.6.35/fs/proc/task_mmu.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/proc/task_mmu.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 248,255 ****
  		const char *name = arch_vma_name(vma);
  		if (!name) {
  			if (mm) {
! 				if (vma->vm_start <= mm->brk &&
! 						vma->vm_end >= mm->start_brk) {
  					name = "[heap]";
  				} else if (vma->vm_start <= mm->start_stack &&
  					   vma->vm_end >= mm->start_stack) {
--- 248,255 ----
  		const char *name = arch_vma_name(vma);
  		if (!name) {
  			if (mm) {
! 				if (vma->vm_start <= mm->start_brk &&
! 						vma->vm_end >= mm->brk) {
  					name = "[heap]";
  				} else if (vma->vm_start <= mm->start_stack &&
  					   vma->vm_end >= mm->start_stack) {
diff -cBr 2.6.35/fs/quota/dquot.c linux-2.6.35.y-512ac85/fs/quota/dquot.c
*** 2.6.35/fs/quota/dquot.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/quota/dquot.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 422,428 ****
   */
  int dquot_commit(struct dquot *dquot)
  {
! 	int ret = 0;
  	struct quota_info *dqopt = sb_dqopt(dquot->dq_sb);
  
  	mutex_lock(&dqopt->dqio_mutex);
--- 422,428 ----
   */
  int dquot_commit(struct dquot *dquot)
  {
! 	int ret = 0, ret2 = 0;
  	struct quota_info *dqopt = sb_dqopt(dquot->dq_sb);
  
  	mutex_lock(&dqopt->dqio_mutex);
***************
*** 434,443 ****
  	spin_unlock(&dq_list_lock);
  	/* Inactive dquot can be only if there was error during read/init
  	 * => we have better not writing it */
! 	if (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))
  		ret = dqopt->ops[dquot->dq_type]->commit_dqblk(dquot);
! 	else
! 		ret = -EIO;
  out_sem:
  	mutex_unlock(&dqopt->dqio_mutex);
  	return ret;
--- 434,448 ----
  	spin_unlock(&dq_list_lock);
  	/* Inactive dquot can be only if there was error during read/init
  	 * => we have better not writing it */
! 	if (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {
  		ret = dqopt->ops[dquot->dq_type]->commit_dqblk(dquot);
! 		if (info_dirty(&dqopt->info[dquot->dq_type])) {
! 			ret2 = dqopt->ops[dquot->dq_type]->write_file_info(
! 						dquot->dq_sb, dquot->dq_type);
! 		}
! 		if (ret >= 0)
! 			ret = ret2;
! 	}
  out_sem:
  	mutex_unlock(&dqopt->dqio_mutex);
  	return ret;
diff -cBr 2.6.35/fs/ramfs/file-nommu.c linux-2.6.35.y-512ac85/fs/ramfs/file-nommu.c
*** 2.6.35/fs/ramfs/file-nommu.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ramfs/file-nommu.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 112,118 ****
  		SetPageDirty(page);
  
  		unlock_page(page);
- 		put_page(page);
  	}
  
  	return 0;
--- 112,117 ----
diff -cBr 2.6.35/fs/reiserfs/ioctl.c linux-2.6.35.y-512ac85/fs/reiserfs/ioctl.c
*** 2.6.35/fs/reiserfs/ioctl.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/reiserfs/ioctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 186,195 ****
  		return 0;
  	}
  
! 	depth = reiserfs_write_lock_once(inode->i_sb);
! 
! 	/* we need to make sure nobody is changing the file size beneath us */
  	reiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);
  
  	write_from = inode->i_size & (blocksize - 1);
  	/* if we are on a block boundary, we are already unpacked.  */
--- 186,196 ----
  		return 0;
  	}
  
! 	/* we need to make sure nobody is changing the file size beneath
! 	 ** us
! 	 */
  	reiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);
+ 	depth = reiserfs_write_lock_once(inode->i_sb);
  
  	write_from = inode->i_size & (blocksize - 1);
  	/* if we are on a block boundary, we are already unpacked.  */
diff -cBr 2.6.35/fs/reiserfs/xattr_acl.c linux-2.6.35.y-512ac85/fs/reiserfs/xattr_acl.c
*** 2.6.35/fs/reiserfs/xattr_acl.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/reiserfs/xattr_acl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 472,480 ****
  		struct reiserfs_transaction_handle th;
  		size_t size = reiserfs_xattr_nblocks(inode,
  					     reiserfs_acl_size(clone->a_count));
! 		int depth;
! 
! 		depth = reiserfs_write_lock_once(inode->i_sb);
  		error = journal_begin(&th, inode->i_sb, size * 2);
  		if (!error) {
  			int error2;
--- 472,478 ----
  		struct reiserfs_transaction_handle th;
  		size_t size = reiserfs_xattr_nblocks(inode,
  					     reiserfs_acl_size(clone->a_count));
! 		reiserfs_write_lock(inode->i_sb);
  		error = journal_begin(&th, inode->i_sb, size * 2);
  		if (!error) {
  			int error2;
***************
*** 484,490 ****
  			if (error2)
  				error = error2;
  		}
! 		reiserfs_write_unlock_once(inode->i_sb, depth);
  	}
  	posix_acl_release(clone);
  	return error;
--- 482,488 ----
  			if (error2)
  				error = error2;
  		}
! 		reiserfs_write_unlock(inode->i_sb);
  	}
  	posix_acl_release(clone);
  	return error;
diff -cBr 2.6.35/fs/splice.c linux-2.6.35.y-512ac85/fs/splice.c
*** 2.6.35/fs/splice.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/splice.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1323,1328 ****
--- 1323,1340 ----
  static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
  			       struct pipe_inode_info *opipe,
  			       size_t len, unsigned int flags);
+ /*
+  * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
+  * location, so checking ->i_pipe is not enough to verify that this is a
+  * pipe.
+  */
+ static inline struct pipe_inode_info *pipe_info(struct inode *inode)
+ {
+ 	if (S_ISFIFO(inode->i_mode))
+ 		return inode->i_pipe;
+ 
+ 	return NULL;
+ }
  
  /*
   * Determine where to splice to/from.
***************
*** 1336,1343 ****
  	loff_t offset, *off;
  	long ret;
  
! 	ipipe = get_pipe_info(in);
! 	opipe = get_pipe_info(out);
  
  	if (ipipe && opipe) {
  		if (off_in || off_out)
--- 1348,1355 ----
  	loff_t offset, *off;
  	long ret;
  
! 	ipipe = pipe_info(in->f_path.dentry->d_inode);
! 	opipe = pipe_info(out->f_path.dentry->d_inode);
  
  	if (ipipe && opipe) {
  		if (off_in || off_out)
***************
*** 1555,1561 ****
  	int error;
  	long ret;
  
! 	pipe = get_pipe_info(file);
  	if (!pipe)
  		return -EBADF;
  
--- 1567,1573 ----
  	int error;
  	long ret;
  
! 	pipe = pipe_info(file->f_path.dentry->d_inode);
  	if (!pipe)
  		return -EBADF;
  
***************
*** 1642,1648 ****
  	};
  	long ret;
  
! 	pipe = get_pipe_info(file);
  	if (!pipe)
  		return -EBADF;
  
--- 1654,1660 ----
  	};
  	long ret;
  
! 	pipe = pipe_info(file->f_path.dentry->d_inode);
  	if (!pipe)
  		return -EBADF;
  
***************
*** 2022,2029 ****
  static long do_tee(struct file *in, struct file *out, size_t len,
  		   unsigned int flags)
  {
! 	struct pipe_inode_info *ipipe = get_pipe_info(in);
! 	struct pipe_inode_info *opipe = get_pipe_info(out);
  	int ret = -EINVAL;
  
  	/*
--- 2034,2041 ----
  static long do_tee(struct file *in, struct file *out, size_t len,
  		   unsigned int flags)
  {
! 	struct pipe_inode_info *ipipe = pipe_info(in->f_path.dentry->d_inode);
! 	struct pipe_inode_info *opipe = pipe_info(out->f_path.dentry->d_inode);
  	int ret = -EINVAL;
  
  	/*
diff -cBr 2.6.35/fs/squashfs/dir.c linux-2.6.35.y-512ac85/fs/squashfs/dir.c
*** 2.6.35/fs/squashfs/dir.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/squashfs/dir.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 172,182 ****
  		length += sizeof(dirh);
  
  		dir_count = le32_to_cpu(dirh.count) + 1;
- 
- 		/* dir_count should never be larger than 256 */
- 		if (dir_count > 256)
- 			goto failed_read;
- 
  		while (dir_count--) {
  			/*
  			 * Read directory entry.
--- 172,177 ----
***************
*** 188,197 ****
  
  			size = le16_to_cpu(dire->size) + 1;
  
- 			/* size should never be larger than SQUASHFS_NAME_LEN */
- 			if (size > SQUASHFS_NAME_LEN)
- 				goto failed_read;
- 
  			err = squashfs_read_metadata(inode->i_sb, dire->name,
  					&block, &offset, size);
  			if (err < 0)
--- 183,188 ----
diff -cBr 2.6.35/fs/squashfs/namei.c linux-2.6.35.y-512ac85/fs/squashfs/namei.c
*** 2.6.35/fs/squashfs/namei.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/squashfs/namei.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 176,186 ****
  		length += sizeof(dirh);
  
  		dir_count = le32_to_cpu(dirh.count) + 1;
- 
- 		/* dir_count should never be larger than 256 */
- 		if (dir_count > 256)
- 			goto data_error;
- 
  		while (dir_count--) {
  			/*
  			 * Read directory entry.
--- 176,181 ----
***************
*** 192,201 ****
  
  			size = le16_to_cpu(dire->size) + 1;
  
- 			/* size should never be larger than SQUASHFS_NAME_LEN */
- 			if (size > SQUASHFS_NAME_LEN)
- 				goto data_error;
- 
  			err = squashfs_read_metadata(dir->i_sb, dire->name,
  					&block, &offset, size);
  			if (err < 0)
--- 187,192 ----
***************
*** 237,245 ****
  	d_add(dentry, inode);
  	return ERR_PTR(0);
  
- data_error:
- 	err = -EIO;
- 
  read_failure:
  	ERROR("Unable to read directory block [%llx:%x]\n",
  		squashfs_i(dir)->start + msblk->directory_table,
--- 228,233 ----
diff -cBr 2.6.35/fs/ubifs/commit.c linux-2.6.35.y-512ac85/fs/ubifs/commit.c
*** 2.6.35/fs/ubifs/commit.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ubifs/commit.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 519,525 ****
  	size_t sz;
  
  	if (!(ubifs_chk_flags & UBIFS_CHK_OLD_IDX))
! 		return 0;
  
  	INIT_LIST_HEAD(&list);
  
--- 519,525 ----
  	size_t sz;
  
  	if (!(ubifs_chk_flags & UBIFS_CHK_OLD_IDX))
! 		goto out;
  
  	INIT_LIST_HEAD(&list);
  
diff -cBr 2.6.35/fs/ubifs/debug.c linux-2.6.35.y-512ac85/fs/ubifs/debug.c
*** 2.6.35/fs/ubifs/debug.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ubifs/debug.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 961,999 ****
  void dbg_save_space_info(struct ubifs_info *c)
  {
  	struct ubifs_debug_info *d = c->dbg;
- 	int freeable_cnt;
  
! 	spin_lock(&c->space_lock);
! 	memcpy(&d->saved_lst, &c->lst, sizeof(struct ubifs_lp_stats));
  
! 	/*
! 	 * We use a dirty hack here and zero out @c->freeable_cnt, because it
! 	 * affects the free space calculations, and UBIFS might not know about
! 	 * all freeable eraseblocks. Indeed, we know about freeable eraseblocks
! 	 * only when we read their lprops, and we do this only lazily, upon the
! 	 * need. So at any given point of time @c->freeable_cnt might be not
! 	 * exactly accurate.
! 	 *
! 	 * Just one example about the issue we hit when we did not zero
! 	 * @c->freeable_cnt.
! 	 * 1. The file-system is mounted R/O, c->freeable_cnt is %0. We save the
! 	 *    amount of free space in @d->saved_free
! 	 * 2. We re-mount R/W, which makes UBIFS to read the "lsave"
! 	 *    information from flash, where we cache LEBs from various
! 	 *    categories ('ubifs_remount_fs()' -> 'ubifs_lpt_init()'
! 	 *    -> 'lpt_init_wr()' -> 'read_lsave()' -> 'ubifs_lpt_lookup()'
! 	 *    -> 'ubifs_get_pnode()' -> 'update_cats()'
! 	 *    -> 'ubifs_add_to_cat()').
! 	 * 3. Lsave contains a freeable eraseblock, and @c->freeable_cnt
! 	 *    becomes %1.
! 	 * 4. We calculate the amount of free space when the re-mount is
! 	 *    finished in 'dbg_check_space_info()' and it does not match
! 	 *    @d->saved_free.
! 	 */
! 	freeable_cnt = c->freeable_cnt;
! 	c->freeable_cnt = 0;
  	d->saved_free = ubifs_get_free_space_nolock(c);
- 	c->freeable_cnt = freeable_cnt;
  	spin_unlock(&c->space_lock);
  }
  
--- 961,971 ----
  void dbg_save_space_info(struct ubifs_info *c)
  {
  	struct ubifs_debug_info *d = c->dbg;
  
! 	ubifs_get_lp_stats(c, &d->saved_lst);
  
! 	spin_lock(&c->space_lock);
  	d->saved_free = ubifs_get_free_space_nolock(c);
  	spin_unlock(&c->space_lock);
  }
  
***************
*** 1010,1024 ****
  {
  	struct ubifs_debug_info *d = c->dbg;
  	struct ubifs_lp_stats lst;
! 	long long free;
! 	int freeable_cnt;
  
  	spin_lock(&c->space_lock);
! 	freeable_cnt = c->freeable_cnt;
! 	c->freeable_cnt = 0;
! 	free = ubifs_get_free_space_nolock(c);
! 	c->freeable_cnt = freeable_cnt;
  	spin_unlock(&c->space_lock);
  
  	if (free != d->saved_free) {
  		ubifs_err("free space changed from %lld to %lld",
--- 982,993 ----
  {
  	struct ubifs_debug_info *d = c->dbg;
  	struct ubifs_lp_stats lst;
! 	long long avail, free;
  
  	spin_lock(&c->space_lock);
! 	avail = ubifs_calc_available(c, c->min_idx_lebs);
  	spin_unlock(&c->space_lock);
+ 	free = ubifs_get_free_space(c);
  
  	if (free != d->saved_free) {
  		ubifs_err("free space changed from %lld to %lld",
***************
*** 2687,2705 ****
  	}
  
  	fname = "dump_lprops";
! 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_lprops = dent;
  
  	fname = "dump_budg";
! 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_budg = dent;
  
  	fname = "dump_tnc";
! 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_tnc = dent;
--- 2656,2674 ----
  	}
  
  	fname = "dump_lprops";
! 	dent = debugfs_create_file(fname, S_IWUGO, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_lprops = dent;
  
  	fname = "dump_budg";
! 	dent = debugfs_create_file(fname, S_IWUGO, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_budg = dent;
  
  	fname = "dump_tnc";
! 	dent = debugfs_create_file(fname, S_IWUGO, d->dfs_dir, c, &dfs_fops);
  	if (IS_ERR(dent))
  		goto out_remove;
  	d->dfs_dump_tnc = dent;
diff -cBr 2.6.35/fs/ubifs/file.c linux-2.6.35.y-512ac85/fs/ubifs/file.c
*** 2.6.35/fs/ubifs/file.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ubifs/file.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1315,1323 ****
  
  	dbg_gen("syncing inode %lu", inode->i_ino);
  
- 	if (inode->i_sb->s_flags & MS_RDONLY)
- 		return 0;
- 
  	/*
  	 * VFS has already synchronized dirty pages for this inode. Synchronize
  	 * the inode unless this is a 'datasync()' call.
--- 1315,1320 ----
diff -cBr 2.6.35/fs/ubifs/lpt.c linux-2.6.35.y-512ac85/fs/ubifs/lpt.c
*** 2.6.35/fs/ubifs/lpt.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ubifs/lpt.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1270,1278 ****
  	lnum = branch->lnum;
  	offs = branch->offs;
  	pnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);
! 	if (!pnode)
! 		return -ENOMEM;
! 
  	if (lnum == 0) {
  		/*
  		 * This pnode was not written which just means that the LEB
--- 1270,1279 ----
  	lnum = branch->lnum;
  	offs = branch->offs;
  	pnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);
! 	if (!pnode) {
! 		err = -ENOMEM;
! 		goto out;
! 	}
  	if (lnum == 0) {
  		/*
  		 * This pnode was not written which just means that the LEB
diff -cBr 2.6.35/fs/ubifs/recovery.c linux-2.6.35.y-512ac85/fs/ubifs/recovery.c
*** 2.6.35/fs/ubifs/recovery.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/ubifs/recovery.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 300,331 ****
  			goto out_free;
  		}
  		memcpy(c->rcvrd_mst_node, c->mst_node, UBIFS_MST_NODE_SZ);
- 
- 		/*
- 		 * We had to recover the master node, which means there was an
- 		 * unclean reboot. However, it is possible that the master node
- 		 * is clean at this point, i.e., %UBIFS_MST_DIRTY is not set.
- 		 * E.g., consider the following chain of events:
- 		 *
- 		 * 1. UBIFS was cleanly unmounted, so the master node is clean
- 		 * 2. UBIFS is being mounted R/W and starts changing the master
- 		 *    node in the first (%UBIFS_MST_LNUM). A power cut happens,
- 		 *    so this LEB ends up with some amount of garbage at the
- 		 *    end.
- 		 * 3. UBIFS is being mounted R/O. We reach this place and
- 		 *    recover the master node from the second LEB
- 		 *    (%UBIFS_MST_LNUM + 1). But we cannot update the media
- 		 *    because we are being mounted R/O. We have to defer the
- 		 *    operation.
- 		 * 4. However, this master node (@c->mst_node) is marked as
- 		 *    clean (since the step 1). And if we just return, the
- 		 *    mount code will be confused and won't recover the master
- 		 *    node when it is re-mounter R/W later.
- 		 *
- 		 *    Thus, to force the recovery by marking the master node as
- 		 *    dirty.
- 		 */
- 		c->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);
  	} else {
  		/* Write the recovered master node */
  		c->max_sqnum = le64_to_cpu(mst->ch.sqnum) - 1;
--- 300,305 ----
diff -cBr 2.6.35/fs/xfs/linux-2.6/xfs_ioctl.c linux-2.6.35.y-512ac85/fs/xfs/linux-2.6/xfs_ioctl.c
*** 2.6.35/fs/xfs/linux-2.6/xfs_ioctl.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/xfs/linux-2.6/xfs_ioctl.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 703,721 ****
  	xfs_mount_t		*mp,
  	void			__user *arg)
  {
! 	xfs_fsop_geom_t         fsgeo;
  	int			error;
  
! 	error = xfs_fs_geometry(mp, &fsgeo, 3);
  	if (error)
  		return -error;
  
! 	/*
! 	 * Caller should have passed an argument of type
! 	 * xfs_fsop_geom_v1_t.  This is a proper subset of the
! 	 * xfs_fsop_geom_t that xfs_fs_geometry() fills in.
! 	 */
! 	if (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))
  		return -XFS_ERROR(EFAULT);
  	return 0;
  }
--- 703,716 ----
  	xfs_mount_t		*mp,
  	void			__user *arg)
  {
! 	xfs_fsop_geom_v1_t	fsgeo;
  	int			error;
  
! 	error = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);
  	if (error)
  		return -error;
  
! 	if (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))
  		return -XFS_ERROR(EFAULT);
  	return 0;
  }
diff -cBr 2.6.35/fs/xfs/xfs_fsops.c linux-2.6.35.y-512ac85/fs/xfs/xfs_fsops.c
*** 2.6.35/fs/xfs/xfs_fsops.c	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/fs/xfs/xfs_fsops.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 57,65 ****
  	xfs_fsop_geom_t		*geo,
  	int			new_version)
  {
- 
- 	memset(geo, 0, sizeof(*geo));
- 
  	geo->blocksize = mp->m_sb.sb_blocksize;
  	geo->rtextsize = mp->m_sb.sb_rextsize;
  	geo->agblocks = mp->m_sb.sb_agblocks;
--- 57,62 ----
Only in 2.6.35/fs: yaffs2
diff -cBr 2.6.35/include/drm/drm_pciids.h linux-2.6.35.y-512ac85/include/drm/drm_pciids.h
*** 2.6.35/include/drm/drm_pciids.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/drm/drm_pciids.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 28,33 ****
--- 28,34 ----
  	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
  	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP}, \
  	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+ 	{0x1002, 0x4243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
  	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
  	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
  	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
diff -cBr 2.6.35/include/drm/drmP.h linux-2.6.35.y-512ac85/include/drm/drmP.h
*** 2.6.35/include/drm/drmP.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/drm/drmP.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 1021,1027 ****
  	struct pci_controller *hose;
  #endif
  	struct drm_sg_mem *sg;	/**< Scatter gather memory */
! 	unsigned int num_crtcs;                  /**< Number of CRTCs on this device */
  	void *dev_private;		/**< device private data */
  	void *mm_private;
  	struct address_space *dev_mapping;
--- 1021,1027 ----
  	struct pci_controller *hose;
  #endif
  	struct drm_sg_mem *sg;	/**< Scatter gather memory */
! 	int num_crtcs;                  /**< Number of CRTCs on this device */
  	void *dev_private;		/**< device private data */
  	void *mm_private;
  	struct address_space *dev_mapping;
diff -cBr 2.6.35/include/keys/rxrpc-type.h linux-2.6.35.y-512ac85/include/keys/rxrpc-type.h
*** 2.6.35/include/keys/rxrpc-type.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/keys/rxrpc-type.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 99,104 ****
--- 99,105 ----
   * structure of raw payloads passed to add_key() or instantiate key
   */
  struct rxrpc_key_data_v1 {
+ 	u32		kif_version;		/* 1 */
  	u16		security_index;
  	u16		ticket_length;
  	u32		expiry;			/* time_t */
Only in 2.6.35/include/linux: akm8975.h
Only in 2.6.35/include/linux: android_aid.h
Only in 2.6.35/include/linux: android_alarm.h
Only in 2.6.35/include/linux: android_pmem.h
Only in 2.6.35/include/linux: ashmem.h
diff -cBr 2.6.35/include/linux/binfmts.h linux-2.6.35.y-512ac85/include/linux/binfmts.h
*** 2.6.35/include/linux/binfmts.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/binfmts.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 29,35 ****
  	char buf[BINPRM_BUF_SIZE];
  #ifdef CONFIG_MMU
  	struct vm_area_struct *vma;
- 	unsigned long vma_pages;
  #else
  # define MAX_ARG_PAGES	32
  	struct page *page[MAX_ARG_PAGES];
--- 29,34 ----
***************
*** 60,69 ****
  	unsigned long loader, exec;
  };
  
- extern void acct_arg_size(struct linux_binprm *bprm, unsigned long pages);
- extern struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
- 					int write);
- 
  #define BINPRM_FLAGS_ENFORCE_NONDUMP_BIT 0
  #define BINPRM_FLAGS_ENFORCE_NONDUMP (1 << BINPRM_FLAGS_ENFORCE_NONDUMP_BIT)
  
--- 59,64 ----
diff -cBr 2.6.35/include/linux/blkdev.h linux-2.6.35.y-512ac85/include/linux/blkdev.h
*** 2.6.35/include/linux/blkdev.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/blkdev.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 325,331 ****
  
  	unsigned char		misaligned;
  	unsigned char		discard_misaligned;
! 	unsigned char		cluster;
  	signed char		discard_zeroes_data;
  };
  
--- 325,331 ----
  
  	unsigned char		misaligned;
  	unsigned char		discard_misaligned;
! 	unsigned char		no_cluster;
  	signed char		discard_zeroes_data;
  };
  
***************
*** 448,453 ****
--- 448,454 ----
  #endif
  };
  
+ #define QUEUE_FLAG_CLUSTER	0	/* cluster several segments into 1 */
  #define QUEUE_FLAG_QUEUED	1	/* uses generic tag queueing */
  #define QUEUE_FLAG_STOPPED	2	/* queue is stopped */
  #define	QUEUE_FLAG_SYNCFULL	3	/* read queue has been filled */
***************
*** 468,473 ****
--- 469,475 ----
  #define QUEUE_FLAG_NOXMERGES   17	/* No extended merges */
  
  #define QUEUE_FLAG_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
+ 				 (1 << QUEUE_FLAG_CLUSTER) |		\
  				 (1 << QUEUE_FLAG_STACKABLE)	|	\
  				 (1 << QUEUE_FLAG_SAME_COMP))
  
***************
*** 634,644 ****
  
  #define rq_data_dir(rq)		((rq)->cmd_flags & 1)
  
- static inline unsigned int blk_queue_cluster(struct request_queue *q)
- {
- 	return q->limits.cluster;
- }
- 
  /*
   * We regard a request as sync, if either a read or a sync write
   */
--- 636,641 ----
***************
*** 939,945 ****
  extern void blk_queue_max_discard_sectors(struct request_queue *q,
  		unsigned int max_discard_sectors);
  extern void blk_queue_logical_block_size(struct request_queue *, unsigned short);
! extern void blk_queue_physical_block_size(struct request_queue *, unsigned int);
  extern void blk_queue_alignment_offset(struct request_queue *q,
  				       unsigned int alignment);
  extern void blk_limits_io_min(struct queue_limits *limits, unsigned int min);
--- 936,942 ----
  extern void blk_queue_max_discard_sectors(struct request_queue *q,
  		unsigned int max_discard_sectors);
  extern void blk_queue_logical_block_size(struct request_queue *, unsigned short);
! extern void blk_queue_physical_block_size(struct request_queue *, unsigned short);
  extern void blk_queue_alignment_offset(struct request_queue *q,
  				       unsigned int alignment);
  extern void blk_limits_io_min(struct queue_limits *limits, unsigned int min);
***************
*** 1089,1095 ****
  	return q->limits.physical_block_size;
  }
  
! static inline unsigned int bdev_physical_block_size(struct block_device *bdev)
  {
  	return queue_physical_block_size(bdev_get_queue(bdev));
  }
--- 1086,1092 ----
  	return q->limits.physical_block_size;
  }
  
! static inline int bdev_physical_block_size(struct block_device *bdev)
  {
  	return queue_physical_block_size(bdev_get_queue(bdev));
  }
diff -cBr 2.6.35/include/linux/bootmem.h linux-2.6.35.y-512ac85/include/linux/bootmem.h
*** 2.6.35/include/linux/bootmem.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/bootmem.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 105,112 ****
  
  #define alloc_bootmem(x) \
  	__alloc_bootmem(x, SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))
- #define alloc_bootmem_align(x, align) \
- 	__alloc_bootmem(x, align, __pa(MAX_DMA_ADDRESS))
  #define alloc_bootmem_nopanic(x) \
  	__alloc_bootmem_nopanic(x, SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))
  #define alloc_bootmem_pages(x) \
--- 105,110 ----
Only in 2.6.35/include/linux: cpuacct.h
Only in 2.6.35/include/linux: earlysuspend.h
diff -cBr 2.6.35/include/linux/filter.h linux-2.6.35.y-512ac85/include/linux/filter.h
*** 2.6.35/include/linux/filter.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/filter.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 91,144 ****
  #define         BPF_TAX         0x00
  #define         BPF_TXA         0x80
  
- enum {
- 	BPF_S_RET_K = 0,
- 	BPF_S_RET_A,
- 	BPF_S_ALU_ADD_K,
- 	BPF_S_ALU_ADD_X,
- 	BPF_S_ALU_SUB_K,
- 	BPF_S_ALU_SUB_X,
- 	BPF_S_ALU_MUL_K,
- 	BPF_S_ALU_MUL_X,
- 	BPF_S_ALU_DIV_X,
- 	BPF_S_ALU_AND_K,
- 	BPF_S_ALU_AND_X,
- 	BPF_S_ALU_OR_K,
- 	BPF_S_ALU_OR_X,
- 	BPF_S_ALU_LSH_K,
- 	BPF_S_ALU_LSH_X,
- 	BPF_S_ALU_RSH_K,
- 	BPF_S_ALU_RSH_X,
- 	BPF_S_ALU_NEG,
- 	BPF_S_LD_W_ABS,
- 	BPF_S_LD_H_ABS,
- 	BPF_S_LD_B_ABS,
- 	BPF_S_LD_W_LEN,
- 	BPF_S_LD_W_IND,
- 	BPF_S_LD_H_IND,
- 	BPF_S_LD_B_IND,
- 	BPF_S_LD_IMM,
- 	BPF_S_LDX_W_LEN,
- 	BPF_S_LDX_B_MSH,
- 	BPF_S_LDX_IMM,
- 	BPF_S_MISC_TAX,
- 	BPF_S_MISC_TXA,
- 	BPF_S_ALU_DIV_K,
- 	BPF_S_LD_MEM,
- 	BPF_S_LDX_MEM,
- 	BPF_S_ST,
- 	BPF_S_STX,
- 	BPF_S_JMP_JA,
- 	BPF_S_JMP_JEQ_K,
- 	BPF_S_JMP_JEQ_X,
- 	BPF_S_JMP_JGE_K,
- 	BPF_S_JMP_JGE_X,
- 	BPF_S_JMP_JGT_K,
- 	BPF_S_JMP_JGT_X,
- 	BPF_S_JMP_JSET_K,
- 	BPF_S_JMP_JSET_X,
- };
- 
  #ifndef BPF_MAXINSNS
  #define BPF_MAXINSNS 4096
  #endif
--- 91,96 ----
Only in 2.6.35/include/linux: fsa9480.h
diff -cBr 2.6.35/include/linux/ftrace.h linux-2.6.35.y-512ac85/include/linux/ftrace.h
*** 2.6.35/include/linux/ftrace.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/ftrace.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 423,429 ****
  
  extern void ftrace_graph_init_task(struct task_struct *t);
  extern void ftrace_graph_exit_task(struct task_struct *t);
- extern void ftrace_graph_init_idle_task(struct task_struct *t, int cpu);
  
  static inline int task_curr_ret_stack(struct task_struct *t)
  {
--- 423,428 ----
***************
*** 447,453 ****
  
  static inline void ftrace_graph_init_task(struct task_struct *t) { }
  static inline void ftrace_graph_exit_task(struct task_struct *t) { }
- static inline void ftrace_graph_init_idle_task(struct task_struct *t, int cpu) { }
  
  static inline int register_ftrace_graph(trace_func_graph_ret_t retfunc,
  			  trace_func_graph_ent_t entryfunc)
--- 446,451 ----
diff -cBr 2.6.35/include/linux/gfp.h linux-2.6.35.y-512ac85/include/linux/gfp.h
*** 2.6.35/include/linux/gfp.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/gfp.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 339,345 ****
  
  extern gfp_t gfp_allowed_mask;
  
! extern void pm_restrict_gfp_mask(void);
! extern void pm_restore_gfp_mask(void);
  
  #endif /* __LINUX_GFP_H */
--- 339,345 ----
  
  extern gfp_t gfp_allowed_mask;
  
! extern void set_gfp_allowed_mask(gfp_t mask);
! extern gfp_t clear_gfp_allowed_mask(gfp_t mask);
  
  #endif /* __LINUX_GFP_H */
Only in 2.6.35/include/linux: gp2a.h
Only in 2.6.35/include/linux: gpio_event.h
diff -cBr 2.6.35/include/linux/hardirq.h linux-2.6.35.y-512ac85/include/linux/hardirq.h
*** 2.6.35/include/linux/hardirq.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/hardirq.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 64,71 ****
  #define HARDIRQ_OFFSET	(1UL << HARDIRQ_SHIFT)
  #define NMI_OFFSET	(1UL << NMI_SHIFT)
  
- #define SOFTIRQ_DISABLE_OFFSET	(2 * SOFTIRQ_OFFSET)
- 
  #ifndef PREEMPT_ACTIVE
  #define PREEMPT_ACTIVE_BITS	1
  #define PREEMPT_ACTIVE_SHIFT	(NMI_SHIFT + NMI_BITS)
--- 64,69 ----
***************
*** 84,96 ****
  /*
   * Are we doing bottom half or hardware interrupt processing?
   * Are we in a softirq context? Interrupt context?
-  * in_softirq - Are we currently processing softirq or have bh disabled?
-  * in_serving_softirq - Are we currently processing softirq?
   */
  #define in_irq()		(hardirq_count())
  #define in_softirq()		(softirq_count())
  #define in_interrupt()		(irq_count())
- #define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
  
  /*
   * Are we in NMI context?
--- 82,91 ----
***************
*** 137,148 ****
  
  struct task_struct;
  
! #if !defined(CONFIG_VIRT_CPU_ACCOUNTING) && !defined(CONFIG_IRQ_TIME_ACCOUNTING)
  static inline void account_system_vtime(struct task_struct *tsk)
  {
  }
- #else
- extern void account_system_vtime(struct task_struct *tsk);
  #endif
  
  #if defined(CONFIG_NO_HZ)
--- 132,141 ----
  
  struct task_struct;
  
! #ifndef CONFIG_VIRT_CPU_ACCOUNTING
  static inline void account_system_vtime(struct task_struct *tsk)
  {
  }
  #endif
  
  #if defined(CONFIG_NO_HZ)
Only in 2.6.35/include/linux/i2c: ak8973.h
diff -cBr 2.6.35/include/linux/ieee80211.h linux-2.6.35.y-512ac85/include/linux/ieee80211.h
*** 2.6.35/include/linux/ieee80211.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/ieee80211.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 959,965 ****
  /* block-ack parameters */
  #define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
  #define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
! #define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
  #define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
  #define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
  
--- 959,965 ----
  /* block-ack parameters */
  #define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
  #define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
! #define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
  #define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
  #define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
  
Only in 2.6.35/include/linux: if_pppolac.h
Only in 2.6.35/include/linux: if_pppopns.h
Only in 2.6.35/include/linux/input: cypress-touchkey.h
Only in 2.6.35/include/linux/input: k3g.h
Only in 2.6.35/include/linux/input: mxt224.h
Only in linux-2.6.35.y-512ac85/include/linux: intel-gtt.h
Only in 2.6.35/include/linux: kernel_debugger.h
Only in 2.6.35/include/linux: keychord.h
Only in 2.6.35/include/linux: keyreset.h
diff -cBr 2.6.35/include/linux/klist.h linux-2.6.35.y-512ac85/include/linux/klist.h
*** 2.6.35/include/linux/klist.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/klist.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 22,28 ****
  	struct list_head	k_list;
  	void			(*get)(struct klist_node *);
  	void			(*put)(struct klist_node *);
! } __attribute__ ((aligned (sizeof(void *))));
  
  #define KLIST_INIT(_name, _get, _put)					\
  	{ .k_lock	= __SPIN_LOCK_UNLOCKED(_name.k_lock),		\
--- 22,28 ----
  	struct list_head	k_list;
  	void			(*get)(struct klist_node *);
  	void			(*put)(struct klist_node *);
! } __attribute__ ((aligned (4)));
  
  #define KLIST_INIT(_name, _get, _put)					\
  	{ .k_lock	= __SPIN_LOCK_UNLOCKED(_name.k_lock),		\
Only in 2.6.35/include/linux: kr3dm.h
Only in 2.6.35/include/linux/mfd: max8998.h
Only in 2.6.35/include/linux/mfd: max8998-private.h
diff -cBr 2.6.35/include/linux/mfd/wm8994/pdata.h linux-2.6.35.y-512ac85/include/linux/mfd/wm8994/pdata.h
*** 2.6.35/include/linux/mfd/wm8994/pdata.h	2011-05-07 19:57:18.506750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/mfd/wm8994/pdata.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 29,35 ****
  #define WM8994_CONFIGURE_GPIO 0x8000
  
  #define WM8994_DRC_REGS 5
! #define WM8994_EQ_REGS  20
  
  /**
   * DRC configurations are specified with a label and a set of register
--- 29,35 ----
  #define WM8994_CONFIGURE_GPIO 0x8000
  
  #define WM8994_DRC_REGS 5
! #define WM8994_EQ_REGS  19
  
  /**
   * DRC configurations are specified with a label and a set of register
Only in 2.6.35/include/linux/mfd/wm8994: wm8994_pdata.h
diff -cBr 2.6.35/include/linux/mmzone.h linux-2.6.35.y-512ac85/include/linux/mmzone.h
*** 2.6.35/include/linux/mmzone.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/mmzone.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 463,468 ****
--- 463,474 ----
  	return test_bit(ZONE_OOM_LOCKED, &zone->flags);
  }
  
+ #ifdef CONFIG_SMP
+ unsigned long zone_nr_free_pages(struct zone *zone);
+ #else
+ #define zone_nr_free_pages(zone) zone_page_state(zone, NR_FREE_PAGES)
+ #endif /* CONFIG_SMP */
+ 
  /*
   * The "priority" of VM scanning is how much of the queues we will scan in one
   * go. A value of 12 for DEF_PRIORITY implies that we will scan 1/4096th of the
***************
*** 662,670 ****
  			unsigned long *free);
  void build_all_zonelists(void *data);
  void wakeup_kswapd(struct zone *zone, int order);
! bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,
! 		int classzone_idx, int alloc_flags);
! bool zone_watermark_ok_safe(struct zone *z, int order, unsigned long mark,
  		int classzone_idx, int alloc_flags);
  enum memmap_context {
  	MEMMAP_EARLY,
--- 668,674 ----
  			unsigned long *free);
  void build_all_zonelists(void *data);
  void wakeup_kswapd(struct zone *zone, int order);
! int zone_watermark_ok(struct zone *z, int order, unsigned long mark,
  		int classzone_idx, int alloc_flags);
  enum memmap_context {
  	MEMMAP_EARLY,
diff -cBr 2.6.35/include/linux/netdevice.h linux-2.6.35.y-512ac85/include/linux/netdevice.h
*** 2.6.35/include/linux/netdevice.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/netdevice.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 2344,2353 ****
  })
  #endif
  
- #define MODULE_ALIAS_NETDEV(device) \
- 	MODULE_ALIAS("netdev-" device)
- 
- 
  #endif /* __KERNEL__ */
  
  #endif	/* _LINUX_NETDEVICE_H */
--- 2344,2349 ----
diff -cBr 2.6.35/include/linux/netfilter.h linux-2.6.35.y-512ac85/include/linux/netfilter.h
*** 2.6.35/include/linux/netfilter.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/netfilter.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 215,221 ****
  	int ret;
  
  	if (!cond ||
! 	    ((ret = nf_hook_thresh(pf, hook, skb, in, out, okfn, INT_MIN)) == 1))
  		ret = okfn(skb);
  	return ret;
  }
--- 215,221 ----
  	int ret;
  
  	if (!cond ||
! 	    (ret = nf_hook_thresh(pf, hook, skb, in, out, okfn, INT_MIN) == 1))
  		ret = okfn(skb);
  	return ret;
  }
Only in 2.6.35/include/linux: nt35580.h
diff -cBr 2.6.35/include/linux/pci_ids.h linux-2.6.35.y-512ac85/include/linux/pci_ids.h
*** 2.6.35/include/linux/pci_ids.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/pci_ids.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 2038,2044 ****
  #define PCI_DEVICE_ID_AFAVLAB_P030	0x2182
  #define PCI_SUBDEVICE_ID_AFAVLAB_P061		0x2150
  
- #define PCI_VENDOR_ID_BCM_GVC          0x14a4
  #define PCI_VENDOR_ID_BROADCOM		0x14e4
  #define PCI_DEVICE_ID_TIGON3_5752	0x1600
  #define PCI_DEVICE_ID_TIGON3_5752M	0x1601
--- 2038,2043 ----
diff -cBr 2.6.35/include/linux/perf_event.h linux-2.6.35.y-512ac85/include/linux/perf_event.h
*** 2.6.35/include/linux/perf_event.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/perf_event.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 764,770 ****
  	int				nr_active;
  	int				is_active;
  	int				nr_stat;
- 	int				rotate_disable;
  	atomic_t			refcount;
  	struct task_struct		*task;
  
--- 764,769 ----
diff -cBr 2.6.35/include/linux/pid.h linux-2.6.35.y-512ac85/include/linux/pid.h
*** 2.6.35/include/linux/pid.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/pid.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 117,123 ****
   */
  extern struct pid *find_get_pid(int nr);
  extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
! int next_pidmap(struct pid_namespace *pid_ns, unsigned int last);
  
  extern struct pid *alloc_pid(struct pid_namespace *ns);
  extern void free_pid(struct pid *pid);
--- 117,123 ----
   */
  extern struct pid *find_get_pid(int nr);
  extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
! int next_pidmap(struct pid_namespace *pid_ns, int last);
  
  extern struct pid *alloc_pid(struct pid_namespace *ns);
  extern void free_pid(struct pid *pid);
diff -cBr 2.6.35/include/linux/pipe_fs_i.h linux-2.6.35.y-512ac85/include/linux/pipe_fs_i.h
*** 2.6.35/include/linux/pipe_fs_i.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/pipe_fs_i.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 160,165 ****
  
  /* for F_SETPIPE_SZ and F_GETPIPE_SZ */
  long pipe_fcntl(struct file *, unsigned int, unsigned long arg);
- struct pipe_inode_info *get_pipe_info(struct file *file);
  
  #endif
--- 160,164 ----
diff -cBr 2.6.35/include/linux/pm_runtime.h linux-2.6.35.y-512ac85/include/linux/pm_runtime.h
*** 2.6.35/include/linux/pm_runtime.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/pm_runtime.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 67,74 ****
  
  static inline bool pm_runtime_suspended(struct device *dev)
  {
! 	return dev->power.runtime_status == RPM_SUSPENDED
! 		&& !dev->power.disable_depth;
  }
  
  #else /* !CONFIG_PM_RUNTIME */
--- 67,73 ----
  
  static inline bool pm_runtime_suspended(struct device *dev)
  {
! 	return dev->power.runtime_status == RPM_SUSPENDED;
  }
  
  #else /* !CONFIG_PM_RUNTIME */
Only in 2.6.35/include/linux: pn544.h
diff -cBr 2.6.35/include/linux/radix-tree.h linux-2.6.35.y-512ac85/include/linux/radix-tree.h
*** 2.6.35/include/linux/radix-tree.h	2011-05-07 19:57:18.516750002 -0400
--- linux-2.6.35.y-512ac85/include/linux/radix-tree.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,41 ****
--- 36,52 ----
   * RCU.
   */
  #define RADIX_TREE_INDIRECT_PTR	1
+ #define RADIX_TREE_RETRY ((void *)-1UL)
+ 
+ static inline void *radix_tree_ptr_to_indirect(void *ptr)
+ {
+ 	return (void *)((unsigned long)ptr | RADIX_TREE_INDIRECT_PTR);
+ }
+ 
+ static inline void *radix_tree_indirect_to_ptr(void *ptr)
+ {
+ 	return (void *)((unsigned long)ptr & ~RADIX_TREE_INDIRECT_PTR);
+ }
  
  static inline int radix_tree_is_indirect_ptr(void *ptr)
  {
***************
*** 127,155 ****
   *		removed.
   *
   * For use with radix_tree_lookup_slot().  Caller must hold tree at least read
!  * locked across slot lookup and dereference. Not required if write lock is
!  * held (ie. items cannot be concurrently inserted).
!  *
!  * radix_tree_deref_retry must be used to confirm validity of the pointer if
!  * only the read lock is held.
   */
  static inline void *radix_tree_deref_slot(void **pslot)
  {
! 	return rcu_dereference(*pslot);
  }
- 
- /**
-  * radix_tree_deref_retry	- check radix_tree_deref_slot
-  * @arg:	pointer returned by radix_tree_deref_slot
-  * Returns:	0 if retry is not required, otherwise retry is required
-  *
-  * radix_tree_deref_retry must be used with radix_tree_deref_slot.
-  */
- static inline int radix_tree_deref_retry(void *arg)
- {
- 	return unlikely((unsigned long)arg & RADIX_TREE_INDIRECT_PTR);
- }
- 
  /**
   * radix_tree_replace_slot	- replace item in a slot
   * @pslot:	pointer to slot, returned by radix_tree_lookup_slot
--- 138,153 ----
   *		removed.
   *
   * For use with radix_tree_lookup_slot().  Caller must hold tree at least read
!  * locked across slot lookup and dereference.  More likely, will be used with
!  * radix_tree_replace_slot(), as well, so caller will hold tree write locked.
   */
  static inline void *radix_tree_deref_slot(void **pslot)
  {
! 	void *ret = rcu_dereference(*pslot);
! 	if (unlikely(radix_tree_is_indirect_ptr(ret)))
! 		ret = RADIX_TREE_RETRY;
! 	return ret;
  }
  /**
   * radix_tree_replace_slot	- replace item in a slot
   * @pslot:	pointer to slot, returned by radix_tree_lookup_slot
Only in 2.6.35/include/linux/regulator: max8893.h
diff -cBr 2.6.35/include/linux/sched.h linux-2.6.35.y-512ac85/include/linux/sched.h
*** 2.6.35/include/linux/sched.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/linux/sched.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 143,149 ****
  extern unsigned long this_cpu_load(void);
  
  
! extern void calc_global_load(unsigned long ticks);
  
  extern unsigned long get_parent_ip(unsigned long addr);
  
--- 143,149 ----
  extern unsigned long this_cpu_load(void);
  
  
! extern void calc_global_load(void);
  
  extern unsigned long get_parent_ip(unsigned long addr);


***************
*** 1081,1087 ****
  					 struct task_struct *task);
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	void (*task_move_group) (struct task_struct *p, int on_rq);
  #endif
  };
  
--- 1076,1082 ----
  					 struct task_struct *task);
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	void (*moved_group) (struct task_struct *p, int on_rq);
  #endif
  };
  
***************
*** 1690,1696 ****
  /*
   * Per process flags
   */
! #define PF_KSOFTIRQD	0x00000001	/* I am ksoftirqd */
  #define PF_STARTING	0x00000002	/* being created */
  #define PF_EXITING	0x00000004	/* getting shut down */
  #define PF_EXITPIDONE	0x00000008	/* pi exit done on shut down */
--- 1685,1692 ----
  /*
   * Per process flags
   */
! #define PF_ALIGNWARN	0x00000001	/* Print alignment warning msgs */
! 					/* Not implemented yet, only for 486*/
  #define PF_STARTING	0x00000002	/* being created */
  #define PF_EXITING	0x00000004	/* getting shut down */
  #define PF_EXITPIDONE	0x00000008	/* pi exit done on shut down */
***************
*** 1828,1846 ****
   */
  extern unsigned long long cpu_clock(int cpu);
  
- #ifdef CONFIG_IRQ_TIME_ACCOUNTING
- /*
-  * An i/f to runtime opt-in for irq time accounting based off of sched_clock.
-  * The reason for this explicit opt-in is not to have perf penalty with
-  * slow sched_clocks.
-  */
- extern void enable_sched_clock_irqtime(void);
- extern void disable_sched_clock_irqtime(void);
- #else
- static inline void enable_sched_clock_irqtime(void) {}
- static inline void disable_sched_clock_irqtime(void) {}
- #endif
- 
  extern unsigned long long
  task_sched_runtime(struct task_struct *task);
  extern unsigned long long thread_group_sched_runtime(struct task_struct *task);
--- 1824,1829 ----
Only in 2.6.35/include/linux: sec_jack.h
diff -cBr 2.6.35/include/linux/socket.h linux-2.6.35.y-512ac85/include/linux/socket.h
*** 2.6.35/include/linux/socket.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/linux/socket.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 24,32 ****
  #include <linux/types.h>		/* pid_t			*/
  #include <linux/compiler.h>		/* __user			*/
  
- struct pid;
- struct cred;
- 
  #define __sockaddr_check_size(size)	\
  	BUILD_BUG_ON(((size) > sizeof(struct __kernel_sockaddr_storage)))
  
--- 24,29 ----
***************
*** 312,319 ****
  #define IPX_TYPE	1
  
  #ifdef __KERNEL__
- extern void cred_to_ucred(struct pid *pid, const struct cred *cred, struct ucred *ucred);
- 
  extern int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
  extern int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
  			       int offset, int len);
--- 309,314 ----
Only in 2.6.35/include/linux: switch.h
Only in 2.6.35/include/linux: synaptics_i2c_rmi.h
Only in 2.6.35/include/linux: tl2796.h
Only in 2.6.35/include/linux: uid_stat.h
Only in 2.6.35/include/linux/usb: android_composite.h
Only in 2.6.35/include/linux/usb: f_accessory.h
Only in 2.6.35/include/linux/usb: f_mtp.h
diff -cBr 2.6.35/include/linux/usb/serial.h linux-2.6.35.y-512ac85/include/linux/usb/serial.h
*** 2.6.35/include/linux/usb/serial.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/linux/usb/serial.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 346,354 ****
  					struct usb_serial_port *port,
  					unsigned int ch);
  extern int usb_serial_handle_break(struct usb_serial_port *port);
- extern void usb_serial_handle_dcd_change(struct usb_serial_port *usb_port,
- 					 struct tty_struct *tty,
- 					 unsigned int status);
  
  
  extern int usb_serial_bus_register(struct usb_serial_driver *device);
--- 346,351 ----
diff -cBr 2.6.35/include/linux/user_namespace.h linux-2.6.35.y-512ac85/include/linux/user_namespace.h
*** 2.6.35/include/linux/user_namespace.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/linux/user_namespace.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,44 ****
  		kref_put(&ns->kref, free_user_ns);
  }
  
- uid_t user_ns_map_uid(struct user_namespace *to, const struct cred *cred, uid_t uid);
- gid_t user_ns_map_gid(struct user_namespace *to, const struct cred *cred, gid_t gid);
- 
  #else
  
  static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
--- 36,41 ----
***************
*** 55,71 ****
  {
  }
  
- static inline uid_t user_ns_map_uid(struct user_namespace *to,
- 	const struct cred *cred, uid_t uid)
- {
- 	return uid;
- }
- static inline gid_t user_ns_map_gid(struct user_namespace *to,
- 	const struct cred *cred, gid_t gid)
- {
- 	return gid;
- }
- 
  #endif
  
  #endif /* _LINUX_USER_H */
--- 52,57 ----
Only in 2.6.35/include/linux: videodev2_samsung.h
diff -cBr 2.6.35/include/linux/vmstat.h linux-2.6.35.y-512ac85/include/linux/vmstat.h
*** 2.6.35/include/linux/vmstat.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/linux/vmstat.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 254,261 ****
  extern void __dec_zone_state(struct zone *, enum zone_stat_item);
  
  void refresh_cpu_vm_stats(int);
- void reduce_pgdat_percpu_threshold(pg_data_t *pgdat);
- void restore_pgdat_percpu_threshold(pg_data_t *pgdat);
  #else /* CONFIG_SMP */
  
  /*
--- 254,259 ----
***************
*** 300,308 ****
  #define dec_zone_page_state __dec_zone_page_state
  #define mod_zone_page_state __mod_zone_page_state
  
- static inline void reduce_pgdat_percpu_threshold(pg_data_t *pgdat) { }
- static inline void restore_pgdat_percpu_threshold(pg_data_t *pgdat) { }
- 
  static inline void refresh_cpu_vm_stats(int cpu) { }
  #endif
  
--- 298,303 ----
Only in 2.6.35/include/linux: wakelock.h
Only in 2.6.35/include/linux: wifi_tiwlan.h
Only in 2.6.35/include/linux/wimax: samsung
Only in 2.6.35/include/linux: wl127x-rfkill.h
Only in 2.6.35/include/linux: wlan_plat.h
Only in 2.6.35/include/linux: yas529.h
Only in 2.6.35/include/media: ce147_platform.h
Only in 2.6.35/include/media: s5k4ecgx.h
Only in 2.6.35/include/media: s5ka3dfx_platform.h
Only in 2.6.35/include/net: activity_stats.h
diff -cBr 2.6.35/include/net/af_unix.h linux-2.6.35.y-512ac85/include/net/af_unix.h
*** 2.6.35/include/net/af_unix.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/net/af_unix.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 10,16 ****
  extern void unix_notinflight(struct file *fp);
  extern void unix_gc(void);
  extern void wait_for_unix_gc(void);
- extern struct sock *unix_get_socket(struct file *filp);
  
  #define UNIX_HASH_SIZE	256
  
--- 10,15 ----
***************
*** 24,31 ****
  };
  
  struct unix_skb_parms {
! 	struct pid		*pid;		/* Skb credentials	*/
! 	const struct cred	*cred;
  	struct scm_fp_list	*fp;		/* Passed files		*/
  #ifdef CONFIG_SECURITY_NETWORK
  	u32			secid;		/* Security ID		*/
--- 23,29 ----
  };
  
  struct unix_skb_parms {
! 	struct ucred		creds;		/* Skb credentials	*/
  	struct scm_fp_list	*fp;		/* Passed files		*/
  #ifdef CONFIG_SECURITY_NETWORK
  	u32			secid;		/* Security ID		*/
***************
*** 33,38 ****
--- 31,37 ----
  };
  
  #define UNIXCB(skb) 	(*(struct unix_skb_parms *)&((skb)->cb))
+ #define UNIXCREDS(skb)	(&UNIXCB((skb)).creds)
  #define UNIXSID(skb)	(&UNIXCB((skb)).secid)
  
  #define unix_state_lock(s)	spin_lock(&unix_sk(s)->lock)
***************
*** 57,63 ****
  	spinlock_t		lock;
  	unsigned int		gc_candidate : 1;
  	unsigned int		gc_maybe_cycle : 1;
- 	unsigned char		recursion_level;
  	struct socket_wq	peer_wq;
  };
  #define unix_sk(__sk) ((struct unix_sock *)__sk)
--- 56,61 ----
diff -cBr 2.6.35/include/net/mac80211.h linux-2.6.35.y-512ac85/include/net/mac80211.h
*** 2.6.35/include/net/mac80211.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/net/mac80211.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 287,295 ****
   * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame
   * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this
   *	frame and selects the maximum number of streams that it can use.
-  *
-  * Note: If you have to add new flags to the enumeration, then don't
-  *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
   */
  enum mac80211_tx_control_flags {
  	IEEE80211_TX_CTL_REQ_TX_STATUS		= BIT(0),
--- 287,292 ----
***************
*** 318,336 ****
  #define IEEE80211_TX_CTL_STBC_SHIFT		23
  };
  
- /*
-  * This definition is used as a mask to clear all temporary flags, which are
-  * set by the tx handlers for each transmission attempt by the mac80211 stack.
-  */
- #define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |		      \
- 	IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \
- 	IEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |	      \
- 	IEEE80211_TX_STAT_TX_FILTERED |	IEEE80211_TX_STAT_ACK |		      \
- 	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
- 	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_PSPOLL_RESPONSE | \
- 	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
- 	IEEE80211_TX_CTL_STBC)
- 
  /**
   * enum mac80211_rate_control_flags - per-rate flags set by the
   *	Rate Control algorithm.
--- 315,320 ----
diff -cBr 2.6.35/include/net/netlink.h linux-2.6.35.y-512ac85/include/net/netlink.h
*** 2.6.35/include/net/netlink.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/net/netlink.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 384,390 ****
   *
   * Returns the first attribute which matches the specified type.
   */
! static inline struct nlattr *nlmsg_find_attr(const struct nlmsghdr *nlh,
  					     int hdrlen, int attrtype)
  {
  	return nla_find(nlmsg_attrdata(nlh, hdrlen),
--- 384,390 ----
   *
   * Returns the first attribute which matches the specified type.
   */
! static inline struct nlattr *nlmsg_find_attr(struct nlmsghdr *nlh,
  					     int hdrlen, int attrtype)
  {
  	return nla_find(nlmsg_attrdata(nlh, hdrlen),
diff -cBr 2.6.35/include/net/scm.h linux-2.6.35.y-512ac85/include/net/scm.h
*** 2.6.35/include/net/scm.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/net/scm.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 19,26 ****
  };
  
  struct scm_cookie {
- 	struct pid		*pid;		/* Skb credentials */
- 	const struct cred	*cred;
  	struct ucred		creds;		/* Skb credentials	*/
  	struct scm_fp_list	*fp;		/* Passed files		*/
  #ifdef CONFIG_SECURITY_NETWORK
--- 19,24 ----
***************
*** 44,70 ****
  { }
  #endif /* CONFIG_SECURITY_NETWORK */
  
- static __inline__ void scm_set_cred(struct scm_cookie *scm,
- 				    struct pid *pid, const struct cred *cred)
- {
- 	scm->pid  = get_pid(pid);
- 	scm->cred = get_cred(cred);
- 	cred_to_ucred(pid, cred, &scm->creds);
- }
- 
- static __inline__ void scm_destroy_cred(struct scm_cookie *scm)
- {
- 	put_pid(scm->pid);
- 	scm->pid  = NULL;
- 
- 	if (scm->cred)
- 		put_cred(scm->cred);
- 	scm->cred = NULL;
- }
- 
  static __inline__ void scm_destroy(struct scm_cookie *scm)
  {
- 	scm_destroy_cred(scm);
  	if (scm && scm->fp)
  		__scm_destroy(scm);
  }
--- 42,49 ----
***************
*** 72,78 ****
  static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
  			       struct scm_cookie *scm)
  {
! 	scm_set_cred(scm, task_tgid(current), current_cred());
  	scm->fp = NULL;
  	unix_get_peersec_dgram(sock, scm);
  	if (msg->msg_controllen <= 0)
--- 51,60 ----
  static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
  			       struct scm_cookie *scm)
  {
! 	struct task_struct *p = current;
! 	scm->creds.uid = current_uid();
! 	scm->creds.gid = current_gid();
! 	scm->creds.pid = task_tgid_vnr(p);
  	scm->fp = NULL;
  	unix_get_peersec_dgram(sock, scm);
  	if (msg->msg_controllen <= 0)
***************
*** 114,121 ****
  	if (test_bit(SOCK_PASSCRED, &sock->flags))
  		put_cmsg(msg, SOL_SOCKET, SCM_CREDENTIALS, sizeof(scm->creds), &scm->creds);
  
- 	scm_destroy_cred(scm);
- 
  	scm_passec(sock, msg, scm);
  
  	if (!scm->fp)
--- 96,101 ----
diff -cBr 2.6.35/include/net/sock.h linux-2.6.35.y-512ac85/include/net/sock.h
*** 2.6.35/include/net/sock.h	2011-05-07 19:57:36.316750004 -0400
--- linux-2.6.35.y-512ac85/include/net/sock.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 1151,1158 ****
  /* Initialise core socket variables */
  extern void sock_init_data(struct socket *sock, struct sock *sk);
  
- extern void sk_filter_release_rcu(struct rcu_head *rcu);
- 
  /**
   *	sk_filter_release - release a socket filter
   *	@fp: filter to remove
--- 1151,1156 ----
***************
*** 1163,1169 ****
  static inline void sk_filter_release(struct sk_filter *fp)
  {
  	if (atomic_dec_and_test(&fp->refcnt))
! 		call_rcu_bh(&fp->rcu, sk_filter_release_rcu);
  }
  
  static inline void sk_filter_uncharge(struct sock *sk, struct sk_filter *fp)
--- 1161,1167 ----
  static inline void sk_filter_release(struct sk_filter *fp)
  {
  	if (atomic_dec_and_test(&fp->refcnt))
! 		kfree(fp);
  }
  
  static inline void sk_filter_uncharge(struct sock *sk, struct sk_filter *fp)
diff -cBr 2.6.35/include/scsi/scsi_device.h linux-2.6.35.y-512ac85/include/scsi/scsi_device.h
*** 2.6.35/include/scsi/scsi_device.h	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/include/scsi/scsi_device.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 451,457 ****
  }
  static inline int scsi_device_enclosure(struct scsi_device *sdev)
  {
! 	return sdev->inquiry ? (sdev->inquiry[6] & (1<<6)) : 1;
  }
  
  static inline int scsi_device_protection(struct scsi_device *sdev)
--- 451,457 ----
  }
  static inline int scsi_device_enclosure(struct scsi_device *sdev)
  {
! 	return sdev->inquiry[6] & (1<<6);
  }
  
  static inline int scsi_device_protection(struct scsi_device *sdev)
diff -cBr 2.6.35/include/sound/soc-dapm.h linux-2.6.35.y-512ac85/include/sound/soc-dapm.h
*** 2.6.35/include/sound/soc-dapm.h	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/include/sound/soc-dapm.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 46,70 ****
  /* platform domain */
  #define SND_SOC_DAPM_INPUT(wname) \
  {	.id = snd_soc_dapm_input, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM }
  #define SND_SOC_DAPM_OUTPUT(wname) \
  {	.id = snd_soc_dapm_output, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM }
  #define SND_SOC_DAPM_MIC(wname, wevent) \
  {	.id = snd_soc_dapm_mic, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD}
  #define SND_SOC_DAPM_HP(wname, wevent) \
  {	.id = snd_soc_dapm_hp, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_SPK(wname, wevent) \
  {	.id = snd_soc_dapm_spk, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_LINE(wname, wevent) \
  {	.id = snd_soc_dapm_line, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  
  /* path domain */
--- 46,70 ----
  /* platform domain */
  #define SND_SOC_DAPM_INPUT(wname) \
  {	.id = snd_soc_dapm_input, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0}
  #define SND_SOC_DAPM_OUTPUT(wname) \
  {	.id = snd_soc_dapm_output, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0}
  #define SND_SOC_DAPM_MIC(wname, wevent) \
  {	.id = snd_soc_dapm_mic, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD}
  #define SND_SOC_DAPM_HP(wname, wevent) \
  {	.id = snd_soc_dapm_hp, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_SPK(wname, wevent) \
  {	.id = snd_soc_dapm_spk, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_LINE(wname, wevent) \
  {	.id = snd_soc_dapm_line, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
  
  /* path domain */
***************
*** 161,171 ****
  /* events that are pre and post DAPM */
  #define SND_SOC_DAPM_PRE(wname, wevent) \
  {	.id = snd_soc_dapm_pre, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_POST(wname, wevent) \
  {	.id = snd_soc_dapm_post, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD}
  
  /* stream domain */
--- 161,171 ----
  /* events that are pre and post DAPM */
  #define SND_SOC_DAPM_PRE(wname, wevent) \
  {	.id = snd_soc_dapm_pre, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD}
  #define SND_SOC_DAPM_POST(wname, wevent) \
  {	.id = snd_soc_dapm_post, .name = wname, .kcontrols = NULL, \
! 	.num_kcontrols = 0, .event = wevent, \
  	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD}
  
  /* stream domain */
diff -cBr 2.6.35/include/xen/interface/io/ring.h linux-2.6.35.y-512ac85/include/xen/interface/io/ring.h
*** 2.6.35/include/xen/interface/io/ring.h	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/include/xen/interface/io/ring.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 24,38 ****
   * A ring contains as many entries as will fit, rounded down to the nearest
   * power of two (so we can mask with (size-1) to loop around).
   */
! #define __CONST_RING_SIZE(_s, _sz)				\
! 	(__RD32(((_sz) - offsetof(struct _s##_sring, ring)) /	\
! 		sizeof(((struct _s##_sring *)0)->ring[0])))
! 
! /*
!  * The same for passing in an actual pointer instead of a name tag.
!  */
! #define __RING_SIZE(_s, _sz)						\
! 	(__RD32(((_sz) - (long)&(_s)->ring + (long)(_s)) / sizeof((_s)->ring[0])))
  
  /*
   * Macros to make the correct C datatypes for a new kind of ring.
--- 24,31 ----
   * A ring contains as many entries as will fit, rounded down to the nearest
   * power of two (so we can mask with (size-1) to loop around).
   */
! #define __RING_SIZE(_s, _sz) \
!     (__RD32(((_sz) - (long)&(_s)->ring + (long)(_s)) / sizeof((_s)->ring[0])))
  
  /*
   * Macros to make the correct C datatypes for a new kind of ring.
diff -cBr 2.6.35/init/calibrate.c linux-2.6.35.y-512ac85/init/calibrate.c
*** 2.6.35/init/calibrate.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/init/calibrate.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 66,72 ****
  		pre_start = 0;
  		read_current_timer(&start);
  		start_jiffies = jiffies;
! 		while (time_before_eq(jiffies, start_jiffies + 1)) {
  			pre_start = start;
  			read_current_timer(&start);
  		}
--- 66,72 ----
  		pre_start = 0;
  		read_current_timer(&start);
  		start_jiffies = jiffies;
! 		while (jiffies <= (start_jiffies + 1)) {
  			pre_start = start;
  			read_current_timer(&start);
  		}
***************
*** 74,81 ****
  
  		pre_end = 0;
  		end = post_start;
! 		while (time_before_eq(jiffies, start_jiffies + 1 +
! 					       DELAY_CALIBRATION_TICKS)) {
  			pre_end = end;
  			read_current_timer(&end);
  		}
--- 74,81 ----
  
  		pre_end = 0;
  		end = post_start;
! 		while (jiffies <=
! 		       (start_jiffies + 1 + DELAY_CALIBRATION_TICKS)) {
  			pre_end = end;
  			read_current_timer(&end);
  		}
diff -cBr 2.6.35/init/Kconfig linux-2.6.35.y-512ac85/init/Kconfig
*** 2.6.35/init/Kconfig	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/init/Kconfig	2010-11-22 14:01:26.000000000 -0500
***************
*** 799,810 ****
  config ANON_INODES
  	bool
  
- config PANIC_TIMEOUT
- 	int "Default panic timeout"
- 	default 0
- 	help
- 	  Set default panic timeout.
- 
  menuconfig EMBEDDED
  	bool "Configure standard kernel features (for small systems)"
  	help
--- 786,791 ----
diff -cBr 2.6.35/ipc/compat.c linux-2.6.35.y-512ac85/ipc/compat.c
*** 2.6.35/ipc/compat.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/ipc/compat.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 241,248 ****
  	struct semid64_ds __user *up64;
  	int version = compat_ipc_parse_version(&third);
  
- 	memset(&s64, 0, sizeof(s64));
- 
  	if (!uptr)
  		return -EINVAL;
  	if (get_user(pad, (u32 __user *) uptr))
--- 241,246 ----
***************
*** 423,430 ****
  	int version = compat_ipc_parse_version(&second);
  	void __user *p;
  
- 	memset(&m64, 0, sizeof(m64));
- 
  	switch (second & (~IPC_64)) {
  	case IPC_INFO:
  	case IPC_RMID:
--- 421,426 ----
***************
*** 598,605 ****
  	int err, err2;
  	int version = compat_ipc_parse_version(&second);
  
- 	memset(&s64, 0, sizeof(s64));
- 
  	switch (second & (~IPC_64)) {
  	case IPC_RMID:
  	case SHM_LOCK:
--- 594,599 ----
diff -cBr 2.6.35/ipc/compat_mq.c linux-2.6.35.y-512ac85/ipc/compat_mq.c
*** 2.6.35/ipc/compat_mq.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/ipc/compat_mq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 53,61 ****
  	void __user *p = NULL;
  	if (u_attr && oflag & O_CREAT) {
  		struct mq_attr attr;
- 
- 		memset(&attr, 0, sizeof(attr));
- 
  		p = compat_alloc_user_space(sizeof(attr));
  		if (get_compat_mq_attr(&attr, u_attr) ||
  		    copy_to_user(p, &attr, sizeof(attr)))
--- 53,58 ----
***************
*** 130,137 ****
  	struct mq_attr __user *p = compat_alloc_user_space(2 * sizeof(*p));
  	long ret;
  
- 	memset(&mqstat, 0, sizeof(mqstat));
- 
  	if (u_mqstat) {
  		if (get_compat_mq_attr(&mqstat, u_mqstat) ||
  		    copy_to_user(p, &mqstat, sizeof(mqstat)))
--- 127,132 ----
diff -cBr 2.6.35/ipc/shm.c linux-2.6.35.y-512ac85/ipc/shm.c
*** 2.6.35/ipc/shm.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/ipc/shm.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 473,479 ****
  	    {
  		struct shmid_ds out;
  
- 		memset(&out, 0, sizeof(out));
  		ipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);
  		out.shm_segsz	= in->shm_segsz;
  		out.shm_atime	= in->shm_atime;
--- 473,478 ----
diff -cBr 2.6.35/kernel/cpuset.c linux-2.6.35.y-512ac85/kernel/cpuset.c
*** 2.6.35/kernel/cpuset.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/kernel/cpuset.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1576,1585 ****
  		return -ENODEV;
  
  	trialcs = alloc_trial_cpuset(cs);
! 	if (!trialcs) {
! 		retval = -ENOMEM;
! 		goto out;
! 	}
  
  	switch (cft->private) {
  	case FILE_CPULIST:
--- 1576,1583 ----
  		return -ENODEV;
  
  	trialcs = alloc_trial_cpuset(cs);
! 	if (!trialcs)
! 		return -ENOMEM;
  
  	switch (cft->private) {
  	case FILE_CPULIST:
***************
*** 1594,1600 ****
  	}
  
  	free_trial_cpuset(trialcs);
- out:
  	cgroup_unlock();
  	return retval;
  }
--- 1592,1597 ----
diff -cBr 2.6.35/kernel/cred.c linux-2.6.35.y-512ac85/kernel/cred.c
*** 2.6.35/kernel/cred.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/kernel/cred.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 256,268 ****
  #endif
  
  	atomic_set(&new->usage, 1);
- #ifdef CONFIG_DEBUG_CREDENTIALS
- 	new->magic = CRED_MAGIC;
- #endif
  
  	if (security_cred_alloc_blank(new, GFP_KERNEL) < 0)
  		goto error;
  
  	return new;
  
  error:
--- 256,268 ----
  #endif
  
  	atomic_set(&new->usage, 1);
  
  	if (security_cred_alloc_blank(new, GFP_KERNEL) < 0)
  		goto error;
  
+ #ifdef CONFIG_DEBUG_CREDENTIALS
+ 	new->magic = CRED_MAGIC;
+ #endif
  	return new;
  
  error:
***************
*** 663,670 ****
  	validate_creds(old);
  
  	*new = *old;
- 	atomic_set(&new->usage, 1);
- 	set_cred_subscribers(new, 0);
  	get_uid(new->user);
  	get_group_info(new->group_info);
  
--- 663,668 ----
***************
*** 682,687 ****
--- 680,687 ----
  	if (security_prepare_creds(new, old, GFP_KERNEL) < 0)
  		goto error;
  
+ 	atomic_set(&new->usage, 1);
+ 	set_cred_subscribers(new, 0);
  	put_cred(old);
  	validate_creds(new);
  	return new;
***************
*** 754,764 ****
  	if (cred->magic != CRED_MAGIC)
  		return true;
  #ifdef CONFIG_SECURITY_SELINUX
! 	/*
! 	 * cred->security == NULL if security_cred_alloc_blank() or
! 	 * security_prepare_creds() returned an error.
! 	 */
! 	if (selinux_is_enabled() && cred->security) {
  		if ((unsigned long) cred->security < PAGE_SIZE)
  			return true;
  		if ((*(u32 *)cred->security & 0xffffff00) ==
--- 754,760 ----
  	if (cred->magic != CRED_MAGIC)
  		return true;
  #ifdef CONFIG_SECURITY_SELINUX
! 	if (selinux_is_enabled()) {
  		if ((unsigned long) cred->security < PAGE_SIZE)
  			return true;
  		if ((*(u32 *)cred->security & 0xffffff00) ==
diff -cBr 2.6.35/kernel/exit.c linux-2.6.35.y-512ac85/kernel/exit.c
*** 2.6.35/kernel/exit.c	2011-05-07 19:57:36.326750004 -0400
--- linux-2.6.35.y-512ac85/kernel/exit.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 95,108 ****
  		sig->tty = NULL;
  	} else {
  		/*
- 		 * This can only happen if the caller is de_thread().
- 		 * FIXME: this is the temporary hack, we should teach
- 		 * posix-cpu-timers to handle this case correctly.
- 		 */
- 		if (unlikely(has_group_leader_pid(tsk)))
- 			posix_cpu_timers_exit_group(tsk);
- 
- 		/*
  		 * If there is any task waiting for the group exit
  		 * then notify it:
  		 */
--- 95,100 ----
***************
*** 908,922 ****
  	if (unlikely(!tsk->pid))
  		panic("Attempted to kill the idle task!");
  
- 	/*
- 	 * If do_exit is called because this processes oopsed, it's possible
- 	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
- 	 * continuing. Amongst other possible reasons, this is to prevent
- 	 * mm_release()->clear_child_tid() from writing to a user-controlled
- 	 * kernel address.
- 	 */
- 	set_fs(USER_DS);
- 
  	tracehook_report_exit(&code);
  
  	validate_creds_for_do_exit(tsk);
--- 900,905 ----
diff -cBr 2.6.35/kernel/fork.c linux-2.6.35.y-512ac85/kernel/fork.c
*** 2.6.35/kernel/fork.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/fork.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 173,195 ****
  
  static inline void put_signal_struct(struct signal_struct *sig)
  {
! 	if (atomic_dec_and_test(&sig->sigcnt)) {
! 		sched_autogroup_exit(sig);
  		free_signal_struct(sig);
- 	}
- }
- 
- int task_free_register(struct notifier_block *n)
- {
- 	return atomic_notifier_chain_register(&task_free_notifier, n);
- }
- EXPORT_SYMBOL(task_free_register);
- 
- int task_free_unregister(struct notifier_block *n)
- {
- 	return atomic_notifier_chain_unregister(&task_free_notifier, n);
  }
- EXPORT_SYMBOL(task_free_unregister);
  
  void __put_task_struct(struct task_struct *tsk)
  {
--- 173,181 ----
  
  static inline void put_signal_struct(struct signal_struct *sig)
  {
! 	if (atomic_dec_and_test(&sig->sigcnt))
  		free_signal_struct(sig);
  }
  
  void __put_task_struct(struct task_struct *tsk)
  {
***************
*** 201,207 ****
  	delayacct_tsk_free(tsk);
  	put_signal_struct(tsk->signal);
  
- 	atomic_notifier_call_chain(&task_free_notifier, 0, tsk);
  	if (!profile_handoff_task(tsk))
  		free_task(tsk);
  }
--- 187,192 ----
***************
*** 287,293 ****
  
  	setup_thread_stack(tsk, orig);
  	clear_user_return_notifier(tsk);
- 	clear_tsk_need_resched(tsk);
  	stackend = end_of_stack(tsk);
  	*stackend = STACK_END_MAGIC;	/* for overflow detection */
  
--- 272,277 ----
***************
*** 916,922 ****
  	posix_cpu_timers_init_group(sig);
  
  	tty_audit_fork(sig);
- 	sched_autogroup_fork(sig);
  
  	sig->oom_adj = current->signal->oom_adj;
  
--- 900,905 ----
diff -cBr 2.6.35/kernel/irq/manage.c linux-2.6.35.y-512ac85/kernel/irq/manage.c
*** 2.6.35/kernel/irq/manage.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/irq/manage.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1093,1099 ****
  	if (retval)
  		kfree(action);
  
! #ifdef CONFIG_DEBUG_SHIRQ_FIXME
  	if (!retval && (irqflags & IRQF_SHARED)) {
  		/*
  		 * It's a shared IRQ -- the driver ought to be prepared for it
--- 1093,1099 ----
  	if (retval)
  		kfree(action);
  
! #ifdef CONFIG_DEBUG_SHIRQ
  	if (!retval && (irqflags & IRQF_SHARED)) {
  		/*
  		 * It's a shared IRQ -- the driver ought to be prepared for it
diff -cBr 2.6.35/kernel/irq/proc.c linux-2.6.35.y-512ac85/kernel/irq/proc.c
*** 2.6.35/kernel/irq/proc.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/irq/proc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 214,220 ****
  
  static int irq_spurious_proc_open(struct inode *inode, struct file *file)
  {
! 	return single_open(file, irq_spurious_proc_show, PDE(inode)->data);
  }
  
  static const struct file_operations irq_spurious_proc_fops = {
--- 214,220 ----
  
  static int irq_spurious_proc_open(struct inode *inode, struct file *file)
  {
! 	return single_open(file, irq_spurious_proc_show, NULL);
  }
  
  static const struct file_operations irq_spurious_proc_fops = {
diff -cBr 2.6.35/kernel/latencytop.c linux-2.6.35.y-512ac85/kernel/latencytop.c
*** 2.6.35/kernel/latencytop.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/latencytop.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 194,200 ****
  
  	account_global_scheduler_latency(tsk, &lat);
  
! 	for (i = 0; i < tsk->latency_record_count; i++) {
  		struct latency_record *mylat;
  		int same = 1;
  
--- 194,207 ----
  
  	account_global_scheduler_latency(tsk, &lat);
  
! 	/*
! 	 * short term hack; if we're > 32 we stop; future we recycle:
! 	 */
! 	tsk->latency_record_count++;
! 	if (tsk->latency_record_count >= LT_SAVECOUNT)
! 		goto out_unlock;
! 
! 	for (i = 0; i < LT_SAVECOUNT; i++) {
  		struct latency_record *mylat;
  		int same = 1;
  
***************
*** 220,233 ****
  		}
  	}
  
- 	/*
- 	 * short term hack; if we're > 32 we stop; future we recycle:
- 	 */
- 	if (tsk->latency_record_count >= LT_SAVECOUNT)
- 		goto out_unlock;
- 
  	/* Allocated a new one: */
! 	i = tsk->latency_record_count++;
  	memcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));
  
  out_unlock:
--- 227,234 ----
  		}
  	}
  
  	/* Allocated a new one: */
! 	i = tsk->latency_record_count;
  	memcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));
  
  out_unlock:
diff -cBr 2.6.35/kernel/perf_event.c linux-2.6.35.y-512ac85/kernel/perf_event.c
*** 2.6.35/kernel/perf_event.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/perf_event.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 58,65 ****
   */
  int sysctl_perf_event_paranoid __read_mostly = 1;
  
! /* Minimum for 128 pages + 1 for the user control page */
! int sysctl_perf_event_mlock __read_mostly = 516; /* 'free' kb per user */
  
  /*
   * max perf event sample rate
--- 58,64 ----
   */
  int sysctl_perf_event_paranoid __read_mostly = 1;
  
! int sysctl_perf_event_mlock __read_mostly = 512; /* 'free' kb per user */
  
  /*
   * max perf event sample rate
***************
*** 1610,1621 ****
  {
  	raw_spin_lock(&ctx->lock);
  
! 	/*
! 	 * Rotate the first entry last of non-pinned groups. Rotation might be
! 	 * disabled by the inheritance code.
! 	 */
! 	if (!ctx->rotate_disable)
! 		list_rotate_left(&ctx->flexible_groups);
  
  	raw_spin_unlock(&ctx->lock);
  }
--- 1609,1616 ----
  {
  	raw_spin_lock(&ctx->lock);
  
! 	/* Rotate the first entry last of non-pinned groups */
! 	list_rotate_left(&ctx->flexible_groups);
  
  	raw_spin_unlock(&ctx->lock);
  }
***************
*** 5401,5420 ****
  			 struct perf_event_context *child_ctx,
  			 struct task_struct *child)
  {
! 	if (child_event->parent) {
! 		raw_spin_lock_irq(&child_ctx->lock);
! 		perf_group_detach(child_event);
! 		raw_spin_unlock_irq(&child_ctx->lock);
! 	}
  
  	perf_event_remove_from_context(child_event);
  
  	/*
! 	 * It can happen that the parent exits first, and has events
  	 * that are still around due to the child reference. These
! 	 * events need to be zapped.
  	 */
! 	if (child_event->parent) {
  		sync_child_event(child_event, child);
  		free_event(child_event);
  	}
--- 5396,5412 ----
  			 struct perf_event_context *child_ctx,
  			 struct task_struct *child)
  {
! 	struct perf_event *parent_event;
  
  	perf_event_remove_from_context(child_event);
  
+ 	parent_event = child_event->parent;
  	/*
! 	 * It can happen that parent exits first, and has events
  	 * that are still around due to the child reference. These
! 	 * events need to be zapped - but otherwise linger.
  	 */
! 	if (parent_event) {
  		sync_child_event(child_event, child);
  		free_event(child_event);
  	}
***************
*** 5604,5610 ****
  	struct perf_event *event;
  	struct task_struct *parent = current;
  	int inherited_all = 1;
- 	unsigned long flags;
  	int ret = 0;
  
  	child->perf_event_ctxp = NULL;
--- 5596,5601 ----
***************
*** 5645,5659 ****
  			break;
  	}
  
- 	/*
- 	 * We can't hold ctx->lock when iterating the ->flexible_group list due
- 	 * to allocations, but we need to prevent rotation because
- 	 * rotate_ctx() will change the list from interrupt context.
- 	 */
- 	raw_spin_lock_irqsave(&parent_ctx->lock, flags);
- 	parent_ctx->rotate_disable = 1;
- 	raw_spin_unlock_irqrestore(&parent_ctx->lock, flags);
- 
  	list_for_each_entry(event, &parent_ctx->flexible_groups, group_entry) {
  		ret = inherit_task_group(event, parent, parent_ctx, child,
  					 &inherited_all);
--- 5636,5641 ----
***************
*** 5661,5670 ****
  			break;
  	}
  
- 	raw_spin_lock_irqsave(&parent_ctx->lock, flags);
- 	parent_ctx->rotate_disable = 0;
- 	raw_spin_unlock_irqrestore(&parent_ctx->lock, flags);
- 
  	child_ctx = child->perf_event_ctxp;
  
  	if (child_ctx && inherited_all) {
--- 5643,5648 ----
diff -cBr 2.6.35/kernel/pid.c linux-2.6.35.y-512ac85/kernel/pid.c
*** 2.6.35/kernel/pid.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/pid.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 183,196 ****
  	return -1;
  }
  
! int next_pidmap(struct pid_namespace *pid_ns, unsigned int last)
  {
  	int offset;
  	struct pidmap *map, *end;
  
- 	if (last >= PID_MAX_LIMIT)
- 		return -1;
- 
  	offset = (last + 1) & BITS_PER_PAGE_MASK;
  	map = &pid_ns->pidmap[(last + 1)/BITS_PER_PAGE];
  	end = &pid_ns->pidmap[PIDMAP_ENTRIES];
--- 183,193 ----
  	return -1;
  }
  
! int next_pidmap(struct pid_namespace *pid_ns, int last)
  {
  	int offset;
  	struct pidmap *map, *end;
  
  	offset = (last + 1) & BITS_PER_PAGE_MASK;
  	map = &pid_ns->pidmap[(last + 1)/BITS_PER_PAGE];
  	end = &pid_ns->pidmap[PIDMAP_ENTRIES];
Only in 2.6.35/kernel/power: consoleearlysuspend.c
Only in 2.6.35/kernel/power: earlysuspend.c
Only in 2.6.35/kernel/power: fbearlysuspend.c
diff -cBr 2.6.35/kernel/power/hibernate.c linux-2.6.35.y-512ac85/kernel/power/hibernate.c
*** 2.6.35/kernel/power/hibernate.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/hibernate.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 324,329 ****
--- 324,330 ----
  int hibernation_snapshot(int platform_mode)
  {
  	int error;
+ 	gfp_t saved_mask;
  
  	error = platform_begin(platform_mode);
  	if (error)
***************
*** 335,341 ****
  		goto Close;
  
  	suspend_console();
! 	pm_restrict_gfp_mask();
  	error = dpm_suspend_start(PMSG_FREEZE);
  	if (error)
  		goto Recover_platform;
--- 336,342 ----
  		goto Close;
  
  	suspend_console();
! 	saved_mask = clear_gfp_allowed_mask(GFP_IOFS);
  	error = dpm_suspend_start(PMSG_FREEZE);
  	if (error)
  		goto Recover_platform;
***************
*** 344,353 ****
  		goto Recover_platform;
  
  	error = create_image(platform_mode);
! 	/*
! 	 * Control returns here (1) after the image has been created or the
! 	 * image creation has failed and (2) after a successful restore.
! 	 */
  
   Resume_devices:
  	/* We may need to release the preallocated image pages here. */
--- 345,351 ----
  		goto Recover_platform;
  
  	error = create_image(platform_mode);
! 	/* Control returns here after successful restore */
  
   Resume_devices:
  	/* We may need to release the preallocated image pages here. */
***************
*** 356,365 ****
  
  	dpm_resume_end(in_suspend ?
  		(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);
! 
! 	if (error || !in_suspend)
! 		pm_restore_gfp_mask();
! 
  	resume_console();
   Close:
  	platform_end(platform_mode);
--- 354,360 ----
  
  	dpm_resume_end(in_suspend ?
  		(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);
! 	set_gfp_allowed_mask(saved_mask);
  	resume_console();
   Close:
  	platform_end(platform_mode);
***************
*** 454,469 ****
  int hibernation_restore(int platform_mode)
  {
  	int error;
  
  	pm_prepare_console();
  	suspend_console();
! 	pm_restrict_gfp_mask();
  	error = dpm_suspend_start(PMSG_QUIESCE);
  	if (!error) {
  		error = resume_target_kernel(platform_mode);
  		dpm_resume_end(PMSG_RECOVER);
  	}
! 	pm_restore_gfp_mask();
  	resume_console();
  	pm_restore_console();
  	return error;
--- 449,465 ----
  int hibernation_restore(int platform_mode)
  {
  	int error;
+ 	gfp_t saved_mask;
  
  	pm_prepare_console();
  	suspend_console();
! 	saved_mask = clear_gfp_allowed_mask(GFP_IOFS);
  	error = dpm_suspend_start(PMSG_QUIESCE);
  	if (!error) {
  		error = resume_target_kernel(platform_mode);
  		dpm_resume_end(PMSG_RECOVER);
  	}
! 	set_gfp_allowed_mask(saved_mask);
  	resume_console();
  	pm_restore_console();
  	return error;
***************
*** 477,482 ****
--- 473,479 ----
  int hibernation_platform_enter(void)
  {
  	int error;
+ 	gfp_t saved_mask;
  
  	if (!hibernation_ops)
  		return -ENOSYS;
***************
*** 492,497 ****
--- 489,495 ----
  
  	entering_platform_hibernation = true;
  	suspend_console();
+ 	saved_mask = clear_gfp_allowed_mask(GFP_IOFS);
  	error = dpm_suspend_start(PMSG_HIBERNATE);
  	if (error) {
  		if (hibernation_ops->recover)
***************
*** 529,534 ****
--- 527,533 ----
   Resume_devices:
  	entering_platform_hibernation = false;
  	dpm_resume_end(PMSG_RESTORE);
+ 	set_gfp_allowed_mask(saved_mask);
  	resume_console();
  
   Close:
***************
*** 636,642 ****
  		swsusp_free();
  		if (!error)
  			power_down();
- 		pm_restore_gfp_mask();
  	} else {
  		pr_debug("PM: Image restored successfully.\n");
  	}
--- 635,640 ----
diff -cBr 2.6.35/kernel/power/main.c linux-2.6.35.y-512ac85/kernel/power/main.c
*** 2.6.35/kernel/power/main.c	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/main.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 266,272 ****
  	int error = pm_start_workqueue();
  	if (error)
  		return error;
- 	hibernate_image_size_init();
  	power_kobj = kobject_create_and_add("power", NULL);
  	if (!power_kobj)
  		return -ENOMEM;
--- 266,271 ----
diff -cBr 2.6.35/kernel/power/power.h linux-2.6.35.y-512ac85/kernel/power/power.h
*** 2.6.35/kernel/power/power.h	2011-05-07 19:57:43.946750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/power.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 14,22 ****
  } __attribute__((aligned(PAGE_SIZE)));
  
  #ifdef CONFIG_HIBERNATION
- /* kernel/power/snapshot.c */
- extern void __init hibernate_image_size_init(void);
- 
  #ifdef CONFIG_ARCH_HIBERNATION_HEADER
  /* Maximum size of architecture specific data in a hibernation header */
  #define MAX_ARCH_HEADER_SIZE	(sizeof(struct new_utsname) + 4)
--- 14,19 ----
***************
*** 52,62 ****
  extern int hibernation_snapshot(int platform_mode);
  extern int hibernation_restore(int platform_mode);
  extern int hibernation_platform_enter(void);
! 
! #else /* !CONFIG_HIBERNATION */
! 
! static inline void hibernate_image_size_init(void) {}
! #endif /* !CONFIG_HIBERNATION */
  
  extern int pfn_is_nosave(unsigned long);
  
--- 49,55 ----
  extern int hibernation_snapshot(int platform_mode);
  extern int hibernation_restore(int platform_mode);
  extern int hibernation_platform_enter(void);
! #endif
  
  extern int pfn_is_nosave(unsigned long);
  
diff -cBr 2.6.35/kernel/power/snapshot.c linux-2.6.35.y-512ac85/kernel/power/snapshot.c
*** 2.6.35/kernel/power/snapshot.c	2011-05-07 19:57:43.956750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/snapshot.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 46,57 ****
   * size will not exceed N bytes, but if that is impossible, it will
   * try to create the smallest image possible.
   */
! unsigned long image_size;
! 
! void __init hibernate_image_size_init(void)
! {
! 	image_size = ((totalram_pages * 2) / 5) * PAGE_SIZE;
! }
  
  /* List of PBEs needed for restoring the pages that were allocated before
   * the suspend and included in the suspend image, but have also been
--- 46,52 ----
   * size will not exceed N bytes, but if that is impossible, it will
   * try to create the smallest image possible.
   */
! unsigned long image_size = 500 * 1024 * 1024;
  
  /* List of PBEs needed for restoring the pages that were allocated before
   * the suspend and included in the suspend image, but have also been
***************
*** 1323,1336 ****
  
  	/* Compute the maximum number of saveable pages to leave in memory. */
  	max_size = (count - (size + PAGES_FOR_IO)) / 2 - 2 * SPARE_PAGES;
- 	/* Compute the desired number of image pages specified by image_size. */
  	size = DIV_ROUND_UP(image_size, PAGE_SIZE);
  	if (size > max_size)
  		size = max_size;
  	/*
! 	 * If the desired number of image pages is at least as large as the
! 	 * current number of saveable pages in memory, allocate page frames for
! 	 * the image and we're done.
  	 */
  	if (size >= saveable) {
  		pages = preallocate_image_highmem(save_highmem);
--- 1318,1329 ----
  
  	/* Compute the maximum number of saveable pages to leave in memory. */
  	max_size = (count - (size + PAGES_FOR_IO)) / 2 - 2 * SPARE_PAGES;
  	size = DIV_ROUND_UP(image_size, PAGE_SIZE);
  	if (size > max_size)
  		size = max_size;
  	/*
! 	 * If the maximum is not less than the current number of saveable pages
! 	 * in memory, allocate page frames for the image and we're done.
  	 */
  	if (size >= saveable) {
  		pages = preallocate_image_highmem(save_highmem);
***************
*** 1519,1526 ****
  swsusp_alloc(struct memory_bitmap *orig_bm, struct memory_bitmap *copy_bm,
  		unsigned int nr_pages, unsigned int nr_highmem)
  {
  	if (nr_highmem > 0) {
! 		if (get_highmem_buffer(PG_ANY))
  			goto err_out;
  		if (nr_highmem > alloc_highmem) {
  			nr_highmem -= alloc_highmem;
--- 1512,1522 ----
  swsusp_alloc(struct memory_bitmap *orig_bm, struct memory_bitmap *copy_bm,
  		unsigned int nr_pages, unsigned int nr_highmem)
  {
+ 	int error = 0;
+ 
  	if (nr_highmem > 0) {
! 		error = get_highmem_buffer(PG_ANY);
! 		if (error)
  			goto err_out;
  		if (nr_highmem > alloc_highmem) {
  			nr_highmem -= alloc_highmem;
***************
*** 1543,1549 ****
  
   err_out:
  	swsusp_free();
! 	return -ENOMEM;
  }
  
  asmlinkage int swsusp_save(void)
--- 1539,1545 ----
  
   err_out:
  	swsusp_free();
! 	return error;
  }
  
  asmlinkage int swsusp_save(void)
diff -cBr 2.6.35/kernel/power/suspend.c linux-2.6.35.y-512ac85/kernel/power/suspend.c
*** 2.6.35/kernel/power/suspend.c	2011-05-07 19:57:43.956750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/suspend.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 196,201 ****
--- 196,202 ----
  int suspend_devices_and_enter(suspend_state_t state)
  {
  	int error;
+ 	gfp_t saved_mask;
  
  	if (!suspend_ops)
  		return -ENOSYS;
***************
*** 206,212 ****
  			goto Close;
  	}
  	suspend_console();
! 	pm_restrict_gfp_mask();
  	suspend_test_start();
  	error = dpm_suspend_start(PMSG_SUSPEND);
  	if (error) {
--- 207,213 ----
  			goto Close;
  	}
  	suspend_console();
! 	saved_mask = clear_gfp_allowed_mask(GFP_IOFS);
  	suspend_test_start();
  	error = dpm_suspend_start(PMSG_SUSPEND);
  	if (error) {
***************
*** 223,229 ****
  	suspend_test_start();
  	dpm_resume_end(PMSG_RESUME);
  	suspend_test_finish("resume devices");
! 	pm_restore_gfp_mask();
  	resume_console();
   Close:
  	if (suspend_ops->end)
--- 224,230 ----
  	suspend_test_start();
  	dpm_resume_end(PMSG_RESUME);
  	suspend_test_finish("resume devices");
! 	set_gfp_allowed_mask(saved_mask);
  	resume_console();
   Close:
  	if (suspend_ops->end)
diff -cBr 2.6.35/kernel/power/user.c linux-2.6.35.y-512ac85/kernel/power/user.c
*** 2.6.35/kernel/power/user.c	2011-05-07 19:57:43.956750001 -0400
--- linux-2.6.35.y-512ac85/kernel/power/user.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 137,143 ****
  	free_all_swap_pages(data->swap);
  	if (data->frozen)
  		thaw_processes();
! 	pm_notifier_call_chain(data->mode == O_RDONLY ?
  			PM_POST_HIBERNATION : PM_POST_RESTORE);
  	atomic_inc(&snapshot_device_available);
  
--- 137,143 ----
  	free_all_swap_pages(data->swap);
  	if (data->frozen)
  		thaw_processes();
! 	pm_notifier_call_chain(data->mode == O_WRONLY ?
  			PM_POST_HIBERNATION : PM_POST_RESTORE);
  	atomic_inc(&snapshot_device_available);
  
***************
*** 263,269 ****
  	case SNAPSHOT_UNFREEZE:
  		if (!data->frozen || data->ready)
  			break;
- 		pm_restore_gfp_mask();
  		thaw_processes();
  		usermodehelper_enable();
  		data->frozen = 0;
--- 263,268 ----
***************
*** 276,282 ****
  			error = -EPERM;
  			break;
  		}
- 		pm_restore_gfp_mask();
  		error = hibernation_snapshot(data->platform_support);
  		if (!error)
  			error = put_user(in_suspend, (int __user *)arg);
--- 275,280 ----
Only in 2.6.35/kernel/power: userwakelock.c
Only in 2.6.35/kernel/power: wakelock.c
diff -cBr 2.6.35/kernel/printk.c linux-2.6.35.y-512ac85/kernel/printk.c
*** 2.6.35/kernel/printk.c	2011-05-07 19:57:43.956750001 -0400
--- linux-2.6.35.y-512ac85/kernel/printk.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1034,1048 ****
  
  int printk_needs_cpu(int cpu)
  {
- 	if (unlikely(cpu_is_offline(cpu)))
- 		printk_tick();
  	return per_cpu(printk_pending, cpu);
  }
  
  void wake_up_klogd(void)
  {
  	if (waitqueue_active(&log_wait))
! 		this_cpu_write(printk_pending, 1);
  }
  
  /**
--- 1034,1046 ----
  
  int printk_needs_cpu(int cpu)
  {
  	return per_cpu(printk_pending, cpu);
  }
  
  void wake_up_klogd(void)
  {
  	if (waitqueue_active(&log_wait))
! 		__raw_get_cpu_var(printk_pending) = 1;
  }
  
  /**
diff -cBr 2.6.35/kernel/ptrace.c linux-2.6.35.y-512ac85/kernel/ptrace.c
*** 2.6.35/kernel/ptrace.c	2011-05-07 19:57:43.956750001 -0400
--- linux-2.6.35.y-512ac85/kernel/ptrace.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 313,319 ****
  		child->exit_code = data;
  		dead = __ptrace_detach(current, child);
  		if (!child->exit_state)
! 			wake_up_state(child, TASK_TRACED | TASK_STOPPED);
  	}
  	write_unlock_irq(&tasklist_lock);
  
--- 313,319 ----
  		child->exit_code = data;
  		dead = __ptrace_detach(current, child);
  		if (!child->exit_state)
! 			wake_up_process(child);
  	}
  	write_unlock_irq(&tasklist_lock);
  
Only in 2.6.35/kernel: sched_autogroup.c
Only in 2.6.35/kernel: sched_autogroup.h
diff -cBr 2.6.35/kernel/sched.c linux-2.6.35.y-512ac85/kernel/sched.c
*** 2.6.35/kernel/sched.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/sched.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 493,499 ****
  	struct mm_struct *prev_mm;
  
  	u64 clock;
- 	u64 clock_task;
  
  	atomic_t nr_iowait;
  
--- 491,496 ----
***************
*** 521,530 ****
  	u64 avg_idle;
  #endif
  
- #ifdef CONFIG_IRQ_TIME_ACCOUNTING
- 	u64 prev_irq_time;
- #endif
- 
  	/* calc_load related fields */
  	unsigned long calc_load_update;
  	long calc_load_active;
--- 518,523 ----
***************
*** 571,577 ****
  	 * A queue event has occurred, and we're going to schedule.  In
  	 * this case, we can save a useless back to back clock update.
  	 */
! 	if (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))
  		rq->skip_clock_update = 1;
  }
  
--- 564,570 ----
  	 * A queue event has occurred, and we're going to schedule.  In
  	 * this case, we can save a useless back to back clock update.
  	 */
! 	if (test_tsk_need_resched(p))
  		rq->skip_clock_update = 1;
  }
  
***************
*** 648,668 ****
  
  #endif /* CONFIG_CGROUP_SCHED */
  
- static u64 irq_time_cpu(int cpu);
- static void sched_irq_time_avg_update(struct rq *rq, u64 irq_time);
- 
  inline void update_rq_clock(struct rq *rq)
  {
- 	int cpu = cpu_of(rq);
- 	u64 irq_time;
- 
  	if (!rq->skip_clock_update)
  		rq->clock = sched_clock_cpu(cpu_of(rq));
- 	irq_time = irq_time_cpu(cpu);
- 	if (rq->clock - irq_time > rq->clock_task)
- 		rq->clock_task = rq->clock - irq_time;
- 
- 	sched_irq_time_avg_update(rq, irq_time);
  }
  
  /*
--- 641,650 ----
***************
*** 1288,1297 ****
  static void sched_rt_avg_update(struct rq *rq, u64 rt_delta)
  {
  }
- 
- static void sched_avg_update(struct rq *rq)
- {
- }
  #endif /* CONFIG_SMP */
  
  #if BITS_PER_LONG == 32
--- 1270,1275 ----
***************
*** 1837,1930 ****
  #define for_each_class(class) \
     for (class = sched_class_highest; class; class = class->next)
  
- #ifdef CONFIG_IRQ_TIME_ACCOUNTING
- 
- /*
-  * There are no locks covering percpu hardirq/softirq time.
-  * They are only modified in account_system_vtime, on corresponding CPU
-  * with interrupts disabled. So, writes are safe.
-  * They are read and saved off onto struct rq in update_rq_clock().
-  * This may result in other CPU reading this CPU's irq time and can
-  * race with irq/account_system_vtime on this CPU. We would either get old
-  * or new value (or semi updated value on 32 bit) with a side effect of
-  * accounting a slice of irq time to wrong task when irq is in progress
-  * while we read rq->clock. That is a worthy compromise in place of having
-  * locks on each irq in account_system_time.
-  */
- static DEFINE_PER_CPU(u64, cpu_hardirq_time);
- static DEFINE_PER_CPU(u64, cpu_softirq_time);
- 
- static DEFINE_PER_CPU(u64, irq_start_time);
- static int sched_clock_irqtime;
- 
- void enable_sched_clock_irqtime(void)
- {
- 	sched_clock_irqtime = 1;
- }
- 
- void disable_sched_clock_irqtime(void)
- {
- 	sched_clock_irqtime = 0;
- }
- 
- static u64 irq_time_cpu(int cpu)
- {
- 	if (!sched_clock_irqtime)
- 		return 0;
- 
- 	return per_cpu(cpu_softirq_time, cpu) + per_cpu(cpu_hardirq_time, cpu);
- }
- 
- void account_system_vtime(struct task_struct *curr)
- {
- 	unsigned long flags;
- 	int cpu;
- 	u64 now, delta;
- 
- 	if (!sched_clock_irqtime)
- 		return;
- 
- 	local_irq_save(flags);
- 
- 	cpu = smp_processor_id();
- 	now = sched_clock_cpu(cpu);
- 	delta = now - per_cpu(irq_start_time, cpu);
- 	per_cpu(irq_start_time, cpu) = now;
- 	/*
- 	 * We do not account for softirq time from ksoftirqd here.
- 	 * We want to continue accounting softirq time to ksoftirqd thread
- 	 * in that case, so as not to confuse scheduler with a special task
- 	 * that do not consume any time, but still wants to run.
- 	 */
- 	if (hardirq_count())
- 		per_cpu(cpu_hardirq_time, cpu) += delta;
- 	else if (in_serving_softirq() && !(curr->flags & PF_KSOFTIRQD))
- 		per_cpu(cpu_softirq_time, cpu) += delta;
- 
- 	local_irq_restore(flags);
- }
- EXPORT_SYMBOL_GPL(account_system_vtime);
- 
- static void sched_irq_time_avg_update(struct rq *rq, u64 curr_irq_time)
- {
- 	if (sched_clock_irqtime && sched_feat(NONIRQ_POWER)) {
- 		u64 delta_irq = curr_irq_time - rq->prev_irq_time;
- 		rq->prev_irq_time = curr_irq_time;
- 		sched_rt_avg_update(rq, delta_irq);
- 	}
- }
- 
- #else
- 
- static u64 irq_time_cpu(int cpu)
- {
- 	return 0;
- }
- 
- static void sched_irq_time_avg_update(struct rq *rq, u64 curr_irq_time) { }
- 
- #endif
- 
  #include "sched_stats.h"
  
  static void inc_nr_running(struct rq *rq)
--- 1815,1820 ----
***************
*** 3001,3015 ****
  	return delta;
  }
  
- static unsigned long
- calc_load(unsigned long load, unsigned long exp, unsigned long active)
- {
- 	load *= exp;
- 	load += active * (FIXED_1 - exp);
- 	load += 1UL << (FSHIFT - 1);
- 	return load >> FSHIFT;
- }
- 
  #ifdef CONFIG_NO_HZ
  /*
   * For NO_HZ we delay the active fold to the next LOAD_FREQ update.
--- 2890,2895 ----
***************
*** 3039,3166 ****
  
  	return delta;
  }
- 
- /**
-  * fixed_power_int - compute: x^n, in O(log n) time
-  *
-  * @x:         base of the power
-  * @frac_bits: fractional bits of @x
-  * @n:         power to raise @x to.
-  *
-  * By exploiting the relation between the definition of the natural power
-  * function: x^n := x*x*...*x (x multiplied by itself for n times), and
-  * the binary encoding of numbers used by computers: n := \Sum n_i * 2^i,
-  * (where: n_i \elem {0, 1}, the binary vector representing n),
-  * we find: x^n := x^(\Sum n_i * 2^i) := \Prod x^(n_i * 2^i), which is
-  * of course trivially computable in O(log_2 n), the length of our binary
-  * vector.
-  */
- static unsigned long
- fixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)
- {
- 	unsigned long result = 1UL << frac_bits;
- 
- 	if (n) for (;;) {
- 		if (n & 1) {
- 			result *= x;
- 			result += 1UL << (frac_bits - 1);
- 			result >>= frac_bits;
- 		}
- 		n >>= 1;
- 		if (!n)
- 			break;
- 		x *= x;
- 		x += 1UL << (frac_bits - 1);
- 		x >>= frac_bits;
- 	}
- 
- 	return result;
- }
- 
- /*
-  * a1 = a0 * e + a * (1 - e)
-  *
-  * a2 = a1 * e + a * (1 - e)
-  *    = (a0 * e + a * (1 - e)) * e + a * (1 - e)
-  *    = a0 * e^2 + a * (1 - e) * (1 + e)
-  *
-  * a3 = a2 * e + a * (1 - e)
-  *    = (a0 * e^2 + a * (1 - e) * (1 + e)) * e + a * (1 - e)
-  *    = a0 * e^3 + a * (1 - e) * (1 + e + e^2)
-  *
-  *  ...
-  *
-  * an = a0 * e^n + a * (1 - e) * (1 + e + ... + e^n-1) [1]
-  *    = a0 * e^n + a * (1 - e) * (1 - e^n)/(1 - e)
-  *    = a0 * e^n + a * (1 - e^n)
-  *
-  * [1] application of the geometric series:
-  *
-  *              n         1 - x^(n+1)
-  *     S_n := \Sum x^i = -------------
-  *             i=0          1 - x
-  */
- static unsigned long
- calc_load_n(unsigned long load, unsigned long exp,
- 	    unsigned long active, unsigned int n)
- {
- 
- 	return calc_load(load, fixed_power_int(exp, FSHIFT, n), active);
- }
- 
- /*
-  * NO_HZ can leave us missing all per-cpu ticks calling
-  * calc_load_account_active(), but since an idle CPU folds its delta into
-  * calc_load_tasks_idle per calc_load_account_idle(), all we need to do is fold
-  * in the pending idle delta if our idle period crossed a load cycle boundary.
-  *
-  * Once we've updated the global active value, we need to apply the exponential
-  * weights adjusted to the number of cycles missed.
-  */
- static void calc_global_nohz(unsigned long ticks)
- {
- 	long delta, active, n;
- 
- 	if (time_before(jiffies, calc_load_update))
- 		return;
- 
- 	/*
- 	 * If we crossed a calc_load_update boundary, make sure to fold
- 	 * any pending idle changes, the respective CPUs might have
- 	 * missed the tick driven calc_load_account_active() update
- 	 * due to NO_HZ.
- 	 */
- 	delta = calc_load_fold_idle();
- 	if (delta)
- 		atomic_long_add(delta, &calc_load_tasks);
- 
- 	/*
- 	 * If we were idle for multiple load cycles, apply them.
- 	 */
- 	if (ticks >= LOAD_FREQ) {
- 		n = ticks / LOAD_FREQ;
- 
- 		active = atomic_long_read(&calc_load_tasks);
- 		active = active > 0 ? active * FIXED_1 : 0;
- 
- 		avenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);
- 		avenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);
- 		avenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);
- 
- 		calc_load_update += n * LOAD_FREQ;
- 	}
- 
- 	/*
- 	 * Its possible the remainder of the above division also crosses
- 	 * a LOAD_FREQ period, the regular check in calc_global_load()
- 	 * which comes after this will take care of that.
- 	 *
- 	 * Consider us being 11 ticks before a cycle completion, and us
- 	 * sleeping for 4*LOAD_FREQ + 22 ticks, then the above code will
- 	 * age us 4 cycles, and the test in calc_global_load() will
- 	 * pick up the final one.
- 	 */
- }
  #else
  static void calc_load_account_idle(struct rq *this_rq)
  {
--- 2919,2924 ----
***************
*** 3170,3179 ****
  {
  	return 0;
  }
- 
- static void calc_global_nohz(unsigned long ticks)
- {
- }
  #endif
  
  /**
--- 2928,2933 ----
***************
*** 3191,3207 ****
  	loads[2] = (avenrun[2] + offset) << shift;
  }
  
  /*
   * calc_load - update the avenrun load estimates 10 ticks after the
   * CPUs have updated calc_load_tasks.
   */
! void calc_global_load(unsigned long ticks)
  {
  	long active;
  
! 	calc_global_nohz(ticks);
! 
! 	if (time_before(jiffies, calc_load_update + 10))
  		return;
  
  	active = atomic_long_read(&calc_load_tasks);
--- 2945,2968 ----
  	loads[2] = (avenrun[2] + offset) << shift;
  }
  
+ static unsigned long
+ calc_load(unsigned long load, unsigned long exp, unsigned long active)
+ {
+ 	load *= exp;
+ 	load += active * (FIXED_1 - exp);
+ 	return load >> FSHIFT;
+ }
+ 
  /*
   * calc_load - update the avenrun load estimates 10 ticks after the
   * CPUs have updated calc_load_tasks.
   */
! void calc_global_load(void)
  {
+ 	unsigned long upd = calc_load_update + 10;
  	long active;
  
! 	if (time_before(jiffies, upd))
  		return;
  
  	active = atomic_long_read(&calc_load_tasks);
***************
*** 3263,3270 ****
  	}
  
  	calc_load_account_active(this_rq);
- 
- 	sched_avg_update(this_rq);
  }
  
  #ifdef CONFIG_SMP
--- 3024,3029 ----
***************
*** 3318,3324 ****
  
  	if (task_current(rq, p)) {
  		update_rq_clock(rq);
! 		ns = rq->clock_task - p->se.exec_start;
  		if ((s64)ns < 0)
  			ns = 0;
  	}
--- 3077,3083 ----
  
  	if (task_current(rq, p)) {
  		update_rq_clock(rq);
! 		ns = rq->clock - p->se.exec_start;
  		if ((s64)ns < 0)
  			ns = 0;
  	}
***************
*** 3467,3473 ****
  	tmp = cputime_to_cputime64(cputime);
  	if (hardirq_count() - hardirq_offset)
  		cpustat->irq = cputime64_add(cpustat->irq, tmp);
! 	else if (in_serving_softirq())
  		cpustat->softirq = cputime64_add(cpustat->softirq, tmp);
  	else
  		cpustat->system = cputime64_add(cpustat->system, tmp);
--- 3226,3232 ----
  	tmp = cputime_to_cputime64(cputime);
  	if (hardirq_count() - hardirq_offset)
  		cpustat->irq = cputime64_add(cpustat->irq, tmp);
! 	else if (softirq_count())
  		cpustat->softirq = cputime64_add(cpustat->softirq, tmp);
  	else
  		cpustat->system = cputime64_add(cpustat->system, tmp);
***************
*** 3770,3775 ****
--- 3529,3535 ----
  {
  	if (prev->se.on_rq)
  		update_rq_clock(rq);
+ 	rq->skip_clock_update = 0;
  	prev->sched_class->put_prev_task(rq, prev);
  }
  
***************
*** 3832,3837 ****
--- 3592,3598 ----
  		hrtick_clear(rq);
  
  	raw_spin_lock_irq(&rq->lock);
+ 	clear_tsk_need_resched(prev);
  
  	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {
  		if (unlikely(signal_pending_state(prev->state, prev)))
***************
*** 3848,3855 ****
  
  	put_prev_task(rq, prev);
  	next = pick_next_task(rq);
- 	clear_tsk_need_resched(prev);
- 	rq->skip_clock_update = 0;
  
  	if (likely(prev != next)) {
  		sched_info_switch(prev, next);
--- 3609,3614 ----
***************
*** 5398,5416 ****
  	idle->se.exec_start = sched_clock();
  
  	cpumask_copy(&idle->cpus_allowed, cpumask_of(cpu));
- 	/*
- 	 * We're having a chicken and egg problem, even though we are
- 	 * holding rq->lock, the cpu isn't yet set to this cpu so the
- 	 * lockdep check in task_group() will fail.
- 	 *
- 	 * Similar case to sched_fork(). / Alternatively we could
- 	 * use task_rq_lock() here and obtain the other rq->lock.
- 	 *
- 	 * Silence PROVE_RCU
- 	 */
- 	rcu_read_lock();
  	__set_task_cpu(idle, cpu);
- 	rcu_read_unlock();
  
  	rq->curr = rq->idle = idle;
  #if defined(CONFIG_SMP) && defined(__ARCH_WANT_UNLOCKED_CTXSW)
--- 5157,5163 ----
***************
*** 5428,5434 ****
  	 * The idle tasks have their own, simple scheduling class:
  	 */
  	idle->sched_class = &idle_sched_class;
! 	ftrace_graph_init_idle_task(idle, cpu);
  }
  
  /*
--- 5175,5181 ----
  	 * The idle tasks have their own, simple scheduling class:
  	 */
  	idle->sched_class = &idle_sched_class;
! 	ftrace_graph_init_task(idle);
  }
  
  /*
***************
*** 6839,6846 ****
  	if (cpu != group_first_cpu(sd->groups))
  		return;
  
- 	sd->groups->group_weight = cpumask_weight(sched_group_cpus(sd->groups));
- 
  	child = sd->child;
  
  	sd->groups->cpu_power = 0;
--- 6586,6591 ----
***************
*** 8334,8345 ****
  	if (unlikely(running))
  		tsk->sched_class->put_prev_task(rq, tsk);
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	if (tsk->sched_class->task_move_group)
! 		tsk->sched_class->task_move_group(tsk, on_rq);
! 	else
  #endif
- 		set_task_rq(tsk, task_cpu(tsk));
  
  	if (unlikely(running))
  		tsk->sched_class->set_curr_task(rq);
--- 8079,8090 ----
  	if (unlikely(running))
  		tsk->sched_class->put_prev_task(rq, tsk);
  
+ 	set_task_rq(tsk, task_cpu(tsk));
+ 
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	if (tsk->sched_class->moved_group)
! 		tsk->sched_class->moved_group(tsk, on_rq);
  #endif
  
  	if (unlikely(running))
  		tsk->sched_class->set_curr_task(rq);
***************
*** 9225,9229 ****
  EXPORT_SYMBOL_GPL(synchronize_sched_expedited);
  
  #endif /* #else #ifndef CONFIG_SMP */
- 
- EXPORT_SYMBOL_GPL(nr_running);
--- 8970,8972 ----
diff -cBr 2.6.35/kernel/sched_fair.c linux-2.6.35.y-512ac85/kernel/sched_fair.c
*** 2.6.35/kernel/sched_fair.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/sched_fair.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 519,525 ****
  static void update_curr(struct cfs_rq *cfs_rq)
  {
  	struct sched_entity *curr = cfs_rq->curr;
! 	u64 now = rq_of(cfs_rq)->clock_task;
  	unsigned long delta_exec;
  
  	if (unlikely(!curr))
--- 519,525 ----
  static void update_curr(struct cfs_rq *cfs_rq)
  {
  	struct sched_entity *curr = cfs_rq->curr;
! 	u64 now = rq_of(cfs_rq)->clock;
  	unsigned long delta_exec;
  
  	if (unlikely(!curr))
***************
*** 602,608 ****
  	/*
  	 * We are starting a new run period:
  	 */
! 	se->exec_start = rq_of(cfs_rq)->clock_task;
  }
  
  /**************************************************
--- 602,608 ----
  	/*
  	 * We are starting a new run period:
  	 */
! 	se->exec_start = rq_of(cfs_rq)->clock;
  }
  
  /**************************************************
***************
*** 1765,1774 ****
  	set_task_cpu(p, this_cpu);
  	activate_task(this_rq, p, 0);
  	check_preempt_curr(this_rq, p, 0);
- 
- 	/* re-arm NEWIDLE balancing when moving tasks */
- 	src_rq->avg_idle = this_rq->avg_idle = 2*sysctl_sched_migration_cost;
- 	this_rq->idle_stamp = 0;
  }
  
  /*
--- 1765,1770 ----
***************
*** 1803,1809 ****
  	 * 2) too many balance attempts have failed.
  	 */
  
! 	tsk_cache_hot = task_hot(p, rq->clock_task, sd);
  	if (!tsk_cache_hot ||
  		sd->nr_balance_failed > sd->cache_nice_tries) {
  #ifdef CONFIG_SCHEDSTATS
--- 1799,1805 ----
  	 * 2) too many balance attempts have failed.
  	 */
  
! 	tsk_cache_hot = task_hot(p, rq->clock, sd);
  	if (!tsk_cache_hot ||
  		sd->nr_balance_failed > sd->cache_nice_tries) {
  #ifdef CONFIG_SCHEDSTATS
***************
*** 2035,2051 ****
  	unsigned long this_load;
  	unsigned long this_load_per_task;
  	unsigned long this_nr_running;
- 	unsigned long this_has_capacity;
- 	unsigned int  this_idle_cpus;
  
  	/* Statistics of the busiest group */
- 	unsigned int  busiest_idle_cpus;
  	unsigned long max_load;
  	unsigned long busiest_load_per_task;
  	unsigned long busiest_nr_running;
  	unsigned long busiest_group_capacity;
- 	unsigned long busiest_has_capacity;
- 	unsigned int  busiest_group_weight;
  
  	int group_imb; /* Is there imbalance in this sd */
  #if defined(CONFIG_SCHED_MC) || defined(CONFIG_SCHED_SMT)
--- 2031,2042 ----
***************
*** 2067,2076 ****
  	unsigned long sum_nr_running; /* Nr tasks running in the group */
  	unsigned long sum_weighted_load; /* Weighted load of group's tasks */
  	unsigned long group_capacity;
- 	unsigned long idle_cpus;
- 	unsigned long group_weight;
  	int group_imb; /* Is there an imbalance in the group ? */
- 	int group_has_capacity; /* Is there extra capacity in the group? */
  };
  
  /**
--- 2058,2064 ----
***************
*** 2280,2293 ****
  	struct rq *rq = cpu_rq(cpu);
  	u64 total, available;
  
  	total = sched_avg_period() + (rq->clock - rq->age_stamp);
  
- 	if (unlikely(total < rq->rt_avg)) {
- 		/* Ensures that power won't end up being negative */
- 		available = 0;
- 	} else {
- 		available = total - rq->rt_avg;
- 	}
  	if (unlikely((s64)total < SCHED_LOAD_SCALE))
  		total = SCHED_LOAD_SCALE;
  
--- 2268,2278 ----
  	struct rq *rq = cpu_rq(cpu);
  	u64 total, available;
  
+ 	sched_avg_update(rq);
+ 
  	total = sched_avg_period() + (rq->clock - rq->age_stamp);
+ 	available = total - rq->rt_avg;
  
  	if (unlikely((s64)total < SCHED_LOAD_SCALE))
  		total = SCHED_LOAD_SCALE;
  
***************
*** 2369,2375 ****
  			int local_group, const struct cpumask *cpus,
  			int *balance, struct sg_lb_stats *sgs)
  {
! 	unsigned long load, max_cpu_load, min_cpu_load, max_nr_running;
  	int i;
  	unsigned int balance_cpu = -1, first_idle_cpu = 0;
  	unsigned long avg_load_per_task = 0;
--- 2354,2360 ----
  			int local_group, const struct cpumask *cpus,
  			int *balance, struct sg_lb_stats *sgs)
  {
! 	unsigned long load, max_cpu_load, min_cpu_load;
  	int i;
  	unsigned int balance_cpu = -1, first_idle_cpu = 0;
  	unsigned long avg_load_per_task = 0;
***************
*** 2380,2386 ****
  	/* Tally up the load of all CPUs in the group */
  	max_cpu_load = 0;
  	min_cpu_load = ~0UL;
- 	max_nr_running = 0;
  
  	for_each_cpu_and(i, sched_group_cpus(group), cpus) {
  		struct rq *rq = cpu_rq(i);
--- 2365,2370 ----
***************
*** 2398,2407 ****
  			load = target_load(i, load_idx);
  		} else {
  			load = source_load(i, load_idx);
! 			if (load > max_cpu_load) {
  				max_cpu_load = load;
- 				max_nr_running = rq->nr_running;
- 			}
  			if (min_cpu_load > load)
  				min_cpu_load = load;
  		}
--- 2382,2389 ----
  			load = target_load(i, load_idx);
  		} else {
  			load = source_load(i, load_idx);
! 			if (load > max_cpu_load)
  				max_cpu_load = load;
  			if (min_cpu_load > load)
  				min_cpu_load = load;
  		}
***************
*** 2409,2416 ****
  		sgs->group_load += load;
  		sgs->sum_nr_running += rq->nr_running;
  		sgs->sum_weighted_load += weighted_cpuload(i);
! 		if (idle_cpu(i))
! 			sgs->idle_cpus++;
  	}
  
  	/*
--- 2391,2397 ----
  		sgs->group_load += load;
  		sgs->sum_nr_running += rq->nr_running;
  		sgs->sum_weighted_load += weighted_cpuload(i);
! 
  	}
  
  	/*
***************
*** 2442,2455 ****
  	if (sgs->sum_nr_running)
  		avg_load_per_task = sgs->sum_weighted_load / sgs->sum_nr_running;
  
! 	if ((max_cpu_load - min_cpu_load) > 2*avg_load_per_task && max_nr_running > 1)
  		sgs->group_imb = 1;
  
! 	sgs->group_capacity = DIV_ROUND_CLOSEST(group->cpu_power, SCHED_LOAD_SCALE);
! 	sgs->group_weight = group->group_weight;
! 
! 	if (sgs->group_capacity > sgs->sum_nr_running)
! 		sgs->group_has_capacity = 1;
  }
  
  /**
--- 2423,2433 ----
  	if (sgs->sum_nr_running)
  		avg_load_per_task = sgs->sum_weighted_load / sgs->sum_nr_running;
  
! 	if ((max_cpu_load - min_cpu_load) > 2*avg_load_per_task)
  		sgs->group_imb = 1;
  
! 	sgs->group_capacity =
! 		DIV_ROUND_CLOSEST(group->cpu_power, SCHED_LOAD_SCALE);
  }
  
  /**
***************
*** 2496,2509 ****
  		/*
  		 * In case the child domain prefers tasks go to siblings
  		 * first, lower the group capacity to one so that we'll try
! 		 * and move all the excess tasks away. We lower the capacity
! 		 * of a group only if the local group has the capacity to fit
! 		 * these excess tasks, i.e. nr_running < group_capacity. The
! 		 * extra check prevents the case where you always pull from the
! 		 * heaviest group when it is already under-utilized (possible
! 		 * with a large weight task outweighs the tasks on the system).
  		 */
! 		if (prefer_sibling && !local_group && sds->this_has_capacity)
  			sgs.group_capacity = min(sgs.group_capacity, 1UL);
  
  		if (local_group) {
--- 2474,2482 ----
  		/*
  		 * In case the child domain prefers tasks go to siblings
  		 * first, lower the group capacity to one so that we'll try
! 		 * and move all the excess tasks away.
  		 */
! 		if (prefer_sibling)
  			sgs.group_capacity = min(sgs.group_capacity, 1UL);
  
  		if (local_group) {
***************
*** 2511,2529 ****
  			sds->this = group;
  			sds->this_nr_running = sgs.sum_nr_running;
  			sds->this_load_per_task = sgs.sum_weighted_load;
- 			sds->this_has_capacity = sgs.group_has_capacity;
- 			sds->this_idle_cpus = sgs.idle_cpus;
  		} else if (sgs.avg_load > sds->max_load &&
  			   (sgs.sum_nr_running > sgs.group_capacity ||
  				sgs.group_imb)) {
  			sds->max_load = sgs.avg_load;
  			sds->busiest = group;
  			sds->busiest_nr_running = sgs.sum_nr_running;
- 			sds->busiest_idle_cpus = sgs.idle_cpus;
  			sds->busiest_group_capacity = sgs.group_capacity;
- 			sds->busiest_group_weight = sgs.group_weight;
  			sds->busiest_load_per_task = sgs.sum_weighted_load;
- 			sds->busiest_has_capacity = sgs.group_has_capacity;
  			sds->group_imb = sgs.group_imb;
  		}
  
--- 2484,2497 ----
***************
*** 2720,2730 ****
  	 * 4) This group is more busy than the avg busieness at this
  	 *    sched_domain.
  	 * 5) The imbalance is within the specified limit.
- 	 *
- 	 * Note: when doing newidle balance, if the local group has excess
- 	 * capacity (i.e. nr_running < group_capacity) and the busiest group
- 	 * does not have any capacity, we force a load balance to pull tasks
- 	 * to the local group. In this case, we skip past checks 3, 4 and 5.
  	 */
  	if (!(*balance))
  		goto ret;
--- 2688,2693 ----
***************
*** 2732,2742 ****
  	if (!sds.busiest || sds.busiest_nr_running == 0)
  		goto out_balanced;
  
- 	/*  SD_BALANCE_NEWIDLE trumps SMP nice when underutilized */
- 	if (idle == CPU_NEWLY_IDLE && sds.this_has_capacity &&
- 			!sds.busiest_has_capacity)
- 		goto force_balance;
- 
  	if (sds.this_load >= sds.max_load)
  		goto out_balanced;
  
--- 2695,2700 ----
***************
*** 2745,2772 ****
  	if (sds.this_load >= sds.avg_load)
  		goto out_balanced;
  
! 	/*
! 	 * In the CPU_NEWLY_IDLE, use imbalance_pct to be conservative.
! 	 * And to check for busy balance use !idle_cpu instead of
! 	 * CPU_NOT_IDLE. This is because HT siblings will use CPU_NOT_IDLE
! 	 * even when they are idle.
! 	 */
! 	if (idle == CPU_NEWLY_IDLE || !idle_cpu(this_cpu)) {
! 		if (100 * sds.max_load <= sd->imbalance_pct * sds.this_load)
! 			goto out_balanced;
! 	} else {
! 		/*
! 		 * This cpu is idle. If the busiest group load doesn't
! 		 * have more tasks than the number of available cpu's and
! 		 * there is no imbalance between this and busiest group
! 		 * wrt to idle cpu's, it is balanced.
! 		 */
! 		if ((sds.this_idle_cpus  <= sds.busiest_idle_cpus + 1) &&
! 		    sds.busiest_nr_running <= sds.busiest_group_weight)
! 			goto out_balanced;
! 	}
  
- force_balance:
  	/* Looks like there is an imbalance. Compute it */
  	calculate_imbalance(&sds, this_cpu, imbalance);
  	return sds.busiest;
--- 2703,2711 ----
  	if (sds.this_load >= sds.avg_load)
  		goto out_balanced;
  
! 	if (100 * sds.max_load <= sd->imbalance_pct * sds.this_load)
! 		goto out_balanced;
  
  	/* Looks like there is an imbalance. Compute it */
  	calculate_imbalance(&sds, this_cpu, imbalance);
  	return sds.busiest;
***************
*** 2957,2970 ****
  
  	if (!ld_moved) {
  		schedstat_inc(sd, lb_failed[idle]);
! 		/*
! 		 * Increment the failure counter only on periodic balance.
! 		 * We do not want newidle balance, which can be very
! 		 * frequent, pollute the failure counter causing
! 		 * excessive cache_hot migrations and active balances.
! 		 */
! 		if (idle != CPU_NEWLY_IDLE)
! 			sd->nr_balance_failed++;
  
  		if (need_active_balance(sd, sd_idle, idle)) {
  			raw_spin_lock_irqsave(&busiest->lock, flags);
--- 2896,2902 ----
  
  	if (!ld_moved) {
  		schedstat_inc(sd, lb_failed[idle]);
! 		sd->nr_balance_failed++;
  
  		if (need_active_balance(sd, sd_idle, idle)) {
  			raw_spin_lock_irqsave(&busiest->lock, flags);
***************
*** 3085,3092 ****
  		interval = msecs_to_jiffies(sd->balance_interval);
  		if (time_after(next_balance, sd->last_balance + interval))
  			next_balance = sd->last_balance + interval;
! 		if (pulled_task)
  			break;
  	}
  
  	raw_spin_lock(&this_rq->lock);
--- 3017,3026 ----
  		interval = msecs_to_jiffies(sd->balance_interval);
  		if (time_after(next_balance, sd->last_balance + interval))
  			next_balance = sd->last_balance + interval;
! 		if (pulled_task) {
! 			this_rq->idle_stamp = 0;
  			break;
+ 		}
  	}
  
  	raw_spin_lock(&this_rq->lock);
***************
*** 3608,3618 ****
  
  	raw_spin_lock_irqsave(&rq->lock, flags);
  
! 	if (unlikely(task_cpu(p) != this_cpu)) {
! 		rcu_read_lock();
  		__set_task_cpu(p, this_cpu);
- 		rcu_read_unlock();
- 	}
  
  	update_curr(cfs_rq);
  
--- 3542,3549 ----
  
  	raw_spin_lock_irqsave(&rq->lock, flags);
  
! 	if (unlikely(task_cpu(p) != this_cpu))
  		__set_task_cpu(p, this_cpu);
  
  	update_curr(cfs_rq);
  
***************
*** 3684,3709 ****
  }
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! static void task_move_group_fair(struct task_struct *p, int on_rq)
  {
! 	/*
! 	 * If the task was not on the rq at the time of this cgroup movement
! 	 * it must have been asleep, sleeping tasks keep their ->vruntime
! 	 * absolute on their old rq until wakeup (needed for the fair sleeper
! 	 * bonus in place_entity()).
! 	 *
! 	 * If it was on the rq, we've just 'preempted' it, which does convert
! 	 * ->vruntime to a relative base.
! 	 *
! 	 * Make sure both cases convert their relative position when migrating
! 	 * to another cgroup's rq. This does somewhat interfere with the
! 	 * fair sleeper stuff for the first placement, but who cares.
! 	 */
! 	if (!on_rq)
! 		p->se.vruntime -= cfs_rq_of(&p->se)->min_vruntime;
! 	set_task_rq(p, task_cpu(p));
  	if (!on_rq)
! 		p->se.vruntime += cfs_rq_of(&p->se)->min_vruntime;
  }
  #endif
  
--- 3615,3627 ----
  }
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! static void moved_group_fair(struct task_struct *p, int on_rq)
  {
! 	struct cfs_rq *cfs_rq = task_cfs_rq(p);
! 
! 	update_curr(cfs_rq);
  	if (!on_rq)
! 		place_entity(cfs_rq, &p->se, 1);
  }
  #endif
  
***************
*** 3755,3761 ****
  	.get_rr_interval	= get_rr_interval_fair,
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	.task_move_group	= task_move_group_fair,
  #endif
  };
  
--- 3673,3679 ----
  	.get_rr_interval	= get_rr_interval_fair,
  
  #ifdef CONFIG_FAIR_GROUP_SCHED
! 	.moved_group		= moved_group_fair,
  #endif
  };
  
diff -cBr 2.6.35/kernel/sched_features.h linux-2.6.35.y-512ac85/kernel/sched_features.h
*** 2.6.35/kernel/sched_features.h	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/sched_features.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 61,68 ****
   * release the lock. Decreases scheduling overhead.
   */
  SCHED_FEAT(OWNER_SPIN, 1)
- 
- /*
-  * Decrement CPU power based on irq activity
-  */
- SCHED_FEAT(NONIRQ_POWER, 1)
--- 61,63 ----
diff -cBr 2.6.35/kernel/sched_rt.c linux-2.6.35.y-512ac85/kernel/sched_rt.c
*** 2.6.35/kernel/sched_rt.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/sched_rt.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 609,615 ****
  	if (!task_has_rt_policy(curr))
  		return;
  
! 	delta_exec = rq->clock_task - curr->se.exec_start;
  	if (unlikely((s64)delta_exec < 0))
  		delta_exec = 0;
  
--- 609,615 ----
  	if (!task_has_rt_policy(curr))
  		return;
  
! 	delta_exec = rq->clock - curr->se.exec_start;
  	if (unlikely((s64)delta_exec < 0))
  		delta_exec = 0;
  
***************
*** 618,624 ****
  	curr->se.sum_exec_runtime += delta_exec;
  	account_group_exec_runtime(curr, delta_exec);
  
! 	curr->se.exec_start = rq->clock_task;
  	cpuacct_charge(curr, delta_exec);
  
  	sched_rt_avg_update(rq, delta_exec);
--- 618,624 ----
  	curr->se.sum_exec_runtime += delta_exec;
  	account_group_exec_runtime(curr, delta_exec);
  
! 	curr->se.exec_start = rq->clock;
  	cpuacct_charge(curr, delta_exec);
  
  	sched_rt_avg_update(rq, delta_exec);
***************
*** 960,978 ****
  	 * runqueue. Otherwise simply start this RT task
  	 * on its current runqueue.
  	 *
! 	 * We want to avoid overloading runqueues. If the woken
! 	 * task is a higher priority, then it will stay on this CPU
! 	 * and the lower prio task should be moved to another CPU.
! 	 * Even though this will probably make the lower prio task
! 	 * lose its cache, we do not want to bounce a higher task
! 	 * around just because it gave up its CPU, perhaps for a
! 	 * lock?
! 	 *
! 	 * For equal prio tasks, we just let the scheduler sort it out.
  	 */
  	if (unlikely(rt_task(rq->curr)) &&
- 	    (rq->curr->rt.nr_cpus_allowed < 2 ||
- 	     rq->curr->prio < p->prio) &&
  	    (p->rt.nr_cpus_allowed > 1)) {
  		int cpu = find_lowest_rq(p);
  
--- 960,977 ----
  	 * runqueue. Otherwise simply start this RT task
  	 * on its current runqueue.
  	 *
! 	 * We want to avoid overloading runqueues. Even if
! 	 * the RT task is of higher priority than the current RT task.
! 	 * RT tasks behave differently than other tasks. If
! 	 * one gets preempted, we try to push it off to another queue.
! 	 * So trying to keep a preempting RT task on the same
! 	 * cache hot CPU will force the running RT task to
! 	 * a cold CPU. So we waste all the cache for the lower
! 	 * RT task in hopes of saving some of a RT task
! 	 * that is just being woken and probably will have
! 	 * cold cache anyway.
  	 */
  	if (unlikely(rt_task(rq->curr)) &&
  	    (p->rt.nr_cpus_allowed > 1)) {
  		int cpu = find_lowest_rq(p);
  
***************
*** 1075,1081 ****
  	} while (rt_rq);
  
  	p = rt_task_of(rt_se);
! 	p->se.exec_start = rq->clock_task;
  
  	return p;
  }
--- 1074,1080 ----
  	} while (rt_rq);
  
  	p = rt_task_of(rt_se);
! 	p->se.exec_start = rq->clock;
  
  	return p;
  }
***************
*** 1492,1501 ****
  	if (!task_running(rq, p) &&
  	    !test_tsk_need_resched(rq->curr) &&
  	    has_pushable_tasks(rq) &&
! 	    p->rt.nr_cpus_allowed > 1 &&
! 	    rt_task(rq->curr) &&
! 	    (rq->curr->rt.nr_cpus_allowed < 2 ||
! 	     rq->curr->prio < p->prio))
  		push_rt_tasks(rq);
  }
  
--- 1491,1497 ----
  	if (!task_running(rq, p) &&
  	    !test_tsk_need_resched(rq->curr) &&
  	    has_pushable_tasks(rq) &&
! 	    p->rt.nr_cpus_allowed > 1)
  		push_rt_tasks(rq);
  }
  
***************
*** 1716,1722 ****
  {
  	struct task_struct *p = rq->curr;
  
! 	p->se.exec_start = rq->clock_task;
  
  	/* The running task is never eligible for pushing */
  	dequeue_pushable_task(rq, p);
--- 1712,1718 ----
  {
  	struct task_struct *p = rq->curr;
  
! 	p->se.exec_start = rq->clock;
  
  	/* The running task is never eligible for pushing */
  	dequeue_pushable_task(rq, p);
diff -cBr 2.6.35/kernel/signal.c linux-2.6.35.y-512ac85/kernel/signal.c
*** 2.6.35/kernel/signal.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/signal.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2410,2422 ****
  		return -EFAULT;
  
  	/* Not even root can pretend to send signals from the kernel.
! 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
! 	 */
! 	if (info.si_code >= 0 || info.si_code == SI_TKILL) {
! 		/* We used to allow any < 0 si_code */
! 		WARN_ON_ONCE(info.si_code < 0);
  		return -EPERM;
- 	}
  	info.si_signo = sig;
  
  	/* POSIX.1b doesn't mention process groups.  */
--- 2410,2418 ----
  		return -EFAULT;
  
  	/* Not even root can pretend to send signals from the kernel.
! 	   Nor can they impersonate a kill(), which adds source info.  */
! 	if (info.si_code >= 0)
  		return -EPERM;
  	info.si_signo = sig;
  
  	/* POSIX.1b doesn't mention process groups.  */
***************
*** 2430,2442 ****
  		return -EINVAL;
  
  	/* Not even root can pretend to send signals from the kernel.
! 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
! 	 */
! 	if (info->si_code >= 0 || info->si_code == SI_TKILL) {
! 		/* We used to allow any < 0 si_code */
! 		WARN_ON_ONCE(info->si_code < 0);
  		return -EPERM;
- 	}
  	info->si_signo = sig;
  
  	return do_send_specific(tgid, pid, sig, info);
--- 2426,2434 ----
  		return -EINVAL;
  
  	/* Not even root can pretend to send signals from the kernel.
! 	   Nor can they impersonate a kill(), which adds source info.  */
! 	if (info->si_code >= 0)
  		return -EPERM;
  	info->si_signo = sig;
  
  	return do_send_specific(tgid, pid, sig, info);
diff -cBr 2.6.35/kernel/smp.c linux-2.6.35.y-512ac85/kernel/smp.c
*** 2.6.35/kernel/smp.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/smp.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 194,217 ****
  	list_for_each_entry_rcu(data, &call_function.queue, csd.list) {
  		int refs;
  
- 		/*
- 		 * Since we walk the list without any locks, we might
- 		 * see an entry that was completed, removed from the
- 		 * list and is in the process of being reused.
- 		 *
- 		 * We must check that the cpu is in the cpumask before
- 		 * checking the refs, and both must be set before
- 		 * executing the callback on this cpu.
- 		 */
- 
- 		if (!cpumask_test_cpu(cpu, data->cpumask))
- 			continue;
- 
- 		smp_rmb();
- 
- 		if (atomic_read(&data->refs) == 0)
- 			continue;
- 
  		if (!cpumask_test_and_clear_cpu(cpu, data->cpumask))
  			continue;
  
--- 194,199 ----
***************
*** 427,433 ****
  {
  	struct call_function_data *data;
  	unsigned long flags;
! 	int refs, cpu, next_cpu, this_cpu = smp_processor_id();
  
  	/*
  	 * Can deadlock when called with interrupts disabled.
--- 409,415 ----
  {
  	struct call_function_data *data;
  	unsigned long flags;
! 	int cpu, next_cpu, this_cpu = smp_processor_id();
  
  	/*
  	 * Can deadlock when called with interrupts disabled.
***************
*** 438,444 ****
  	WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
  		     && !oops_in_progress);
  
! 	/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */
  	cpu = cpumask_first_and(mask, cpu_online_mask);
  	if (cpu == this_cpu)
  		cpu = cpumask_next_and(cpu, mask, cpu_online_mask);
--- 420,426 ----
  	WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
  		     && !oops_in_progress);
  
! 	/* So, what's a CPU they want? Ignoring this one. */
  	cpu = cpumask_first_and(mask, cpu_online_mask);
  	if (cpu == this_cpu)
  		cpu = cpumask_next_and(cpu, mask, cpu_online_mask);
***************
*** 461,508 ****
  	data = &__get_cpu_var(cfd_data);
  	csd_lock(&data->csd);
  
- 	/* This BUG_ON verifies our reuse assertions and can be removed */
- 	BUG_ON(atomic_read(&data->refs) || !cpumask_empty(data->cpumask));
- 
- 	/*
- 	 * The global call function queue list add and delete are protected
- 	 * by a lock, but the list is traversed without any lock, relying
- 	 * on the rcu list add and delete to allow safe concurrent traversal.
- 	 * We reuse the call function data without waiting for any grace
- 	 * period after some other cpu removes it from the global queue.
- 	 * This means a cpu might find our data block as it is being
- 	 * filled out.
- 	 *
- 	 * We hold off the interrupt handler on the other cpu by
- 	 * ordering our writes to the cpu mask vs our setting of the
- 	 * refs counter.  We assert only the cpu owning the data block
- 	 * will set a bit in cpumask, and each bit will only be cleared
- 	 * by the subject cpu.  Each cpu must first find its bit is
- 	 * set and then check that refs is set indicating the element is
- 	 * ready to be processed, otherwise it must skip the entry.
- 	 *
- 	 * On the previous iteration refs was set to 0 by another cpu.
- 	 * To avoid the use of transitivity, set the counter to 0 here
- 	 * so the wmb will pair with the rmb in the interrupt handler.
- 	 */
- 	atomic_set(&data->refs, 0);	/* convert 3rd to 1st party write */
- 
  	data->csd.func = func;
  	data->csd.info = info;
- 
- 	/* Ensure 0 refs is visible before mask.  Also orders func and info */
- 	smp_wmb();
- 
- 	/* We rely on the "and" being processed before the store */
  	cpumask_and(data->cpumask, mask, cpu_online_mask);
  	cpumask_clear_cpu(this_cpu, data->cpumask);
! 	refs = cpumask_weight(data->cpumask);
! 
! 	/* Some callers race with other cpus changing the passed mask */
! 	if (unlikely(!refs)) {
! 		csd_unlock(&data->csd);
! 		return;
! 	}
  
  	raw_spin_lock_irqsave(&call_function.lock, flags);
  	/*
--- 443,453 ----
  	data = &__get_cpu_var(cfd_data);
  	csd_lock(&data->csd);
  
  	data->csd.func = func;
  	data->csd.info = info;
  	cpumask_and(data->cpumask, mask, cpu_online_mask);
  	cpumask_clear_cpu(this_cpu, data->cpumask);
! 	atomic_set(&data->refs, cpumask_weight(data->cpumask));
  
  	raw_spin_lock_irqsave(&call_function.lock, flags);
  	/*
***************
*** 511,522 ****
  	 * will not miss any other list entries:
  	 */
  	list_add_rcu(&data->csd.list, &call_function.queue);
- 	/*
- 	 * We rely on the wmb() in list_add_rcu to complete our writes
- 	 * to the cpumask before this write to refs, which indicates
- 	 * data is on the list and is ready to be processed.
- 	 */
- 	atomic_set(&data->refs, refs);
  	raw_spin_unlock_irqrestore(&call_function.lock, flags);
  
  	/*
--- 456,461 ----
diff -cBr 2.6.35/kernel/softirq.c linux-2.6.35.y-512ac85/kernel/softirq.c
*** 2.6.35/kernel/softirq.c	2011-05-07 19:57:51.956750026 -0400
--- linux-2.6.35.y-512ac85/kernel/softirq.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 77,97 ****
  }
  
  /*
-  * preempt_count and SOFTIRQ_OFFSET usage:
-  * - preempt_count is changed by SOFTIRQ_OFFSET on entering or leaving
-  *   softirq processing.
-  * - preempt_count is changed by SOFTIRQ_DISABLE_OFFSET (= 2 * SOFTIRQ_OFFSET)
-  *   on local_bh_disable or local_bh_enable.
-  * This lets us distinguish between whether we are currently processing
-  * softirq and whether we just have bh disabled.
-  */
- 
- /*
   * This one is for softirq.c-internal use,
   * where hardirqs are disabled legitimately:
   */
  #ifdef CONFIG_TRACE_IRQFLAGS
! static void __local_bh_disable(unsigned long ip, unsigned int cnt)
  {
  	unsigned long flags;
  
--- 77,87 ----
  }
  
  /*
   * This one is for softirq.c-internal use,
   * where hardirqs are disabled legitimately:
   */
  #ifdef CONFIG_TRACE_IRQFLAGS
! static void __local_bh_disable(unsigned long ip)
  {
  	unsigned long flags;
  
***************
*** 105,147 ****
  	 * We must manually increment preempt_count here and manually
  	 * call the trace_preempt_off later.
  	 */
! 	preempt_count() += cnt;
  	/*
  	 * Were softirqs turned off above:
  	 */
! 	if (softirq_count() == cnt)
  		trace_softirqs_off(ip);
  	raw_local_irq_restore(flags);
  
! 	if (preempt_count() == cnt)
  		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
  }
  #else /* !CONFIG_TRACE_IRQFLAGS */
! static inline void __local_bh_disable(unsigned long ip, unsigned int cnt)
  {
! 	add_preempt_count(cnt);
  	barrier();
  }
  #endif /* CONFIG_TRACE_IRQFLAGS */
  
  void local_bh_disable(void)
  {
! 	__local_bh_disable((unsigned long)__builtin_return_address(0),
! 				SOFTIRQ_DISABLE_OFFSET);
  }
  
  EXPORT_SYMBOL(local_bh_disable);
  
- static void __local_bh_enable(unsigned int cnt)
- {
- 	WARN_ON_ONCE(in_irq());
- 	WARN_ON_ONCE(!irqs_disabled());
- 
- 	if (softirq_count() == cnt)
- 		trace_softirqs_on((unsigned long)__builtin_return_address(0));
- 	sub_preempt_count(cnt);
- }
- 
  /*
   * Special-case - softirqs can safely be enabled in
   * cond_resched_softirq(), or by __do_softirq(),
--- 95,126 ----
  	 * We must manually increment preempt_count here and manually
  	 * call the trace_preempt_off later.
  	 */
! 	preempt_count() += SOFTIRQ_OFFSET;
  	/*
  	 * Were softirqs turned off above:
  	 */
! 	if (softirq_count() == SOFTIRQ_OFFSET)
  		trace_softirqs_off(ip);
  	raw_local_irq_restore(flags);
  
! 	if (preempt_count() == SOFTIRQ_OFFSET)
  		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
  }
  #else /* !CONFIG_TRACE_IRQFLAGS */
! static inline void __local_bh_disable(unsigned long ip)
  {
! 	add_preempt_count(SOFTIRQ_OFFSET);
  	barrier();
  }
  #endif /* CONFIG_TRACE_IRQFLAGS */
  
  void local_bh_disable(void)
  {
! 	__local_bh_disable((unsigned long)__builtin_return_address(0));
  }
  
  EXPORT_SYMBOL(local_bh_disable);
  
  /*
   * Special-case - softirqs can safely be enabled in
   * cond_resched_softirq(), or by __do_softirq(),
***************
*** 149,155 ****
   */
  void _local_bh_enable(void)
  {
! 	__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);
  }
  
  EXPORT_SYMBOL(_local_bh_enable);
--- 128,139 ----
   */
  void _local_bh_enable(void)
  {
! 	WARN_ON_ONCE(in_irq());
! 	WARN_ON_ONCE(!irqs_disabled());
! 
! 	if (softirq_count() == SOFTIRQ_OFFSET)
! 		trace_softirqs_on((unsigned long)__builtin_return_address(0));
! 	sub_preempt_count(SOFTIRQ_OFFSET);
  }
  
  EXPORT_SYMBOL(_local_bh_enable);
***************
*** 163,175 ****
  	/*
  	 * Are softirqs going to be turned on now:
  	 */
! 	if (softirq_count() == SOFTIRQ_DISABLE_OFFSET)
  		trace_softirqs_on(ip);
  	/*
  	 * Keep preemption disabled until we are done with
  	 * softirq processing:
   	 */
! 	sub_preempt_count(SOFTIRQ_DISABLE_OFFSET - 1);
  
  	if (unlikely(!in_interrupt() && local_softirq_pending()))
  		do_softirq();
--- 147,159 ----
  	/*
  	 * Are softirqs going to be turned on now:
  	 */
! 	if (softirq_count() == SOFTIRQ_OFFSET)
  		trace_softirqs_on(ip);
  	/*
  	 * Keep preemption disabled until we are done with
  	 * softirq processing:
   	 */
!  	sub_preempt_count(SOFTIRQ_OFFSET - 1);
  
  	if (unlikely(!in_interrupt() && local_softirq_pending()))
  		do_softirq();
***************
*** 214,221 ****
  	pending = local_softirq_pending();
  	account_system_vtime(current);
  
! 	__local_bh_disable((unsigned long)__builtin_return_address(0),
! 				SOFTIRQ_OFFSET);
  	lockdep_softirq_enter();
  
  	cpu = smp_processor_id();
--- 198,204 ----
  	pending = local_softirq_pending();
  	account_system_vtime(current);
  
! 	__local_bh_disable((unsigned long)__builtin_return_address(0));
  	lockdep_softirq_enter();
  
  	cpu = smp_processor_id();
***************
*** 262,268 ****
  	lockdep_softirq_exit();
  
  	account_system_vtime(current);
! 	__local_bh_enable(SOFTIRQ_OFFSET);
  }
  
  #ifndef __ARCH_HAS_DO_SOFTIRQ
--- 245,251 ----
  	lockdep_softirq_exit();
  
  	account_system_vtime(current);
! 	_local_bh_enable();
  }
  
  #ifndef __ARCH_HAS_DO_SOFTIRQ
***************
*** 296,311 ****
  
  	rcu_irq_enter();
  	if (idle_cpu(cpu) && !in_interrupt()) {
! 		/*
! 		 * Prevent raise_softirq from needlessly waking up ksoftirqd
! 		 * here, as softirq will be serviced on return from interrupt.
! 		 */
! 		local_bh_disable();
  		tick_check_idle(cpu);
! 		_local_bh_enable();
! 	}
! 
! 	__irq_enter();
  }
  
  #ifdef __ARCH_IRQ_EXIT_IRQS_DISABLED
--- 279,288 ----
  
  	rcu_irq_enter();
  	if (idle_cpu(cpu) && !in_interrupt()) {
! 		__irq_enter();
  		tick_check_idle(cpu);
! 	} else
! 		__irq_enter();
  }
  
  #ifdef __ARCH_IRQ_EXIT_IRQS_DISABLED
***************
*** 719,725 ****
  {
  	set_current_state(TASK_INTERRUPTIBLE);
  
- 	current->flags |= PF_KSOFTIRQD;
  	while (!kthread_should_stop()) {
  		preempt_disable();
  		if (!local_softirq_pending()) {
--- 696,701 ----
diff -cBr 2.6.35/kernel/time/tick-broadcast.c linux-2.6.35.y-512ac85/kernel/time/tick-broadcast.c
*** 2.6.35/kernel/time/tick-broadcast.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/time/tick-broadcast.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 600,613 ****
  	return tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;
  }
  
- /*
-  * Check whether the broadcast device supports oneshot.
-  */
- bool tick_broadcast_oneshot_available(void)
- {
- 	struct clock_event_device *bc = tick_broadcast_device.evtdev;
- 
- 	return bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;
- }
- 
  #endif
--- 600,603 ----
diff -cBr 2.6.35/kernel/time/tick-common.c linux-2.6.35.y-512ac85/kernel/time/tick-common.c
*** 2.6.35/kernel/time/tick-common.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/time/tick-common.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 51,61 ****
  {
  	struct clock_event_device *dev = __get_cpu_var(tick_cpu_device).evtdev;
  
! 	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))
! 		return 0;
! 	if (!(dev->features & CLOCK_EVT_FEAT_C3STOP))
! 		return 1;
! 	return tick_broadcast_oneshot_available();
  }
  
  /*
--- 51,57 ----
  {
  	struct clock_event_device *dev = __get_cpu_var(tick_cpu_device).evtdev;
  
! 	return dev && (dev->features & CLOCK_EVT_FEAT_ONESHOT);
  }
  
  /*
diff -cBr 2.6.35/kernel/time/tick-internal.h linux-2.6.35.y-512ac85/kernel/time/tick-internal.h
*** 2.6.35/kernel/time/tick-internal.h	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/time/tick-internal.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 36,42 ****
  extern int tick_resume_broadcast_oneshot(struct clock_event_device *bc);
  extern int tick_broadcast_oneshot_active(void);
  extern void tick_check_oneshot_broadcast(int cpu);
- bool tick_broadcast_oneshot_available(void);
  # else /* BROADCAST */
  static inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc)
  {
--- 36,41 ----
***************
*** 47,53 ****
  static inline void tick_shutdown_broadcast_oneshot(unsigned int *cpup) { }
  static inline int tick_broadcast_oneshot_active(void) { return 0; }
  static inline void tick_check_oneshot_broadcast(int cpu) { }
- static inline bool tick_broadcast_oneshot_available(void) { return true; }
  # endif /* !BROADCAST */
  
  #else /* !ONESHOT */
--- 46,51 ----
***************
*** 78,84 ****
  	return 0;
  }
  static inline int tick_broadcast_oneshot_active(void) { return 0; }
- static inline bool tick_broadcast_oneshot_available(void) { return false; }
  #endif /* !TICK_ONESHOT */
  
  /*
--- 76,81 ----
diff -cBr 2.6.35/kernel/timer.c linux-2.6.35.y-512ac85/kernel/timer.c
*** 2.6.35/kernel/timer.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/timer.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1237,1248 ****
  	struct tvec_base *base = __get_cpu_var(tvec_bases);
  	unsigned long expires;
  
- 	/*
- 	 * Pretend that there is no timer pending if the cpu is offline.
- 	 * Possible pending timers will be migrated later to an active cpu.
- 	 */
- 	if (cpu_is_offline(smp_processor_id()))
- 		return now + NEXT_TIMER_MAX_DELTA;
  	spin_lock(&base->lock);
  	if (time_before_eq(base->next_timer, base->timer_jiffies))
  		base->next_timer = __next_timer_interrupt(base);
--- 1237,1242 ----
***************
*** 1308,1314 ****
  {
  	jiffies_64 += ticks;
  	update_wall_time();
! 	calc_global_load(ticks);
  }
  
  #ifdef __ARCH_WANT_SYS_ALARM
--- 1302,1308 ----
  {
  	jiffies_64 += ticks;
  	update_wall_time();
! 	calc_global_load();
  }
  
  #ifdef __ARCH_WANT_SYS_ALARM
diff -cBr 2.6.35/kernel/trace/ftrace.c linux-2.6.35.y-512ac85/kernel/trace/ftrace.c
*** 2.6.35/kernel/trace/ftrace.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/trace/ftrace.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 3290,3296 ****
  	/* The cpu_boot init_task->ret_stack will never be freed */
  	for_each_online_cpu(cpu) {
  		if (!idle_task(cpu)->ret_stack)
! 			ftrace_graph_init_idle_task(idle_task(cpu), cpu);
  	}
  
  	do {
--- 3290,3296 ----
  	/* The cpu_boot init_task->ret_stack will never be freed */
  	for_each_online_cpu(cpu) {
  		if (!idle_task(cpu)->ret_stack)
! 			ftrace_graph_init_task(idle_task(cpu));
  	}
  
  	do {
***************
*** 3380,3428 ****
  	mutex_unlock(&ftrace_lock);
  }
  
- static DEFINE_PER_CPU(struct ftrace_ret_stack *, idle_ret_stack);
- 
- static void
- graph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)
- {
- 	atomic_set(&t->tracing_graph_pause, 0);
- 	atomic_set(&t->trace_overrun, 0);
- 	t->ftrace_timestamp = 0;
- 	/* make curr_ret_stack visable before we add the ret_stack */
- 	smp_wmb();
- 	t->ret_stack = ret_stack;
- }
- 
- /*
-  * Allocate a return stack for the idle task. May be the first
-  * time through, or it may be done by CPU hotplug online.
-  */
- void ftrace_graph_init_idle_task(struct task_struct *t, int cpu)
- {
- 	t->curr_ret_stack = -1;
- 	/*
- 	 * The idle task has no parent, it either has its own
- 	 * stack or no stack at all.
- 	 */
- 	if (t->ret_stack)
- 		WARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));
- 
- 	if (ftrace_graph_active) {
- 		struct ftrace_ret_stack *ret_stack;
- 
- 		ret_stack = per_cpu(idle_ret_stack, cpu);
- 		if (!ret_stack) {
- 			ret_stack = kmalloc(FTRACE_RETFUNC_DEPTH
- 					    * sizeof(struct ftrace_ret_stack),
- 					    GFP_KERNEL);
- 			if (!ret_stack)
- 				return;
- 			per_cpu(idle_ret_stack, cpu) = ret_stack;
- 		}
- 		graph_init_task(t, ret_stack);
- 	}
- }
- 
  /* Allocate a return stack for newly created task */
  void ftrace_graph_init_task(struct task_struct *t)
  {
--- 3380,3385 ----
***************
*** 3438,3444 ****
  				GFP_KERNEL);
  		if (!ret_stack)
  			return;
! 		graph_init_task(t, ret_stack);
  	}
  }
  
--- 3395,3406 ----
  				GFP_KERNEL);
  		if (!ret_stack)
  			return;
! 		atomic_set(&t->tracing_graph_pause, 0);
! 		atomic_set(&t->trace_overrun, 0);
! 		t->ftrace_timestamp = 0;
! 		/* make curr_ret_stack visable before we add the ret_stack */
! 		smp_wmb();
! 		t->ret_stack = ret_stack;
  	}
  }
  
diff -cBr 2.6.35/kernel/trace/trace.c linux-2.6.35.y-512ac85/kernel/trace/trace.c
*** 2.6.35/kernel/trace/trace.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/trace/trace.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2382,2400 ****
  	return count;
  }
  
- static loff_t tracing_seek(struct file *file, loff_t offset, int origin)
- {
- 	if (file->f_mode & FMODE_READ)
- 		return seq_lseek(file, offset, origin);
- 	else
- 		return 0;
- }
- 
  static const struct file_operations tracing_fops = {
  	.open		= tracing_open,
  	.read		= seq_read,
  	.write		= tracing_write_stub,
! 	.llseek		= tracing_seek,
  	.release	= tracing_release,
  };
  
--- 2382,2392 ----
  	return count;
  }
  
  static const struct file_operations tracing_fops = {
  	.open		= tracing_open,
  	.read		= seq_read,
  	.write		= tracing_write_stub,
! 	.llseek		= seq_lseek,
  	.release	= tracing_release,
  };
  
diff -cBr 2.6.35/kernel/user.c linux-2.6.35.y-512ac85/kernel/user.c
*** 2.6.35/kernel/user.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/user.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 91,97 ****
   * upon function exit.
   */
  static void free_user(struct user_struct *up, unsigned long flags)
- 	__releases(&uidhash_lock)
  {
  	uid_hash_remove(up);
  	spin_unlock_irqrestore(&uidhash_lock, flags);
--- 91,96 ----
***************
*** 158,164 ****
  		spin_lock_irq(&uidhash_lock);
  		up = uid_hash_find(uid, hashent);
  		if (up) {
- 			put_user_ns(ns);
  			key_put(new->uid_keyring);
  			key_put(new->session_keyring);
  			kmem_cache_free(uid_cachep, new);
--- 157,162 ----
diff -cBr 2.6.35/kernel/user_namespace.c linux-2.6.35.y-512ac85/kernel/user_namespace.c
*** 2.6.35/kernel/user_namespace.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/kernel/user_namespace.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 9,15 ****
  #include <linux/nsproxy.h>
  #include <linux/slab.h>
  #include <linux/user_namespace.h>
- #include <linux/highuid.h>
  #include <linux/cred.h>
  
  /*
--- 9,14 ----
***************
*** 83,128 ****
  	schedule_work(&ns->destroyer);
  }
  EXPORT_SYMBOL(free_user_ns);
- 
- uid_t user_ns_map_uid(struct user_namespace *to, const struct cred *cred, uid_t uid)
- {
- 	struct user_namespace *tmp;
- 
- 	if (likely(to == cred->user->user_ns))
- 		return uid;
- 
- 
- 	/* Is cred->user the creator of the target user_ns
- 	 * or the creator of one of it's parents?
- 	 */
- 	for ( tmp = to; tmp != &init_user_ns;
- 	      tmp = tmp->creator->user_ns ) {
- 		if (cred->user == tmp->creator) {
- 			return (uid_t)0;
- 		}
- 	}
- 
- 	/* No useful relationship so no mapping */
- 	return overflowuid;
- }
- 
- gid_t user_ns_map_gid(struct user_namespace *to, const struct cred *cred, gid_t gid)
- {
- 	struct user_namespace *tmp;
- 
- 	if (likely(to == cred->user->user_ns))
- 		return gid;
- 
- 	/* Is cred->user the creator of the target user_ns
- 	 * or the creator of one of it's parents?
- 	 */
- 	for ( tmp = to; tmp != &init_user_ns;
- 	      tmp = tmp->creator->user_ns ) {
- 		if (cred->user == tmp->creator) {
- 			return (gid_t)0;
- 		}
- 	}
- 
- 	/* No useful relationship so no mapping */
- 	return overflowgid;
- }
--- 82,84 ----
diff -cBr 2.6.35/lib/percpu_counter.c linux-2.6.35.y-512ac85/lib/percpu_counter.c
*** 2.6.35/lib/percpu_counter.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/lib/percpu_counter.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 76,82 ****
  	if (!fbc->counters)
  		return -ENOMEM;
  #ifdef CONFIG_HOTPLUG_CPU
- 	INIT_LIST_HEAD(&fbc->list);
  	mutex_lock(&percpu_counters_lock);
  	list_add(&fbc->list, &percpu_counters);
  	mutex_unlock(&percpu_counters_lock);
--- 76,81 ----
diff -cBr 2.6.35/lib/radix-tree.c linux-2.6.35.y-512ac85/lib/radix-tree.c
*** 2.6.35/lib/radix-tree.c	2011-05-07 19:57:51.966750023 -0400
--- linux-2.6.35.y-512ac85/lib/radix-tree.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 82,97 ****
  };
  static DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads) = { 0, };
  
- static inline void *ptr_to_indirect(void *ptr)
- {
- 	return (void *)((unsigned long)ptr | RADIX_TREE_INDIRECT_PTR);
- }
- 
- static inline void *indirect_to_ptr(void *ptr)
- {
- 	return (void *)((unsigned long)ptr & ~RADIX_TREE_INDIRECT_PTR);
- }
- 
  static inline gfp_t root_gfp_mask(struct radix_tree_root *root)
  {
  	return root->gfp_mask & __GFP_BITS_MASK;
--- 82,87 ----
***************
*** 273,279 ****
  			return -ENOMEM;
  
  		/* Increase the height.  */
! 		node->slots[0] = indirect_to_ptr(root->rnode);
  
  		/* Propagate the aggregated tag info into the new root */
  		for (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++) {
--- 263,269 ----
  			return -ENOMEM;
  
  		/* Increase the height.  */
! 		node->slots[0] = radix_tree_indirect_to_ptr(root->rnode);
  
  		/* Propagate the aggregated tag info into the new root */
  		for (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++) {
***************
*** 284,290 ****
  		newheight = root->height+1;
  		node->height = newheight;
  		node->count = 1;
! 		node = ptr_to_indirect(node);
  		rcu_assign_pointer(root->rnode, node);
  		root->height = newheight;
  	} while (height > root->height);
--- 274,280 ----
  		newheight = root->height+1;
  		node->height = newheight;
  		node->count = 1;
! 		node = radix_tree_ptr_to_indirect(node);
  		rcu_assign_pointer(root->rnode, node);
  		root->height = newheight;
  	} while (height > root->height);
***************
*** 317,323 ****
  			return error;
  	}
  
! 	slot = indirect_to_ptr(root->rnode);
  
  	height = root->height;
  	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
--- 307,313 ----
  			return error;
  	}
  
! 	slot = radix_tree_indirect_to_ptr(root->rnode);
  
  	height = root->height;
  	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
***************
*** 333,339 ****
  				rcu_assign_pointer(node->slots[offset], slot);
  				node->count++;
  			} else
! 				rcu_assign_pointer(root->rnode, ptr_to_indirect(slot));
  		}
  
  		/* Go a level down */
--- 323,330 ----
  				rcu_assign_pointer(node->slots[offset], slot);
  				node->count++;
  			} else
! 				rcu_assign_pointer(root->rnode,
! 					radix_tree_ptr_to_indirect(slot));
  		}
  
  		/* Go a level down */
***************
*** 381,387 ****
  			return NULL;
  		return is_slot ? (void *)&root->rnode : node;
  	}
! 	node = indirect_to_ptr(node);
  
  	height = node->height;
  	if (index > radix_tree_maxindex(height))
--- 372,378 ----
  			return NULL;
  		return is_slot ? (void *)&root->rnode : node;
  	}
! 	node = radix_tree_indirect_to_ptr(node);
  
  	height = node->height;
  	if (index > radix_tree_maxindex(height))
***************
*** 400,406 ****
  		height--;
  	} while (height > 0);
  
! 	return is_slot ? (void *)slot : indirect_to_ptr(node);
  }
  
  /**
--- 391,397 ----
  		height--;
  	} while (height > 0);
  
! 	return is_slot ? (void *)slot:node;
  }
  
  /**
***************
*** 462,468 ****
  	height = root->height;
  	BUG_ON(index > radix_tree_maxindex(height));
  
! 	slot = indirect_to_ptr(root->rnode);
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  
  	while (height > 0) {
--- 453,459 ----
  	height = root->height;
  	BUG_ON(index > radix_tree_maxindex(height));
  
! 	slot = radix_tree_indirect_to_ptr(root->rnode);
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  
  	while (height > 0) {
***************
*** 516,522 ****
  
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  	pathp->node = NULL;
! 	slot = indirect_to_ptr(root->rnode);
  
  	while (height > 0) {
  		int offset;
--- 507,513 ----
  
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  	pathp->node = NULL;
! 	slot = radix_tree_indirect_to_ptr(root->rnode);
  
  	while (height > 0) {
  		int offset;
***************
*** 586,592 ****
  
  	if (!radix_tree_is_indirect_ptr(node))
  		return (index == 0);
! 	node = indirect_to_ptr(node);
  
  	height = node->height;
  	if (index > radix_tree_maxindex(height))
--- 577,583 ----
  
  	if (!radix_tree_is_indirect_ptr(node))
  		return (index == 0);
! 	node = radix_tree_indirect_to_ptr(node);
  
  	height = node->height;
  	if (index > radix_tree_maxindex(height))
***************
*** 776,782 ****
  		results[0] = node;
  		return 1;
  	}
! 	node = indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
--- 767,773 ----
  		results[0] = node;
  		return 1;
  	}
! 	node = radix_tree_indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
***************
*** 844,850 ****
  		results[0] = (void **)&root->rnode;
  		return 1;
  	}
! 	node = indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
--- 835,841 ----
  		results[0] = (void **)&root->rnode;
  		return 1;
  	}
! 	node = radix_tree_indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
***************
*** 969,975 ****
  		results[0] = node;
  		return 1;
  	}
! 	node = indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
--- 960,966 ----
  		results[0] = node;
  		return 1;
  	}
! 	node = radix_tree_indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
***************
*** 988,995 ****
  			slot = *(((void ***)results)[ret + i]);
  			if (!slot)
  				continue;
! 			results[ret + nr_found] =
! 				indirect_to_ptr(rcu_dereference_raw(slot));
  			nr_found++;
  		}
  		ret += nr_found;
--- 979,985 ----
  			slot = *(((void ***)results)[ret + i]);
  			if (!slot)
  				continue;
! 			results[ret + nr_found] = rcu_dereference_raw(slot);
  			nr_found++;
  		}
  		ret += nr_found;
***************
*** 1039,1045 ****
  		results[0] = (void **)&root->rnode;
  		return 1;
  	}
! 	node = indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
--- 1029,1035 ----
  		results[0] = (void **)&root->rnode;
  		return 1;
  	}
! 	node = radix_tree_indirect_to_ptr(node);
  
  	max_index = radix_tree_maxindex(node->height);
  
***************
*** 1075,1081 ****
  		void *newptr;
  
  		BUG_ON(!radix_tree_is_indirect_ptr(to_free));
! 		to_free = indirect_to_ptr(to_free);
  
  		/*
  		 * The candidate node has more than one child, or its child
--- 1065,1071 ----
  		void *newptr;
  
  		BUG_ON(!radix_tree_is_indirect_ptr(to_free));
! 		to_free = radix_tree_indirect_to_ptr(to_free);
  
  		/*
  		 * The candidate node has more than one child, or its child
***************
*** 1088,1126 ****
  
  		/*
  		 * We don't need rcu_assign_pointer(), since we are simply
! 		 * moving the node from one part of the tree to another: if it
! 		 * was safe to dereference the old pointer to it
  		 * (to_free->slots[0]), it will be safe to dereference the new
! 		 * one (root->rnode) as far as dependent read barriers go.
  		 */
  		newptr = to_free->slots[0];
  		if (root->height > 1)
! 			newptr = ptr_to_indirect(newptr);
  		root->rnode = newptr;
  		root->height--;
- 
- 		/*
- 		 * We have a dilemma here. The node's slot[0] must not be
- 		 * NULLed in case there are concurrent lookups expecting to
- 		 * find the item. However if this was a bottom-level node,
- 		 * then it may be subject to the slot pointer being visible
- 		 * to callers dereferencing it. If item corresponding to
- 		 * slot[0] is subsequently deleted, these callers would expect
- 		 * their slot to become empty sooner or later.
- 		 *
- 		 * For example, lockless pagecache will look up a slot, deref
- 		 * the page pointer, and if the page is 0 refcount it means it
- 		 * was concurrently deleted from pagecache so try the deref
- 		 * again. Fortunately there is already a requirement for logic
- 		 * to retry the entire slot lookup -- the indirect pointer
- 		 * problem (replacing direct root node with an indirect pointer
- 		 * also results in a stale slot). So tag the slot as indirect
- 		 * to force callers to retry.
- 		 */
- 		if (root->height == 0)
- 			*((unsigned long *)&to_free->slots[0]) |=
- 						RADIX_TREE_INDIRECT_PTR;
- 
  		radix_tree_node_free(to_free);
  	}
  }
--- 1078,1093 ----
  
  		/*
  		 * We don't need rcu_assign_pointer(), since we are simply
! 		 * moving the node from one part of the tree to another. If
! 		 * it was safe to dereference the old pointer to it
  		 * (to_free->slots[0]), it will be safe to dereference the new
! 		 * one (root->rnode).
  		 */
  		newptr = to_free->slots[0];
  		if (root->height > 1)
! 			newptr = radix_tree_ptr_to_indirect(newptr);
  		root->rnode = newptr;
  		root->height--;
  		radix_tree_node_free(to_free);
  	}
  }
***************
*** 1157,1163 ****
  		root->rnode = NULL;
  		goto out;
  	}
! 	slot = indirect_to_ptr(slot);
  
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  	pathp->node = NULL;
--- 1124,1130 ----
  		root->rnode = NULL;
  		goto out;
  	}
! 	slot = radix_tree_indirect_to_ptr(slot);
  
  	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
  	pathp->node = NULL;
***************
*** 1199,1205 ****
  			radix_tree_node_free(to_free);
  
  		if (pathp->node->count) {
! 			if (pathp->node == indirect_to_ptr(root->rnode))
  				radix_tree_shrink(root);
  			goto out;
  		}
--- 1166,1173 ----
  			radix_tree_node_free(to_free);
  
  		if (pathp->node->count) {
! 			if (pathp->node ==
! 					radix_tree_indirect_to_ptr(root->rnode))
  				radix_tree_shrink(root);
  			goto out;
  		}
diff -cBr 2.6.35/MAINTAINERS linux-2.6.35.y-512ac85/MAINTAINERS
*** 2.6.35/MAINTAINERS	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/MAINTAINERS	2010-11-22 14:01:26.000000000 -0500
***************
*** 5442,5447 ****
--- 5442,5448 ----
  
  STABLE BRANCH
  M:	Greg Kroah-Hartman <greg@kroah.com>
+ M:	Chris Wright <chrisw@sous-sol.org>
  L:	stable@kernel.org
  S:	Maintained
  
diff -cBr 2.6.35/Makefile linux-2.6.35.y-512ac85/Makefile
*** 2.6.35/Makefile	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/Makefile	2010-11-22 14:01:26.000000000 -0500
***************
*** 1,7 ****
  VERSION = 2
  PATCHLEVEL = 6
  SUBLEVEL = 35
! EXTRAVERSION = .13
  NAME = Yokohama
  
  # *DOCUMENTATION*
--- 1,7 ----
  VERSION = 2
  PATCHLEVEL = 6
  SUBLEVEL = 35
! EXTRAVERSION = .9
  NAME = Yokohama
  
  # *DOCUMENTATION*
Only in 2.6.35/mm: ashmem.c
diff -cBr 2.6.35/mm/filemap.c linux-2.6.35.y-512ac85/mm/filemap.c
*** 2.6.35/mm/filemap.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/filemap.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 631,639 ****
  	pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
  	if (pagep) {
  		page = radix_tree_deref_slot(pagep);
! 		if (unlikely(!page))
! 			goto out;
! 		if (radix_tree_deref_retry(page))
  			goto repeat;
  
  		if (!page_cache_get_speculative(page))
--- 631,637 ----
  	pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
  	if (pagep) {
  		page = radix_tree_deref_slot(pagep);
! 		if (unlikely(!page || page == RADIX_TREE_RETRY))
  			goto repeat;
  
  		if (!page_cache_get_speculative(page))
***************
*** 649,655 ****
  			goto repeat;
  		}
  	}
- out:
  	rcu_read_unlock();
  
  	return page;
--- 647,652 ----
***************
*** 767,777 ****
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		if (radix_tree_deref_retry(page)) {
! 			if (ret)
! 				start = pages[ret-1]->index;
  			goto restart;
- 		}
  
  		if (!page_cache_get_speculative(page))
  			goto repeat;
--- 764,775 ----
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		/*
! 		 * this can only trigger if nr_found == 1, making livelock
! 		 * a non issue.
! 		 */
! 		if (unlikely(page == RADIX_TREE_RETRY))
  			goto restart;
  
  		if (!page_cache_get_speculative(page))
  			goto repeat;
***************
*** 819,825 ****
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		if (radix_tree_deref_retry(page))
  			goto restart;
  
  		if (page->mapping == NULL || page->index != index)
--- 817,827 ----
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		/*
! 		 * this can only trigger if nr_found == 1, making livelock
! 		 * a non issue.
! 		 */
! 		if (unlikely(page == RADIX_TREE_RETRY))
  			goto restart;
  
  		if (page->mapping == NULL || page->index != index)
***************
*** 872,878 ****
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		if (radix_tree_deref_retry(page))
  			goto restart;
  
  		if (!page_cache_get_speculative(page))
--- 874,884 ----
  		page = radix_tree_deref_slot((void **)pages[i]);
  		if (unlikely(!page))
  			continue;
! 		/*
! 		 * this can only trigger if nr_found == 1, making livelock
! 		 * a non issue.
! 		 */
! 		if (unlikely(page == RADIX_TREE_RETRY))
  			goto restart;
  
  		if (!page_cache_get_speculative(page))
***************
*** 1010,1018 ****
  				goto page_not_up_to_date;
  			if (!trylock_page(page))
  				goto page_not_up_to_date;
- 			/* Did it get truncated before we got the lock? */
- 			if (!page->mapping)
- 				goto page_not_up_to_date_locked;
  			if (!mapping->a_ops->is_partially_uptodate(page,
  								desc, offset))
  				goto page_not_up_to_date_locked;
--- 1016,1021 ----
diff -cBr 2.6.35/mm/internal.h linux-2.6.35.y-512ac85/mm/internal.h
*** 2.6.35/mm/internal.h	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/internal.h	2010-11-22 14:01:26.000000000 -0500
***************
*** 62,68 ****
   */
  static inline unsigned long page_order(struct page *page)
  {
! 	/* PageBuddy() must be checked by the caller */
  	return page_private(page);
  }
  
--- 62,68 ----
   */
  static inline unsigned long page_order(struct page *page)
  {
! 	VM_BUG_ON(!PageBuddy(page));
  	return page_private(page);
  }
  
diff -cBr 2.6.35/mm/memory_hotplug.c linux-2.6.35.y-512ac85/mm/memory_hotplug.c
*** 2.6.35/mm/memory_hotplug.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/memory_hotplug.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 659,665 ****
   * Scanning pfn is much easier than scanning lru list.
   * Scan pfn from start to end and Find LRU page.
   */
! unsigned long scan_lru_pages(unsigned long start, unsigned long end)
  {
  	unsigned long pfn;
  	struct page *page;
--- 659,665 ----
   * Scanning pfn is much easier than scanning lru list.
   * Scan pfn from start to end and Find LRU page.
   */
! int scan_lru_pages(unsigned long start, unsigned long end)
  {
  	unsigned long pfn;
  	struct page *page;
diff -cBr 2.6.35/mm/mempolicy.c linux-2.6.35.y-512ac85/mm/mempolicy.c
*** 2.6.35/mm/mempolicy.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/mempolicy.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1576,1582 ****
  		(void)first_zones_zonelist(zonelist, highest_zoneidx,
  							&policy->v.nodes,
  							&zone);
! 		return zone ? zone->node : numa_node_id();
  	}
  
  	default:
--- 1576,1582 ----
  		(void)first_zones_zonelist(zonelist, highest_zoneidx,
  							&policy->v.nodes,
  							&zone);
! 		return zone->node;
  	}
  
  	default:
diff -cBr 2.6.35/mm/mmap.c linux-2.6.35.y-512ac85/mm/mmap.c
*** 2.6.35/mm/mmap.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/mmap.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2444,2450 ****
  			    unsigned long addr, unsigned long len,
  			    unsigned long vm_flags, struct page **pages)
  {
- 	int ret;
  	struct vm_area_struct *vma;
  
  	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
--- 2444,2449 ----
***************
*** 2462,2484 ****
  	vma->vm_ops = &special_mapping_vmops;
  	vma->vm_private_data = pages;
  
! 	ret = security_file_mmap(NULL, 0, 0, 0, vma->vm_start, 1);
! 	if (ret)
! 		goto out;
! 
! 	ret = insert_vm_struct(mm, vma);
! 	if (ret)
! 		goto out;
  
  	mm->total_vm += len >> PAGE_SHIFT;
  
  	perf_event_mmap(vma);
  
  	return 0;
- 
- out:
- 	kmem_cache_free(vm_area_cachep, vma);
- 	return ret;
  }
  
  static DEFINE_MUTEX(mm_all_locks_mutex);
--- 2461,2476 ----
  	vma->vm_ops = &special_mapping_vmops;
  	vma->vm_private_data = pages;
  
! 	if (unlikely(insert_vm_struct(mm, vma))) {
! 		kmem_cache_free(vm_area_cachep, vma);
! 		return -ENOMEM;
! 	}
  
  	mm->total_vm += len >> PAGE_SHIFT;
  
  	perf_event_mmap(vma);
  
  	return 0;
  }
  
  static DEFINE_MUTEX(mm_all_locks_mutex);
diff -cBr 2.6.35/mm/mmzone.c linux-2.6.35.y-512ac85/mm/mmzone.c
*** 2.6.35/mm/mmzone.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/mmzone.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 87,89 ****
--- 87,110 ----
  	return 1;
  }
  #endif /* CONFIG_ARCH_HAS_HOLES_MEMORYMODEL */
+ 
+ #ifdef CONFIG_SMP
+ /* Called when a more accurate view of NR_FREE_PAGES is needed */
+ unsigned long zone_nr_free_pages(struct zone *zone)
+ {
+ 	unsigned long nr_free_pages = zone_page_state(zone, NR_FREE_PAGES);
+ 
+ 	/*
+ 	 * While kswapd is awake, it is considered the zone is under some
+ 	 * memory pressure. Under pressure, there is a risk that
+ 	 * per-cpu-counter-drift will allow the min watermark to be breached
+ 	 * potentially causing a live-lock. While kswapd is awake and
+ 	 * free pages are low, get a better estimate for free pages
+ 	 */
+ 	if (nr_free_pages < zone->percpu_drift_mark &&
+ 			!waitqueue_active(&zone->zone_pgdat->kswapd_wait))
+ 		return zone_page_state_snapshot(zone, NR_FREE_PAGES);
+ 
+ 	return nr_free_pages;
+ }
+ #endif /* CONFIG_SMP */
diff -cBr 2.6.35/mm/mprotect.c linux-2.6.35.y-512ac85/mm/mprotect.c
*** 2.6.35/mm/mprotect.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/mprotect.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 211,217 ****
  	mmu_notifier_invalidate_range_end(mm, start, end);
  	vm_stat_account(mm, oldflags, vma->vm_file, -nrpages);
  	vm_stat_account(mm, newflags, vma->vm_file, nrpages);
- 	perf_event_mmap(vma);
  	return 0;
  
  fail:
--- 211,216 ----
***************
*** 300,305 ****
--- 299,305 ----
  		error = mprotect_fixup(vma, &prev, nstart, tmp, newflags);
  		if (error)
  			goto out;
+ 		perf_event_mmap(vma);
  		nstart = tmp;
  
  		if (nstart < prev->vm_end)
diff -cBr 2.6.35/mm/mremap.c linux-2.6.35.y-512ac85/mm/mremap.c
*** 2.6.35/mm/mremap.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/mremap.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 91,97 ****
  		 */
  		mapping = vma->vm_file->f_mapping;
  		spin_lock(&mapping->i_mmap_lock);
! 		new_vma->vm_truncate_count = 0;
  	}
  
  	/*
--- 91,99 ----
  		 */
  		mapping = vma->vm_file->f_mapping;
  		spin_lock(&mapping->i_mmap_lock);
! 		if (new_vma->vm_truncate_count &&
! 		    new_vma->vm_truncate_count != vma->vm_truncate_count)
! 			new_vma->vm_truncate_count = 0;
  	}
  
  	/*
***************
*** 274,289 ****
  	if (old_len > vma->vm_end - addr)
  		goto Efault;
  
! 	/* Need to be careful about a growing mapping */
! 	if (new_len > old_len) {
! 		unsigned long pgoff;
! 
! 		if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))
  			goto Efault;
- 		pgoff = (addr - vma->vm_start) >> PAGE_SHIFT;
- 		pgoff += vma->vm_pgoff;
- 		if (pgoff + (new_len >> PAGE_SHIFT) < pgoff)
- 			goto Einval;
  	}
  
  	if (vma->vm_flags & VM_LOCKED) {
--- 276,284 ----
  	if (old_len > vma->vm_end - addr)
  		goto Efault;
  
! 	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
! 		if (new_len > old_len)
  			goto Efault;
  	}
  
  	if (vma->vm_flags & VM_LOCKED) {
diff -cBr 2.6.35/mm/nommu.c linux-2.6.35.y-512ac85/mm/nommu.c
*** 2.6.35/mm/nommu.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/nommu.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 1673,1679 ****
  		mm->mmap = vma->vm_next;
  		delete_vma_from_mm(vma);
  		delete_vma(mm, vma);
- 		cond_resched();
  	}
  
  	kleave("");
--- 1673,1678 ----
diff -cBr 2.6.35/mm/page_alloc.c linux-2.6.35.y-512ac85/mm/page_alloc.c
*** 2.6.35/mm/page_alloc.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/page_alloc.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 103,126 ****
   * only be modified with pm_mutex held, unless the suspend/hibernate code is
   * guaranteed not to run in parallel with that modification).
   */
! 
! static gfp_t saved_gfp_mask;
! 
! void pm_restore_gfp_mask(void)
  {
  	WARN_ON(!mutex_is_locked(&pm_mutex));
! 	if (saved_gfp_mask) {
! 		gfp_allowed_mask = saved_gfp_mask;
! 		saved_gfp_mask = 0;
! 	}
  }
  
! void pm_restrict_gfp_mask(void)
  {
  	WARN_ON(!mutex_is_locked(&pm_mutex));
! 	WARN_ON(saved_gfp_mask);
! 	saved_gfp_mask = gfp_allowed_mask;
! 	gfp_allowed_mask &= ~GFP_IOFS;
  }
  #endif /* CONFIG_PM_SLEEP */
  
--- 103,121 ----
   * only be modified with pm_mutex held, unless the suspend/hibernate code is
   * guaranteed not to run in parallel with that modification).
   */
! void set_gfp_allowed_mask(gfp_t mask)
  {
  	WARN_ON(!mutex_is_locked(&pm_mutex));
! 	gfp_allowed_mask = mask;
  }
  
! gfp_t clear_gfp_allowed_mask(gfp_t mask)
  {
+ 	gfp_t ret = gfp_allowed_mask;
+ 
  	WARN_ON(!mutex_is_locked(&pm_mutex));
! 	gfp_allowed_mask &= ~mask;
! 	return ret;
  }
  #endif /* CONFIG_PM_SLEEP */
  
***************
*** 535,541 ****
  	 * so it's less likely to be used soon and more likely to be merged
  	 * as a higher order page
  	 */
! 	if ((order < MAX_ORDER-2) && pfn_valid_within(page_to_pfn(buddy))) {
  		struct page *higher_page, *higher_buddy;
  		combined_idx = __find_combined_index(page_idx, order);
  		higher_page = page + combined_idx - page_idx;
--- 530,536 ----
  	 * so it's less likely to be used soon and more likely to be merged
  	 * as a higher order page
  	 */
! 	if ((order < MAX_ORDER-1) && pfn_valid_within(page_to_pfn(buddy))) {
  		struct page *higher_page, *higher_buddy;
  		combined_idx = __find_combined_index(page_idx, order);
  		higher_page = page + combined_idx - page_idx;
***************
*** 1459,1482 ****
  #endif /* CONFIG_FAIL_PAGE_ALLOC */
  
  /*
!  * Return true if free pages are above 'mark'. This takes into account the order
   * of the allocation.
   */
! static bool __zone_watermark_ok(struct zone *z, int order, unsigned long mark,
! 		      int classzone_idx, int alloc_flags, long free_pages)
  {
  	/* free_pages my go negative - that's OK */
  	long min = mark;
  	int o;
  
- 	free_pages -= (1 << order) + 1;
  	if (alloc_flags & ALLOC_HIGH)
  		min -= min / 2;
  	if (alloc_flags & ALLOC_HARDER)
  		min -= min / 4;
  
  	if (free_pages <= min + z->lowmem_reserve[classzone_idx])
! 		return false;
  	for (o = 0; o < order; o++) {
  		/* At the next order, this order's pages become unavailable */
  		free_pages -= z->free_area[o].nr_free << o;
--- 1454,1477 ----
  #endif /* CONFIG_FAIL_PAGE_ALLOC */
  
  /*
!  * Return 1 if free pages are above 'mark'. This takes into account the order
   * of the allocation.
   */
! int zone_watermark_ok(struct zone *z, int order, unsigned long mark,
! 		      int classzone_idx, int alloc_flags)
  {
  	/* free_pages my go negative - that's OK */
  	long min = mark;
+ 	long free_pages = zone_nr_free_pages(z) - (1 << order) + 1;
  	int o;
  
  	if (alloc_flags & ALLOC_HIGH)
  		min -= min / 2;
  	if (alloc_flags & ALLOC_HARDER)
  		min -= min / 4;
  
  	if (free_pages <= min + z->lowmem_reserve[classzone_idx])
! 		return 0;
  	for (o = 0; o < order; o++) {
  		/* At the next order, this order's pages become unavailable */
  		free_pages -= z->free_area[o].nr_free << o;
***************
*** 1485,1512 ****
  		min >>= 1;
  
  		if (free_pages <= min)
! 			return false;
  	}
! 	return true;
! }
! 
! bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,
! 		      int classzone_idx, int alloc_flags)
! {
! 	return __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,
! 					zone_page_state(z, NR_FREE_PAGES));
! }
! 
! bool zone_watermark_ok_safe(struct zone *z, int order, unsigned long mark,
! 		      int classzone_idx, int alloc_flags)
! {
! 	long free_pages = zone_page_state(z, NR_FREE_PAGES);
! 
! 	if (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)
! 		free_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);
! 
! 	return __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,
! 								free_pages);
  }
  
  #ifdef CONFIG_NUMA
--- 1480,1488 ----
  		min >>= 1;
  
  		if (free_pages <= min)
! 			return 0;
  	}
! 	return 1;
  }
  
  #ifdef CONFIG_NUMA
***************
*** 2449,2455 ****
  			" all_unreclaimable? %s"
  			"\n",
  			zone->name,
! 			K(zone_page_state(zone, NR_FREE_PAGES)),
  			K(min_wmark_pages(zone)),
  			K(low_wmark_pages(zone)),
  			K(high_wmark_pages(zone)),
--- 2425,2431 ----
  			" all_unreclaimable? %s"
  			"\n",
  			zone->name,
! 			K(zone_nr_free_pages(zone)),
  			K(min_wmark_pages(zone)),
  			K(low_wmark_pages(zone)),
  			K(high_wmark_pages(zone)),
diff -cBr 2.6.35/mm/shmem.c linux-2.6.35.y-512ac85/mm/shmem.c
*** 2.6.35/mm/shmem.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/shmem.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2756,2761 ****
  		fput(vma->vm_file);
  	vma->vm_file = file;
  	vma->vm_ops = &shmem_vm_ops;
- 	vma->vm_flags |= VM_CAN_NONLINEAR;
  	return 0;
  }
--- 2756,2760 ----
diff -cBr 2.6.35/mm/slab.c linux-2.6.35.y-512ac85/mm/slab.c
*** 2.6.35/mm/slab.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/slab.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2289,2296 ****
  	if (ralign < align) {
  		ralign = align;
  	}
! 	/* disable debug if necessary */
! 	if (ralign > __alignof__(unsigned long long))
  		flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
  	/*
  	 * 4) Store it.
--- 2289,2296 ----
  	if (ralign < align) {
  		ralign = align;
  	}
! 	/* disable debug if not aligning with REDZONE_ALIGN */
! 	if (ralign & (__alignof__(unsigned long long) - 1))
  		flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
  	/*
  	 * 4) Store it.
***************
*** 2316,2323 ****
  	 */
  	if (flags & SLAB_RED_ZONE) {
  		/* add space for red zone words */
! 		cachep->obj_offset += sizeof(unsigned long long);
! 		size += 2 * sizeof(unsigned long long);
  	}
  	if (flags & SLAB_STORE_USER) {
  		/* user store requires one word storage behind the end of
--- 2316,2323 ----
  	 */
  	if (flags & SLAB_RED_ZONE) {
  		/* add space for red zone words */
! 		cachep->obj_offset += align;
! 		size += align + sizeof(unsigned long long);
  	}
  	if (flags & SLAB_STORE_USER) {
  		/* user store requires one word storage behind the end of
diff -cBr 2.6.35/mm/vmscan.c linux-2.6.35.y-512ac85/mm/vmscan.c
*** 2.6.35/mm/vmscan.c	2011-05-07 19:57:51.976750008 -0400
--- linux-2.6.35.y-512ac85/mm/vmscan.c	2010-11-22 14:01:26.000000000 -0500
***************
*** 2007,2013 ****
  		if (zone->all_unreclaimable)
  			continue;
  
! 		if (!zone_watermark_ok_safe(zone, order, high_wmark_pages(zone),
  								0, 0))
  			return 1;
  	}
--- 2007,2013 ----
  		if (zone->all_unreclaimable)
  			continue;
  
! 		if (!zone_watermark_ok(zone, order, high_wmark_pages(zone),
  								0, 0))
  			return 1;
  	}
***************
*** 2104,2110 ****
  				shrink_active_list(SWAP_CLUSTER_MAX, zone,
  							&sc, priority, 0);
  
! 			if (!zone_watermark_ok_safe(zone, order,
  					high_wmark_pages(zone), 0, 0)) {
  				end_zone = i;
  				break;
--- 2104,2110 ----
  				shrink_active_list(SWAP_CLUSTER_MAX, zone,
  							&sc, priority, 0);
  
! 			if (!zone_watermark_ok(zone, order,
  					high_wmark_pages(zone), 0, 0)) {
  				end_zone = i;
  				break;
***************
*** 2155,2161 ****
  			 * We put equal pressure on every zone, unless one
  			 * zone has way too many pages free already.
  			 */
! 			if (!zone_watermark_ok_safe(zone, order,
  					8*high_wmark_pages(zone), end_zone, 0))
  				shrink_zone(priority, zone, &sc);
  			reclaim_state->reclaimed_slab = 0;
--- 2155,2161 ----
  			 * We put equal pressure on every zone, unless one
  			 * zone has way too many pages free already.
  			 */
! 			if (!zone_watermark_ok(zone, order,
  					8*high_wmark_pages(zone), end_zone, 0))
  				shrink_zone(priority, zone, &sc);
  			reclaim_state->reclaimed_slab = 0;
***************
*** 2176,2182 ****
  			    total_scanned > sc.nr_reclaimed + sc.nr_reclaimed / 2)
  				sc.may_writepage = 1;
  
! 			if (!zone_watermark_ok_safe(zone, order,
  					high_wmark_pages(zone), end_zone, 0)) {
  				all_zones_ok = 0;
  				/*
--- 2176,2182 ----
  			    total_scanned > sc.nr_reclaimed + sc.nr_reclaimed / 2)
  				sc.may_writepage = 1;
  
! 			if (!zone_watermark_ok(zone, order,
  					high_wmark_pages(zone), end_zone, 0)) {
  				all_zones_ok = 0;
  				/*
***************
*** 2184,2190 ****
  				 * means that we have a GFP_ATOMIC allocation
  				 * failure risk. Hurry up!
  				 */
! 				if (!zone_watermark_ok_safe(zone, order,
  					    min_wmark_pages(zone), end_zone, 0))
  					has_under_min_watermark_zone = 1;
  			}
--- 2184,2190 ----
  				 * means that we have a GFP_ATOMIC allocation
  				 * failure risk. Hurry up!
  				 */
! 				if (!zone_watermark_ok(zone, order,
  					    min_wmark_pages(zone), end_zone, 0))
  					has_under_min_watermark_zone = 1;
  			}
***************
*** 2326,2336 ****
  				 * premature sleep. If not, then go fully
  				 * to sleep until explicitly woken up
  				 */
! 				if (!sleeping_prematurely(pgdat, order, remaining)) {
! 					restore_pgdat_percpu_threshold(pgdat);
  					schedule();
! 					reduce_pgdat_percpu_threshold(pgdat);
! 				} else {
  					if (remaining)
  						count_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);
  					else
--- 2326,2334 ----
  				 * premature sleep. If not, then go fully
  				 * to sleep until explicitly woken up
  				 */
! 				if (!sleeping_prematurely(pgdat, order, remaining))
  					schedule();
! 				else {
  					if (remaining)
  						count_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);
  					else
***************
*** 2366,2381 ****
  	if (!populated_zone(zone))
  		return;
  
- 	if (!cpuset_zone_allowed_hardwall(zone, GFP_KERNEL))
- 		return;
  	pgdat = zone->zone_pgdat;
  	if (pgdat->kswapd_max_order < order)
  		pgdat->kswapd_max_order = order;
! 	if (!waitqueue_active(&pgdat->kswapd_wait))
  		return;
! 	if (zone_watermark_ok_safe(zone, order, low_wmark_pages(zone), 0, 0))
  		return;
- 
  	wake_up_interruptible(&pgdat->kswapd_wait);
  }
  
--- 2364,2378 ----
  	if (!populated_zone(zone))
  		return;
  
  	pgdat = zone->zone_pgdat;
+ 	if (zone_watermark_ok(zone, order, low_wmark_pages(zone), 0, 0))
+ 		return;
  	if (pgdat->kswapd_max_order < order)
  		pgdat->kswapd_max_order = order;
! 	if (!cpuset_zone_allowed_hardwall(zone, GFP_KERNEL))
  		return;
! 	if (!waitqueue_active(&pgdat->kswapd_wait))
  		return;
  	wake_up_interruptible(&pgdat->kswapd_wait);
  }
  
